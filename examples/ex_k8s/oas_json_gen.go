// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode encodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON as json.
func (s GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON from json.
func (s *GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admissionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.AdmissionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AdmissionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.AdmissionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"clientConfig\"" + ":")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.Comma()
		}
		if s.FailurePolicy.Set {
			e.RawStr("\"failurePolicy\"" + ":")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.Comma()
		}
		if s.MatchPolicy.Set {
			e.RawStr("\"matchPolicy\"" + ":")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.Comma()
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.Comma()
		}
		if s.ObjectSelector.Set {
			e.RawStr("\"objectSelector\"" + ":")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.ReinvocationPolicy.Set {
			e.Comma()
		}
		if s.ReinvocationPolicy.Set {
			e.RawStr("\"reinvocationPolicy\"" + ":")
			s.ReinvocationPolicy.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"sideEffects\"" + ":")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.Comma()
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook = [11]string{
	0:  "admissionReviewVersions",
	1:  "clientConfig",
	2:  "failurePolicy",
	3:  "matchPolicy",
	4:  "name",
	5:  "namespaceSelector",
	6:  "objectSelector",
	7:  "reinvocationPolicy",
	8:  "rules",
	9:  "sideEffects",
	10: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdmissionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admissionReviewVersions\"")
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "failurePolicy":
			if err := func() error {
				s.FailurePolicy.Reset()
				if err := s.FailurePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failurePolicy\"")
			}
		case "matchPolicy":
			if err := func() error {
				s.MatchPolicy.Reset()
				if err := s.MatchPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchPolicy\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "objectSelector":
			if err := func() error {
				s.ObjectSelector.Reset()
				if err := s.ObjectSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectSelector\"")
			}
		case "reinvocationPolicy":
			if err := func() error {
				s.ReinvocationPolicy.Reset()
				if err := s.ReinvocationPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reinvocationPolicy\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIAdmissionregistrationV1RuleWithOperations, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SideEffects = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sideEffects\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Webhooks != nil {
			e.RawStr("\"webhooks\"" + ":")
			e.ArrStart()
			if len(s.Webhooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Webhooks[0]
					elem.Encode(e)
				}
				for _, elem := range s.Webhooks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks = make([]IoK8sAPIAdmissionregistrationV1MutatingWebhook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1MutatingWebhook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Webhooks = append(s.Webhooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1RuleWithOperations) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroups != nil {
			e.RawStr("\"apiGroups\"" + ":")
			e.ArrStart()
			if len(s.ApiGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiGroups[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiGroups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersions != nil {
			e.RawStr("\"apiVersions\"" + ":")
			e.ArrStart()
			if len(s.ApiVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Operations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operations != nil {
			e.RawStr("\"operations\"" + ":")
			e.ArrStart()
			if len(s.Operations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Operations[0]
					e.Str(elem)
				}
				for _, elem := range s.Operations[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources != nil {
			e.RawStr("\"resources\"" + ":")
			e.ArrStart()
			if len(s.Resources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Resources[0]
					e.Str(elem)
				}
				for _, elem := range s.Resources[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Scope.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1RuleWithOperations = [5]string{
	0: "apiGroups",
	1: "apiVersions",
	2: "operations",
	3: "resources",
	4: "scope",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1RuleWithOperations from json.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1RuleWithOperations to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "apiVersions":
			if err := func() error {
				s.ApiVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiVersions = append(s.ApiVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersions\"")
			}
		case "operations":
			if err := func() error {
				s.Operations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1RuleWithOperations")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ServiceReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ServiceReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admissionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.AdmissionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AdmissionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.AdmissionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"clientConfig\"" + ":")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.Comma()
		}
		if s.FailurePolicy.Set {
			e.RawStr("\"failurePolicy\"" + ":")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.Comma()
		}
		if s.MatchPolicy.Set {
			e.RawStr("\"matchPolicy\"" + ":")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.Comma()
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.Comma()
		}
		if s.ObjectSelector.Set {
			e.RawStr("\"objectSelector\"" + ":")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"sideEffects\"" + ":")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.Comma()
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook = [10]string{
	0: "admissionReviewVersions",
	1: "clientConfig",
	2: "failurePolicy",
	3: "matchPolicy",
	4: "name",
	5: "namespaceSelector",
	6: "objectSelector",
	7: "rules",
	8: "sideEffects",
	9: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdmissionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admissionReviewVersions\"")
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "failurePolicy":
			if err := func() error {
				s.FailurePolicy.Reset()
				if err := s.FailurePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failurePolicy\"")
			}
		case "matchPolicy":
			if err := func() error {
				s.MatchPolicy.Reset()
				if err := s.MatchPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchPolicy\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "objectSelector":
			if err := func() error {
				s.ObjectSelector.Reset()
				if err := s.ObjectSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectSelector\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIAdmissionregistrationV1RuleWithOperations, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SideEffects = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sideEffects\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Webhooks != nil {
			e.RawStr("\"webhooks\"" + ":")
			e.ArrStart()
			if len(s.Webhooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Webhooks[0]
					elem.Encode(e)
				}
				for _, elem := range s.Webhooks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks = make([]IoK8sAPIAdmissionregistrationV1ValidatingWebhook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Webhooks = append(s.Webhooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1WebhookClientConfig from json.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1WebhookClientConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1WebhookClientConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiServerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiServerID.Set {
			e.RawStr("\"apiServerID\"" + ":")
			s.ApiServerID.Encode(e)
		}
	}
	{
		if s.DecodableVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DecodableVersions != nil {
			e.RawStr("\"decodableVersions\"" + ":")
			e.ArrStart()
			if len(s.DecodableVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.DecodableVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.DecodableVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EncodingVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncodingVersion.Set {
			e.RawStr("\"encodingVersion\"" + ":")
			s.EncodingVersion.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1ServerStorageVersion = [3]string{
	0: "apiServerID",
	1: "decodableVersions",
	2: "encodingVersion",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiServerID":
			if err := func() error {
				s.ApiServerID.Reset()
				if err := s.ApiServerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiServerID\"")
			}
		case "decodableVersions":
			if err := func() error {
				s.DecodableVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DecodableVersions = append(s.DecodableVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decodableVersions\"")
			}
		case "encodingVersion":
			if err := func() error {
				s.EncodingVersion.Reset()
				if err := s.EncodingVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodingVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionList from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIApiserverinternalV1alpha1StorageVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1StorageVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionSpec = [0]string{}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommonEncodingVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommonEncodingVersion.Set {
			e.RawStr("\"commonEncodingVersion\"" + ":")
			s.CommonEncodingVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StorageVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageVersions != nil {
			e.RawStr("\"storageVersions\"" + ":")
			e.ArrStart()
			if len(s.StorageVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StorageVersions[0]
					elem.Encode(e)
				}
				for _, elem := range s.StorageVersions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionStatus = [3]string{
	0: "commonEncodingVersion",
	1: "conditions",
	2: "storageVersions",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commonEncodingVersion":
			if err := func() error {
				s.CommonEncodingVersion.Reset()
				if err := s.CommonEncodingVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonEncodingVersion\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "storageVersions":
			if err := func() error {
				s.StorageVersions = make([]IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StorageVersions = append(s.StorageVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ControllerRevision) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data != nil {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"revision\"" + ":")
		e.Int64(s.Revision)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision = [5]string{
	0: "apiVersion",
	1: "data",
	2: "kind",
	3: "metadata",
	4: "revision",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevision from json.
func (s *IoK8sAPIAppsV1ControllerRevision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ControllerRevision to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem IoK8sApimachineryPkgRuntimeRawExtension
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "revision":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Revision = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revision\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ControllerRevision")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ControllerRevisionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevisionList from json.
func (s *IoK8sAPIAppsV1ControllerRevisionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ControllerRevisionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1ControllerRevision, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ControllerRevision
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ControllerRevisionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1DaemonSet from json.
func (s *IoK8sAPIAppsV1DaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSet")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetCondition from json.
func (s *IoK8sAPIAppsV1DaemonSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetList from json.
func (s *IoK8sAPIAppsV1DaemonSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1DaemonSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DaemonSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.Comma()
		}
		if s.UpdateStrategy.Set {
			e.RawStr("\"updateStrategy\"" + ":")
			s.UpdateStrategy.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec = [5]string{
	0: "minReadySeconds",
	1: "revisionHistoryLimit",
	2: "selector",
	3: "template",
	4: "updateStrategy",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (s *IoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "updateStrategy":
			if err := func() error {
				s.UpdateStrategy.Reset()
				if err := s.UpdateStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CollisionCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentNumberScheduled\"" + ":")
		e.Int32(s.CurrentNumberScheduled)
	}
	{
		e.Comma()

		e.RawStr("\"desiredNumberScheduled\"" + ":")
		e.Int32(s.DesiredNumberScheduled)
	}
	{
		if s.NumberAvailable.Set {
			e.Comma()
		}
		if s.NumberAvailable.Set {
			e.RawStr("\"numberAvailable\"" + ":")
			s.NumberAvailable.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"numberMisscheduled\"" + ":")
		e.Int32(s.NumberMisscheduled)
	}
	{
		e.Comma()

		e.RawStr("\"numberReady\"" + ":")
		e.Int32(s.NumberReady)
	}
	{
		if s.NumberUnavailable.Set {
			e.Comma()
		}
		if s.NumberUnavailable.Set {
			e.RawStr("\"numberUnavailable\"" + ":")
			s.NumberUnavailable.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.UpdatedNumberScheduled.Set {
			e.Comma()
		}
		if s.UpdatedNumberScheduled.Set {
			e.RawStr("\"updatedNumberScheduled\"" + ":")
			s.UpdatedNumberScheduled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus = [10]string{
	0: "collisionCount",
	1: "conditions",
	2: "currentNumberScheduled",
	3: "desiredNumberScheduled",
	4: "numberAvailable",
	5: "numberMisscheduled",
	6: "numberReady",
	7: "numberUnavailable",
	8: "observedGeneration",
	9: "updatedNumberScheduled",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (s *IoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1DaemonSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DaemonSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentNumberScheduled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentNumberScheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentNumberScheduled\"")
			}
		case "desiredNumberScheduled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredNumberScheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredNumberScheduled\"")
			}
		case "numberAvailable":
			if err := func() error {
				s.NumberAvailable.Reset()
				if err := s.NumberAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberAvailable\"")
			}
		case "numberMisscheduled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.NumberMisscheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberMisscheduled\"")
			}
		case "numberReady":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.NumberReady = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberReady\"")
			}
		case "numberUnavailable":
			if err := func() error {
				s.NumberUnavailable.Reset()
				if err := s.NumberUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberUnavailable\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "updatedNumberScheduled":
			if err := func() error {
				s.UpdatedNumberScheduled.Reset()
				if err := s.UpdatedNumberScheduled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedNumberScheduled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetUpdateStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetUpdateStrategy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1Deployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1Deployment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1Deployment from json.
func (s *IoK8sAPIAppsV1Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1Deployment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1Deployment")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastUpdateTime.Set {
			e.RawStr("\"lastUpdateTime\"" + ":")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentCondition from json.
func (s *IoK8sAPIAppsV1DeploymentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "lastUpdateTime":
			if err := func() error {
				s.LastUpdateTime.Reset()
				if err := s.LastUpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdateTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DeploymentList from json.
func (s *IoK8sAPIAppsV1DeploymentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1Deployment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1Deployment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Paused.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Paused.Set {
			e.RawStr("\"paused\"" + ":")
			s.Paused.Encode(e)
		}
	}
	{
		if s.ProgressDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProgressDeadlineSeconds.Set {
			e.RawStr("\"progressDeadlineSeconds\"" + ":")
			s.ProgressDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		if s.Strategy.Set {
			e.Comma()
		}
		if s.Strategy.Set {
			e.RawStr("\"strategy\"" + ":")
			s.Strategy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec = [8]string{
	0: "minReadySeconds",
	1: "paused",
	2: "progressDeadlineSeconds",
	3: "replicas",
	4: "revisionHistoryLimit",
	5: "selector",
	6: "strategy",
	7: "template",
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (s *IoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "paused":
			if err := func() error {
				s.Paused.Reset()
				if err := s.Paused.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "progressDeadlineSeconds":
			if err := func() error {
				s.ProgressDeadlineSeconds.Reset()
				if err := s.ProgressDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressDeadlineSeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "strategy":
			if err := func() error {
				s.Strategy.Reset()
				if err := s.Strategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.CollisionCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.UnavailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnavailableReplicas.Set {
			e.RawStr("\"unavailableReplicas\"" + ":")
			s.UnavailableReplicas.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedReplicas.Set {
			e.RawStr("\"updatedReplicas\"" + ":")
			s.UpdatedReplicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStatus = [8]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
	6: "unavailableReplicas",
	7: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (s *IoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1DeploymentCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DeploymentCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "unavailableReplicas":
			if err := func() error {
				s.UnavailableReplicas.Reset()
				if err := s.UnavailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unavailableReplicas\"")
			}
		case "updatedReplicas":
			if err := func() error {
				s.UpdatedReplicas.Reset()
				if err := s.UpdatedReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedReplicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (s *IoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentStrategy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSet from json.
func (s *IoK8sAPIAppsV1ReplicaSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSet")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetCondition from json.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetList from json.
func (s *IoK8sAPIAppsV1ReplicaSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1ReplicaSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ReplicaSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		if s.Template.Set {
			e.Comma()
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullyLabeledReplicas.Set {
			e.RawStr("\"fullyLabeledReplicas\"" + ":")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1ReplicaSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ReplicaSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "fullyLabeledReplicas":
			if err := func() error {
				s.FullyLabeledReplicas.Reset()
				if err := s.FullyLabeledReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullyLabeledReplicas\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxSurge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxSurge.Set {
			e.RawStr("\"maxSurge\"" + ":")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDaemonSet = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDaemonSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			if err := func() error {
				s.MaxSurge.Reset()
				if err := s.MaxSurge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSurge\"")
			}
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateDaemonSet")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxSurge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxSurge.Set {
			e.RawStr("\"maxSurge\"" + ":")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDeployment = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDeployment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			if err := func() error {
				s.MaxSurge.Reset()
				if err := s.MaxSurge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSurge\"")
			}
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateDeployment")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy = [1]string{
	0: "partition",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1StatefulSet from json.
func (s *IoK8sAPIAppsV1StatefulSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSet")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetCondition from json.
func (s *IoK8sAPIAppsV1StatefulSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetList from json.
func (s *IoK8sAPIAppsV1StatefulSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1StatefulSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1StatefulSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.PodManagementPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodManagementPolicy.Set {
			e.RawStr("\"podManagementPolicy\"" + ":")
			s.PodManagementPolicy.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"serviceName\"" + ":")
		e.Str(s.ServiceName)
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.Comma()
		}
		if s.UpdateStrategy.Set {
			e.RawStr("\"updateStrategy\"" + ":")
			s.UpdateStrategy.Encode(e)
		}
	}
	{
		if s.VolumeClaimTemplates != nil {
			e.Comma()
		}
		if s.VolumeClaimTemplates != nil {
			e.RawStr("\"volumeClaimTemplates\"" + ":")
			e.ArrStart()
			if len(s.VolumeClaimTemplates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeClaimTemplates[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeClaimTemplates[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec = [9]string{
	0: "minReadySeconds",
	1: "podManagementPolicy",
	2: "replicas",
	3: "revisionHistoryLimit",
	4: "selector",
	5: "serviceName",
	6: "template",
	7: "updateStrategy",
	8: "volumeClaimTemplates",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (s *IoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "podManagementPolicy":
			if err := func() error {
				s.PodManagementPolicy.Reset()
				if err := s.PodManagementPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podManagementPolicy\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "serviceName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ServiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceName\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "updateStrategy":
			if err := func() error {
				s.UpdateStrategy.Reset()
				if err := s.UpdateStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateStrategy\"")
			}
		case "volumeClaimTemplates":
			if err := func() error {
				s.VolumeClaimTemplates = make([]IoK8sAPICoreV1PersistentVolumeClaim, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaim
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeClaimTemplates = append(s.VolumeClaimTemplates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeClaimTemplates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"availableReplicas\"" + ":")
		e.Int32(s.AvailableReplicas)
	}
	{
		if s.CollisionCount.Set {
			e.Comma()
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.Comma()
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.CurrentReplicas.Set {
			e.Comma()
		}
		if s.CurrentReplicas.Set {
			e.RawStr("\"currentReplicas\"" + ":")
			s.CurrentReplicas.Encode(e)
		}
	}
	{
		if s.CurrentRevision.Set {
			e.Comma()
		}
		if s.CurrentRevision.Set {
			e.RawStr("\"currentRevision\"" + ":")
			s.CurrentRevision.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.Comma()
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	{
		if s.UpdateRevision.Set {
			e.Comma()
		}
		if s.UpdateRevision.Set {
			e.RawStr("\"updateRevision\"" + ":")
			s.UpdateRevision.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			e.Comma()
		}
		if s.UpdatedReplicas.Set {
			e.RawStr("\"updatedReplicas\"" + ":")
			s.UpdatedReplicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus = [10]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "currentReplicas",
	4: "currentRevision",
	5: "observedGeneration",
	6: "readyReplicas",
	7: "replicas",
	8: "updateRevision",
	9: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (s *IoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.AvailableReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1StatefulSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1StatefulSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentReplicas":
			if err := func() error {
				s.CurrentReplicas.Reset()
				if err := s.CurrentReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "currentRevision":
			if err := func() error {
				s.CurrentRevision.Reset()
				if err := s.CurrentRevision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentRevision\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "updateRevision":
			if err := func() error {
				s.UpdateRevision.Reset()
				if err := s.UpdateRevision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateRevision\"")
			}
		case "updatedReplicas":
			if err := func() error {
				s.UpdatedReplicas.Reset()
				if err := s.UpdatedReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedReplicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetUpdateStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetUpdateStrategy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscaler")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV1HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	{
		if s.TargetCPUUtilizationPercentage.Set {
			e.Comma()
		}
		if s.TargetCPUUtilizationPercentage.Set {
			e.RawStr("\"targetCPUUtilizationPercentage\"" + ":")
			s.TargetCPUUtilizationPercentage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "minReplicas",
	2: "scaleTargetRef",
	3: "targetCPUUtilizationPercentage",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		case "targetCPUUtilizationPercentage":
			if err := func() error {
				s.TargetCPUUtilizationPercentage.Reset()
				if err := s.TargetCPUUtilizationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetCPUUtilizationPercentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentCPUUtilizationPercentage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentCPUUtilizationPercentage.Set {
			e.RawStr("\"currentCPUUtilizationPercentage\"" + ":")
			s.CurrentCPUUtilizationPercentage.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus = [5]string{
	0: "currentCPUUtilizationPercentage",
	1: "currentReplicas",
	2: "desiredReplicas",
	3: "lastScaleTime",
	4: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentCPUUtilizationPercentage":
			if err := func() error {
				s.CurrentCPUUtilizationPercentage.Reset()
				if err := s.CurrentCPUUtilizationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentCPUUtilizationPercentage\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1Scale) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1Scale = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1Scale from json.
func (s *IoK8sAPIAutoscalingV1Scale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1Scale to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1Scale")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleSpec = [1]string{
	0: "replicas",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1ScaleSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1ScaleSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus = [2]string{
	0: "replicas",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1ScaleStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1ScaleStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.Comma()
		}
		if s.TargetAverageUtilization.Set {
			e.RawStr("\"targetAverageUtilization\"" + ":")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource = [4]string{
	0: "container",
	1: "name",
	2: "targetAverageUtilization",
	3: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "targetAverageUtilization":
			if err := func() error {
				s.TargetAverageUtilization.Reset()
				if err := s.TargetAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageUtilization\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		if s.CurrentAverageUtilization.Set {
			e.Comma()
		}
		if s.CurrentAverageUtilization.Set {
			e.RawStr("\"currentAverageUtilization\"" + ":")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus = [4]string{
	0: "container",
	1: "currentAverageUtilization",
	2: "currentAverageValue",
	3: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "currentAverageUtilization":
			if err := func() error {
				s.CurrentAverageUtilization.Reset()
				if err := s.CurrentAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageUtilization\"")
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.Comma()
		}
		if s.MetricSelector.Set {
			e.RawStr("\"metricSelector\"" + ":")
			s.MetricSelector.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	{
		if s.TargetValue.Set {
			e.Comma()
		}
		if s.TargetValue.Set {
			e.RawStr("\"targetValue\"" + ":")
			s.TargetValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource = [4]string{
	0: "metricName",
	1: "metricSelector",
	2: "targetAverageValue",
	3: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "metricSelector":
			if err := func() error {
				s.MetricSelector.Reset()
				if err := s.MetricSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricSelector\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		case "targetValue":
			if err := func() error {
				s.TargetValue.Reset()
				if err := s.TargetValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ExternalMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentAverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentAverageValue.Set {
			e.RawStr("\"currentAverageValue\"" + ":")
			s.CurrentAverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentValue\"" + ":")
		s.CurrentValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.Comma()
		}
		if s.MetricSelector.Set {
			e.RawStr("\"metricSelector\"" + ":")
			s.MetricSelector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus = [4]string{
	0: "currentAverageValue",
	1: "currentValue",
	2: "metricName",
	3: "metricSelector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			if err := func() error {
				s.CurrentAverageValue.Reset()
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "metricSelector":
			if err := func() error {
				s.MetricSelector.Reset()
				if err := s.MetricSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricSelector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ExternalMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.Comma()
		}
		if s.Metrics != nil {
			e.RawStr("\"metrics\"" + ":")
			e.ArrStart()
			if len(s.Metrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Metrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.Metrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "metrics",
	2: "minReplicas",
	3: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics = make([]IoK8sAPIAutoscalingV2beta1MetricSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1MetricSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.Comma()
		}
		if s.CurrentMetrics != nil {
			e.RawStr("\"currentMetrics\"" + ":")
			e.ArrStart()
			if len(s.CurrentMetrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentMetrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentMetrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentMetrics":
			if err := func() error {
				s.CurrentMetrics = make([]IoK8sAPIAutoscalingV2beta1MetricStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1MetricStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentMetrics = append(s.CurrentMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMetrics\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1MetricSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1MetricSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1MetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1MetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"targetValue\"" + ":")
		s.TargetValue.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource = [5]string{
	0: "averageValue",
	1: "metricName",
	2: "selector",
	3: "target",
	4: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "targetValue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TargetValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ObjectMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentValue\"" + ":")
		s.CurrentValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus = [5]string{
	0: "averageValue",
	1: "currentValue",
	2: "metricName",
	3: "selector",
	4: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ObjectMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetAverageValue\"" + ":")
		s.TargetAverageValue.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource = [3]string{
	0: "metricName",
	1: "selector",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "targetAverageValue":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1PodsMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus = [3]string{
	0: "currentAverageValue",
	1: "metricName",
	2: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1PodsMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.Comma()
		}
		if s.TargetAverageUtilization.Set {
			e.RawStr("\"targetAverageUtilization\"" + ":")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource = [3]string{
	0: "name",
	1: "targetAverageUtilization",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "targetAverageUtilization":
			if err := func() error {
				s.TargetAverageUtilization.Reset()
				if err := s.TargetAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageUtilization\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentAverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentAverageUtilization.Set {
			e.RawStr("\"currentAverageUtilization\"" + ":")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus = [3]string{
	0: "currentAverageUtilization",
	1: "currentAverageValue",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageUtilization":
			if err := func() error {
				s.CurrentAverageUtilization.Reset()
				if err := s.CurrentAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageUtilization\"")
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource = [3]string{
	0: "container",
	1: "name",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus = [3]string{
	0: "container",
	1: "current",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ExternalMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ExternalMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"periodSeconds\"" + ":")
		e.Int32(s.PeriodSeconds)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Int32(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy = [3]string{
	0: "periodSeconds",
	1: "type",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingPolicy from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "periodSeconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PeriodSeconds = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"periodSeconds\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Value = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HPAScalingPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Policies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Policies != nil {
			e.RawStr("\"policies\"" + ":")
			e.ArrStart()
			if len(s.Policies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Policies[0]
					elem.Encode(e)
				}
				for _, elem := range s.Policies[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SelectPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelectPolicy.Set {
			e.RawStr("\"selectPolicy\"" + ":")
			s.SelectPolicy.Encode(e)
		}
	}
	{
		if s.StabilizationWindowSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StabilizationWindowSeconds.Set {
			e.RawStr("\"stabilizationWindowSeconds\"" + ":")
			s.StabilizationWindowSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingRules = [3]string{
	0: "policies",
	1: "selectPolicy",
	2: "stabilizationWindowSeconds",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "policies":
			if err := func() error {
				s.Policies = make([]IoK8sAPIAutoscalingV2beta2HPAScalingPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Policies = append(s.Policies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policies\"")
			}
		case "selectPolicy":
			if err := func() error {
				s.SelectPolicy.Reset()
				if err := s.SelectPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selectPolicy\"")
			}
		case "stabilizationWindowSeconds":
			if err := func() error {
				s.StabilizationWindowSeconds.Reset()
				if err := s.StabilizationWindowSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stabilizationWindowSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HPAScalingRules")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ScaleDown.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleDown.Set {
			e.RawStr("\"scaleDown\"" + ":")
			s.ScaleDown.Encode(e)
		}
	}
	{
		if s.ScaleUp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleUp.Set {
			e.RawStr("\"scaleUp\"" + ":")
			s.ScaleUp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior = [2]string{
	0: "scaleDown",
	1: "scaleUp",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scaleDown":
			if err := func() error {
				s.ScaleDown.Reset()
				if err := s.ScaleDown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleDown\"")
			}
		case "scaleUp":
			if err := func() error {
				s.ScaleUp.Reset()
				if err := s.ScaleUp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleUp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Behavior.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Behavior.Set {
			e.RawStr("\"behavior\"" + ":")
			s.Behavior.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.Comma()
		}
		if s.Metrics != nil {
			e.RawStr("\"metrics\"" + ":")
			e.ArrStart()
			if len(s.Metrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Metrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.Metrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec = [5]string{
	0: "behavior",
	1: "maxReplicas",
	2: "metrics",
	3: "minReplicas",
	4: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "behavior":
			if err := func() error {
				s.Behavior.Reset()
				if err := s.Behavior.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior\"")
			}
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics = make([]IoK8sAPIAutoscalingV2beta2MetricSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2MetricSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.Comma()
		}
		if s.CurrentMetrics != nil {
			e.RawStr("\"currentMetrics\"" + ":")
			e.ArrStart()
			if len(s.CurrentMetrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentMetrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentMetrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentMetrics":
			if err := func() error {
				s.CurrentMetrics = make([]IoK8sAPIAutoscalingV2beta2MetricStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2MetricStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentMetrics = append(s.CurrentMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMetrics\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricIdentifier) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier = [2]string{
	0: "name",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricIdentifier from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricTarget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageUtilization.Set {
			e.RawStr("\"averageUtilization\"" + ":")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget = [4]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "type",
	3: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricTarget from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricTarget to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			if err := func() error {
				s.AverageUtilization.Reset()
				if err := s.AverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageUtilization\"")
			}
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricTarget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricValueStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageUtilization.Set {
			e.RawStr("\"averageUtilization\"" + ":")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricValueStatus = [3]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricValueStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricValueStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			if err := func() error {
				s.AverageUtilization.Reset()
				if err := s.AverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageUtilization\"")
			}
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricValueStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"describedObject\"" + ":")
		s.DescribedObject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource = [3]string{
	0: "describedObject",
	1: "metric",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "describedObject":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DescribedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"describedObject\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ObjectMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"describedObject\"" + ":")
		s.DescribedObject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus = [3]string{
	0: "current",
	1: "describedObject",
	2: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "describedObject":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DescribedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"describedObject\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ObjectMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2PodsMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2PodsMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource = [2]string{
	0: "name",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus = [2]string{
	0: "current",
	1: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1CronJob from json.
func (s *IoK8sAPIBatchV1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJob to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJob")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1CronJobList from json.
func (s *IoK8sAPIBatchV1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1CronJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1CronJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConcurrencyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConcurrencyPolicy.Set {
			e.RawStr("\"concurrencyPolicy\"" + ":")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailedJobsHistoryLimit.Set {
			e.RawStr("\"failedJobsHistoryLimit\"" + ":")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jobTemplate\"" + ":")
		s.JobTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"schedule\"" + ":")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.Comma()
		}
		if s.StartingDeadlineSeconds.Set {
			e.RawStr("\"startingDeadlineSeconds\"" + ":")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.Comma()
		}
		if s.SuccessfulJobsHistoryLimit.Set {
			e.RawStr("\"successfulJobsHistoryLimit\"" + ":")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.Comma()
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (s *IoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			if err := func() error {
				s.ConcurrencyPolicy.Reset()
				if err := s.ConcurrencyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrencyPolicy\"")
			}
		case "failedJobsHistoryLimit":
			if err := func() error {
				s.FailedJobsHistoryLimit.Reset()
				if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedJobsHistoryLimit\"")
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.JobTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobTemplate\"")
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Schedule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "startingDeadlineSeconds":
			if err := func() error {
				s.StartingDeadlineSeconds.Reset()
				if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingDeadlineSeconds\"")
			}
		case "successfulJobsHistoryLimit":
			if err := func() error {
				s.SuccessfulJobsHistoryLimit.Reset()
				if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulJobsHistoryLimit\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active != nil {
			e.RawStr("\"active\"" + ":")
			e.ArrStart()
			if len(s.Active) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Active[0]
					elem.Encode(e)
				}
				for _, elem := range s.Active[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastScheduleTime.Set {
			e.RawStr("\"lastScheduleTime\"" + ":")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastSuccessfulTime.Set {
			e.RawStr("\"lastSuccessfulTime\"" + ":")
			s.LastSuccessfulTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (s *IoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Active = append(s.Active, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "lastScheduleTime":
			if err := func() error {
				s.LastScheduleTime.Reset()
				if err := s.LastScheduleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScheduleTime\"")
			}
		case "lastSuccessfulTime":
			if err := func() error {
				s.LastSuccessfulTime.Reset()
				if err := s.LastSuccessfulTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSuccessfulTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1Job) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1Job = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1Job from json.
func (s *IoK8sAPIBatchV1Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1Job to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1Job")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIBatchV1JobCondition from json.
func (s *IoK8sAPIBatchV1JobCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobCondition) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1JobList from json.
func (s *IoK8sAPIBatchV1JobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1Job, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1Job
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ActiveDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveDeadlineSeconds.Set {
			e.RawStr("\"activeDeadlineSeconds\"" + ":")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.BackoffLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BackoffLimit.Set {
			e.RawStr("\"backoffLimit\"" + ":")
			s.BackoffLimit.Encode(e)
		}
	}
	{
		if s.CompletionMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletionMode.Set {
			e.RawStr("\"completionMode\"" + ":")
			s.CompletionMode.Encode(e)
		}
	}
	{
		if s.Completions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Completions.Set {
			e.RawStr("\"completions\"" + ":")
			s.Completions.Encode(e)
		}
	}
	{
		if s.ManualSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ManualSelector.Set {
			e.RawStr("\"manualSelector\"" + ":")
			s.ManualSelector.Encode(e)
		}
	}
	{
		if s.Parallelism.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parallelism.Set {
			e.RawStr("\"parallelism\"" + ":")
			s.Parallelism.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.TtlSecondsAfterFinished.Set {
			e.Comma()
		}
		if s.TtlSecondsAfterFinished.Set {
			e.RawStr("\"ttlSecondsAfterFinished\"" + ":")
			s.TtlSecondsAfterFinished.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobSpec = [10]string{
	0: "activeDeadlineSeconds",
	1: "backoffLimit",
	2: "completionMode",
	3: "completions",
	4: "manualSelector",
	5: "parallelism",
	6: "selector",
	7: "suspend",
	8: "template",
	9: "ttlSecondsAfterFinished",
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (s *IoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			if err := func() error {
				s.ActiveDeadlineSeconds.Reset()
				if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeDeadlineSeconds\"")
			}
		case "backoffLimit":
			if err := func() error {
				s.BackoffLimit.Reset()
				if err := s.BackoffLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backoffLimit\"")
			}
		case "completionMode":
			if err := func() error {
				s.CompletionMode.Reset()
				if err := s.CompletionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionMode\"")
			}
		case "completions":
			if err := func() error {
				s.Completions.Reset()
				if err := s.Completions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completions\"")
			}
		case "manualSelector":
			if err := func() error {
				s.ManualSelector.Reset()
				if err := s.ManualSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manualSelector\"")
			}
		case "parallelism":
			if err := func() error {
				s.Parallelism.Reset()
				if err := s.Parallelism.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelism\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		case "template":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "ttlSecondsAfterFinished":
			if err := func() error {
				s.TtlSecondsAfterFinished.Reset()
				if err := s.TtlSecondsAfterFinished.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttlSecondsAfterFinished\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.CompletedIndexes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletedIndexes.Set {
			e.RawStr("\"completedIndexes\"" + ":")
			s.CompletedIndexes.Encode(e)
		}
	}
	{
		if s.CompletionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletionTime.Set {
			e.RawStr("\"completionTime\"" + ":")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Failed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Failed.Set {
			e.RawStr("\"failed\"" + ":")
			s.Failed.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartTime.Set {
			e.RawStr("\"startTime\"" + ":")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Succeeded.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Succeeded.Set {
			e.RawStr("\"succeeded\"" + ":")
			s.Succeeded.Encode(e)
		}
	}
	{
		if s.UncountedTerminatedPods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UncountedTerminatedPods.Set {
			e.RawStr("\"uncountedTerminatedPods\"" + ":")
			s.UncountedTerminatedPods.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobStatus = [8]string{
	0: "active",
	1: "completedIndexes",
	2: "completionTime",
	3: "conditions",
	4: "failed",
	5: "startTime",
	6: "succeeded",
	7: "uncountedTerminatedPods",
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (s *IoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "completedIndexes":
			if err := func() error {
				s.CompletedIndexes.Reset()
				if err := s.CompletedIndexes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedIndexes\"")
			}
		case "completionTime":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTime\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIBatchV1JobCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1JobCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "failed":
			if err := func() error {
				s.Failed.Reset()
				if err := s.Failed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "succeeded":
			if err := func() error {
				s.Succeeded.Reset()
				if err := s.Succeeded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"succeeded\"")
			}
		case "uncountedTerminatedPods":
			if err := func() error {
				s.UncountedTerminatedPods.Reset()
				if err := s.UncountedTerminatedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uncountedTerminatedPods\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobTemplateSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Failed != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Failed != nil {
			e.RawStr("\"failed\"" + ":")
			e.ArrStart()
			if len(s.Failed) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Failed[0]
					e.Str(elem)
				}
				for _, elem := range s.Failed[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Succeeded != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Succeeded != nil {
			e.RawStr("\"succeeded\"" + ":")
			e.ArrStart()
			if len(s.Succeeded) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Succeeded[0]
					e.Str(elem)
				}
				for _, elem := range s.Succeeded[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1UncountedTerminatedPods = [2]string{
	0: "failed",
	1: "succeeded",
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1UncountedTerminatedPods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failed":
			if err := func() error {
				s.Failed = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Failed = append(s.Failed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed\"")
			}
		case "succeeded":
			if err := func() error {
				s.Succeeded = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Succeeded = append(s.Succeeded, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"succeeded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1UncountedTerminatedPods")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJob from json.
func (s *IoK8sAPIBatchV1beta1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJob to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJob")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobList from json.
func (s *IoK8sAPIBatchV1beta1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1beta1CronJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1beta1CronJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConcurrencyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConcurrencyPolicy.Set {
			e.RawStr("\"concurrencyPolicy\"" + ":")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailedJobsHistoryLimit.Set {
			e.RawStr("\"failedJobsHistoryLimit\"" + ":")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jobTemplate\"" + ":")
		s.JobTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"schedule\"" + ":")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.Comma()
		}
		if s.StartingDeadlineSeconds.Set {
			e.RawStr("\"startingDeadlineSeconds\"" + ":")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.Comma()
		}
		if s.SuccessfulJobsHistoryLimit.Set {
			e.RawStr("\"successfulJobsHistoryLimit\"" + ":")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.Comma()
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			if err := func() error {
				s.ConcurrencyPolicy.Reset()
				if err := s.ConcurrencyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrencyPolicy\"")
			}
		case "failedJobsHistoryLimit":
			if err := func() error {
				s.FailedJobsHistoryLimit.Reset()
				if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedJobsHistoryLimit\"")
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.JobTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobTemplate\"")
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Schedule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "startingDeadlineSeconds":
			if err := func() error {
				s.StartingDeadlineSeconds.Reset()
				if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingDeadlineSeconds\"")
			}
		case "successfulJobsHistoryLimit":
			if err := func() error {
				s.SuccessfulJobsHistoryLimit.Reset()
				if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulJobsHistoryLimit\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active != nil {
			e.RawStr("\"active\"" + ":")
			e.ArrStart()
			if len(s.Active) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Active[0]
					elem.Encode(e)
				}
				for _, elem := range s.Active[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastScheduleTime.Set {
			e.RawStr("\"lastScheduleTime\"" + ":")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastSuccessfulTime.Set {
			e.RawStr("\"lastSuccessfulTime\"" + ":")
			s.LastSuccessfulTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Active = append(s.Active, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "lastScheduleTime":
			if err := func() error {
				s.LastScheduleTime.Reset()
				if err := s.LastScheduleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScheduleTime\"")
			}
		case "lastSuccessfulTime":
			if err := func() error {
				s.LastSuccessfulTime.Reset()
				if err := s.LastSuccessfulTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSuccessfulTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1JobTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1beta1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1JobTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1JobTemplateSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequest from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastUpdateTime.Set {
			e.RawStr("\"lastUpdateTime\"" + ":")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestCondition from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "lastUpdateTime":
			if err := func() error {
				s.LastUpdateTime.Reset()
				if err := s.LastUpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdateTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestList from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICertificatesV1CertificateSigningRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICertificatesV1CertificateSigningRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ExpirationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		if s.Extra.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Extra.Set {
			e.RawStr("\"extra\"" + ":")
			s.Extra.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"request\"" + ":")
		e.Base64(s.Request)
	}
	{
		e.Comma()

		e.RawStr("\"signerName\"" + ":")
		e.Str(s.SignerName)
	}
	{
		if s.UID.Set {
			e.Comma()
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	{
		if s.Usages != nil {
			e.Comma()
		}
		if s.Usages != nil {
			e.RawStr("\"usages\"" + ":")
			e.ArrStart()
			if len(s.Usages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Usages[0]
					e.Str(elem)
				}
				for _, elem := range s.Usages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec = [8]string{
	0: "expirationSeconds",
	1: "extra",
	2: "groups",
	3: "request",
	4: "signerName",
	5: "uid",
	6: "usages",
	7: "username",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpec from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		case "extra":
			if err := func() error {
				s.Extra.Reset()
				if err := s.Extra.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extra\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "request":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Request = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "signerName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SignerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signerName\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "usages":
			if err := func() error {
				s.Usages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Usages = append(s.Usages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usages\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.ArrStart()
		if len(elem) >= 1 {
			// Encode first element without comma.
			{
				elem := elem[0]
				e.Str(elem)
			}
			for _, elem := range elem[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra = [0]string{}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra from json.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem []string
			if err := func() error {
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"certificate\"" + ":")
		e.Base64(s.Certificate)
	}
	{
		if s.Conditions != nil {
			e.Comma()
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestStatus = [2]string{
	0: "certificate",
	1: "conditions",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				v, err := d.Base64()
				s.Certificate = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICertificatesV1CertificateSigningRequestCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICertificatesV1CertificateSigningRequestCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1Lease) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1Lease = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoordinationV1Lease from json.
func (s *IoK8sAPICoordinationV1Lease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1Lease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1Lease")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1LeaseList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoordinationV1LeaseList from json.
func (s *IoK8sAPICoordinationV1LeaseList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1LeaseList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoordinationV1Lease, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoordinationV1Lease
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1LeaseList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList) {
					name = jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AcquireTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AcquireTime.Set {
			e.RawStr("\"acquireTime\"" + ":")
			s.AcquireTime.Encode(e)
		}
	}
	{
		if s.HolderIdentity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HolderIdentity.Set {
			e.RawStr("\"holderIdentity\"" + ":")
			s.HolderIdentity.Encode(e)
		}
	}
	{
		if s.LeaseDurationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LeaseDurationSeconds.Set {
			e.RawStr("\"leaseDurationSeconds\"" + ":")
			s.LeaseDurationSeconds.Encode(e)
		}
	}
	{
		if s.LeaseTransitions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LeaseTransitions.Set {
			e.RawStr("\"leaseTransitions\"" + ":")
			s.LeaseTransitions.Encode(e)
		}
	}
	{
		if s.RenewTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RenewTime.Set {
			e.RawStr("\"renewTime\"" + ":")
			s.RenewTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseSpec = [5]string{
	0: "acquireTime",
	1: "holderIdentity",
	2: "leaseDurationSeconds",
	3: "leaseTransitions",
	4: "renewTime",
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (s *IoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1LeaseSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acquireTime":
			if err := func() error {
				s.AcquireTime.Reset()
				if err := s.AcquireTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acquireTime\"")
			}
		case "holderIdentity":
			if err := func() error {
				s.HolderIdentity.Reset()
				if err := s.HolderIdentity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"holderIdentity\"")
			}
		case "leaseDurationSeconds":
			if err := func() error {
				s.LeaseDurationSeconds.Reset()
				if err := s.LeaseDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaseDurationSeconds\"")
			}
		case "leaseTransitions":
			if err := func() error {
				s.LeaseTransitions.Reset()
				if err := s.LeaseTransitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaseTransitions\"")
			}
		case "renewTime":
			if err := func() error {
				s.RenewTime.Reset()
				if err := s.RenewTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"renewTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1LeaseSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "readOnly",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Affinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeAffinity.Set {
			e.RawStr("\"nodeAffinity\"" + ":")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PodAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodAffinity.Set {
			e.RawStr("\"podAffinity\"" + ":")
			s.PodAffinity.Encode(e)
		}
	}
	{
		if s.PodAntiAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodAntiAffinity.Set {
			e.RawStr("\"podAntiAffinity\"" + ":")
			s.PodAntiAffinity.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Affinity = [3]string{
	0: "nodeAffinity",
	1: "podAffinity",
	2: "podAntiAffinity",
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (s *IoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Affinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "podAffinity":
			if err := func() error {
				s.PodAffinity.Reset()
				if err := s.PodAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinity\"")
			}
		case "podAntiAffinity":
			if err := func() error {
				s.PodAntiAffinity.Reset()
				if err := s.PodAntiAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAntiAffinity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Affinity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AttachedVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"devicePath\"" + ":")
		e.Str(s.DevicePath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1AttachedVolume from json.
func (s *IoK8sAPICoreV1AttachedVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AttachedVolume to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DevicePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devicePath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AttachedVolume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CachingMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CachingMode.Set {
			e.RawStr("\"cachingMode\"" + ":")
			s.CachingMode.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diskName\"" + ":")
		e.Str(s.DiskName)
	}
	{
		e.Comma()

		e.RawStr("\"diskURI\"" + ":")
		e.Str(s.DiskURI)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource = [6]string{
	0: "cachingMode",
	1: "diskName",
	2: "diskURI",
	3: "fsType",
	4: "kind",
	5: "readOnly",
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cachingMode":
			if err := func() error {
				s.CachingMode.Reset()
				if err := s.CachingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cachingMode\"")
			}
		case "diskName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DiskName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskName\"")
			}
		case "diskURI":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DiskURI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskURI\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"secretName\"" + ":")
		e.Str(s.SecretName)
	}
	{
		if s.SecretNamespace.Set {
			e.Comma()
		}
		if s.SecretNamespace.Set {
			e.RawStr("\"secretNamespace\"" + ":")
			s.SecretNamespace.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"shareName\"" + ":")
		e.Str(s.ShareName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource = [4]string{
	0: "readOnly",
	1: "secretName",
	2: "secretNamespace",
	3: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureFilePersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		case "secretNamespace":
			if err := func() error {
				s.SecretNamespace.Reset()
				if err := s.SecretNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretNamespace\"")
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ShareName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureFilePersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"secretName\"" + ":")
		e.Str(s.SecretName)
	}
	{
		e.Comma()

		e.RawStr("\"shareName\"" + ":")
		e.Str(s.ShareName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource = [3]string{
	0: "readOnly",
	1: "secretName",
	2: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureFileVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShareName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureFileVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ControllerExpandSecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ControllerExpandSecretRef.Set {
			e.RawStr("\"controllerExpandSecretRef\"" + ":")
			s.ControllerExpandSecretRef.Encode(e)
		}
	}
	{
		if s.ControllerPublishSecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ControllerPublishSecretRef.Set {
			e.RawStr("\"controllerPublishSecretRef\"" + ":")
			s.ControllerPublishSecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.Comma()
		}
		if s.NodePublishSecretRef.Set {
			e.RawStr("\"nodePublishSecretRef\"" + ":")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.NodeStageSecretRef.Set {
			e.Comma()
		}
		if s.NodeStageSecretRef.Set {
			e.RawStr("\"nodeStageSecretRef\"" + ":")
			s.NodeStageSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.Comma()
		}
		if s.VolumeAttributes.Set {
			e.RawStr("\"volumeAttributes\"" + ":")
			s.VolumeAttributes.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"volumeHandle\"" + ":")
		e.Str(s.VolumeHandle)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource = [9]string{
	0: "controllerExpandSecretRef",
	1: "controllerPublishSecretRef",
	2: "driver",
	3: "fsType",
	4: "nodePublishSecretRef",
	5: "nodeStageSecretRef",
	6: "readOnly",
	7: "volumeAttributes",
	8: "volumeHandle",
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controllerExpandSecretRef":
			if err := func() error {
				s.ControllerExpandSecretRef.Reset()
				if err := s.ControllerExpandSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllerExpandSecretRef\"")
			}
		case "controllerPublishSecretRef":
			if err := func() error {
				s.ControllerPublishSecretRef.Reset()
				if err := s.ControllerPublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllerPublishSecretRef\"")
			}
		case "driver":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "nodePublishSecretRef":
			if err := func() error {
				s.NodePublishSecretRef.Reset()
				if err := s.NodePublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePublishSecretRef\"")
			}
		case "nodeStageSecretRef":
			if err := func() error {
				s.NodeStageSecretRef.Reset()
				if err := s.NodeStageSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeStageSecretRef\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeAttributes":
			if err := func() error {
				s.VolumeAttributes.Reset()
				if err := s.VolumeAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeAttributes\"")
			}
		case "volumeHandle":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VolumeHandle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeHandle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes = [0]string{}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes from json.
func (s IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.Comma()
		}
		if s.NodePublishSecretRef.Set {
			e.RawStr("\"nodePublishSecretRef\"" + ":")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.Comma()
		}
		if s.VolumeAttributes.Set {
			e.RawStr("\"volumeAttributes\"" + ":")
			s.VolumeAttributes.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "nodePublishSecretRef",
	3: "readOnly",
	4: "volumeAttributes",
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (s *IoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "nodePublishSecretRef":
			if err := func() error {
				s.NodePublishSecretRef.Reset()
				if err := s.NodePublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePublishSecretRef\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeAttributes":
			if err := func() error {
				s.VolumeAttributes.Reset()
				if err := s.VolumeAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeAttributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes = [0]string{}

// Decode decodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes from json.
func (s IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Capabilities) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Add != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Add != nil {
			e.RawStr("\"add\"" + ":")
			e.ArrStart()
			if len(s.Add) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Add[0]
					e.Str(elem)
				}
				for _, elem := range s.Add[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Drop != nil {
			e.RawStr("\"drop\"" + ":")
			e.ArrStart()
			if len(s.Drop) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Drop[0]
					e.Str(elem)
				}
				for _, elem := range s.Drop[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Capabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (s *IoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Capabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			if err := func() error {
				s.Add = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Add = append(s.Add, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Capabilities")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.Comma()
		}
		if s.SecretFile.Set {
			e.RawStr("\"secretFile\"" + ":")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CephFSPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretFile":
			if err := func() error {
				s.SecretFile.Reset()
				if err := s.SecretFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretFile\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CephFSPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.Comma()
		}
		if s.SecretFile.Set {
			e.RawStr("\"secretFile\"" + ":")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CephFSVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretFile":
			if err := func() error {
				s.SecretFile.Reset()
				if err := s.SecretFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretFile\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CephFSVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CinderPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CinderPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (s *IoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CinderVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CinderVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TimeoutSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ClientIPConfig = [1]string{
	0: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (s *IoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ClientIPConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ClientIPConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition = [4]string{
	0: "error",
	1: "message",
	2: "status",
	3: "type",
}

// Decode decodes IoK8sAPICoreV1ComponentCondition from json.
func (s *IoK8sAPICoreV1ComponentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatus = [4]string{
	0: "apiVersion",
	1: "conditions",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatus from json.
func (s *IoK8sAPICoreV1ComponentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1ComponentCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ComponentCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentStatusList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatusList from json.
func (s *IoK8sAPICoreV1ComponentStatusList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentStatusList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ComponentStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ComponentStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentStatusList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMap) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.BinaryData.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BinaryData.Set {
			e.RawStr("\"binaryData\"" + ":")
			s.BinaryData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Immutable.Set {
			e.RawStr("\"immutable\"" + ":")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMap = [6]string{
	0: "apiVersion",
	1: "binaryData",
	2: "data",
	3: "immutable",
	4: "kind",
	5: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMap from json.
func (s *IoK8sAPICoreV1ConfigMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMap to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "binaryData":
			if err := func() error {
				s.BinaryData.Reset()
				if err := s.BinaryData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"binaryData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "immutable":
			if err := func() error {
				s.Immutable.Reset()
				if err := s.Immutable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immutable\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMap")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapBinaryData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Base64(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapBinaryData = [0]string{}

// Decode decodes IoK8sAPICoreV1ConfigMapBinaryData from json.
func (s IoK8sAPICoreV1ConfigMapBinaryData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapBinaryData to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem []byte
			if err := func() error {
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapBinaryData")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapData = [0]string{}

// Decode decodes IoK8sAPICoreV1ConfigMapData from json.
func (s IoK8sAPICoreV1ConfigMapData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapData to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapData")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapEnvSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapEnvSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.Comma()
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapKeySelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapKeySelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMapList from json.
func (s *IoK8sAPICoreV1ConfigMapList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ConfigMap, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ConfigMap
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kubeletConfigKey\"" + ":")
		e.Str(s.KubeletConfigKey)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.ResourceVersion.Set {
			e.Comma()
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.Comma()
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource = [5]string{
	0: "kubeletConfigKey",
	1: "name",
	2: "namespace",
	3: "resourceVersion",
	4: "uid",
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapNodeConfigSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletConfigKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KubeletConfigKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletConfigKey\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapNodeConfigSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (s *IoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapProjection")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "name",
	3: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Container) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Args != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Args != nil {
			e.RawStr("\"args\"" + ":")
			e.ArrStart()
			if len(s.Args) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Args[0]
					e.Str(elem)
				}
				for _, elem := range s.Args[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Env != nil {
			e.RawStr("\"env\"" + ":")
			e.ArrStart()
			if len(s.Env) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Env[0]
					elem.Encode(e)
				}
				for _, elem := range s.Env[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnvFrom != nil {
			e.RawStr("\"envFrom\"" + ":")
			e.ArrStart()
			if len(s.EnvFrom) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EnvFrom[0]
					elem.Encode(e)
				}
				for _, elem := range s.EnvFrom[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Image.Set {
			e.RawStr("\"image\"" + ":")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullPolicy.Set {
			e.RawStr("\"imagePullPolicy\"" + ":")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lifecycle.Set {
			e.RawStr("\"lifecycle\"" + ":")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LivenessProbe.Set {
			e.RawStr("\"livenessProbe\"" + ":")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.Comma()
		}
		if s.ReadinessProbe.Set {
			e.RawStr("\"readinessProbe\"" + ":")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.Comma()
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.Comma()
		}
		if s.StartupProbe.Set {
			e.RawStr("\"startupProbe\"" + ":")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.Comma()
		}
		if s.Stdin.Set {
			e.RawStr("\"stdin\"" + ":")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.Comma()
		}
		if s.StdinOnce.Set {
			e.RawStr("\"stdinOnce\"" + ":")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.Comma()
		}
		if s.TerminationMessagePath.Set {
			e.RawStr("\"terminationMessagePath\"" + ":")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.Comma()
		}
		if s.TerminationMessagePolicy.Set {
			e.RawStr("\"terminationMessagePolicy\"" + ":")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.Comma()
		}
		if s.Tty.Set {
			e.RawStr("\"tty\"" + ":")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.Comma()
		}
		if s.VolumeDevices != nil {
			e.RawStr("\"volumeDevices\"" + ":")
			e.ArrStart()
			if len(s.VolumeDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.Comma()
		}
		if s.VolumeMounts != nil {
			e.RawStr("\"volumeMounts\"" + ":")
			e.ArrStart()
			if len(s.VolumeMounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeMounts[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeMounts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.Comma()
		}
		if s.WorkingDir.Set {
			e.RawStr("\"workingDir\"" + ":")
			s.WorkingDir.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Container = [22]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "terminationMessagePath",
	17: "terminationMessagePolicy",
	18: "tty",
	19: "volumeDevices",
	20: "volumeMounts",
	21: "workingDir",
}

// Decode decodes IoK8sAPICoreV1Container from json.
func (s *IoK8sAPICoreV1Container) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Container to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			if err := func() error {
				s.Args = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Args = append(s.Args, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]IoK8sAPICoreV1EnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "envFrom":
			if err := func() error {
				s.EnvFrom = make([]IoK8sAPICoreV1EnvFromSource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvFromSource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EnvFrom = append(s.EnvFrom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envFrom\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "lifecycle":
			if err := func() error {
				s.Lifecycle.Reset()
				if err := s.Lifecycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycle\"")
			}
		case "livenessProbe":
			if err := func() error {
				s.LivenessProbe.Reset()
				if err := s.LivenessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livenessProbe\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ContainerPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "readinessProbe":
			if err := func() error {
				s.ReadinessProbe.Reset()
				if err := s.ReadinessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessProbe\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "startupProbe":
			if err := func() error {
				s.StartupProbe.Reset()
				if err := s.StartupProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startupProbe\"")
			}
		case "stdin":
			if err := func() error {
				s.Stdin.Reset()
				if err := s.Stdin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdin\"")
			}
		case "stdinOnce":
			if err := func() error {
				s.StdinOnce.Reset()
				if err := s.StdinOnce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdinOnce\"")
			}
		case "terminationMessagePath":
			if err := func() error {
				s.TerminationMessagePath.Reset()
				if err := s.TerminationMessagePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePath\"")
			}
		case "terminationMessagePolicy":
			if err := func() error {
				s.TerminationMessagePolicy.Reset()
				if err := s.TerminationMessagePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePolicy\"")
			}
		case "tty":
			if err := func() error {
				s.Tty.Reset()
				if err := s.Tty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tty\"")
			}
		case "volumeDevices":
			if err := func() error {
				s.VolumeDevices = make([]IoK8sAPICoreV1VolumeDevice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeDevice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeDevices = append(s.VolumeDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeDevices\"")
			}
		case "volumeMounts":
			if err := func() error {
				s.VolumeMounts = make([]IoK8sAPICoreV1VolumeMount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeMount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeMounts = append(s.VolumeMounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMounts\"")
			}
		case "workingDir":
			if err := func() error {
				s.WorkingDir.Reset()
				if err := s.WorkingDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workingDir\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Container")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Container) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Container[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerImage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Names != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Names != nil {
			e.RawStr("\"names\"" + ":")
			e.ArrStart()
			if len(s.Names) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Names[0]
					e.Str(elem)
				}
				for _, elem := range s.Names[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SizeBytes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SizeBytes.Set {
			e.RawStr("\"sizeBytes\"" + ":")
			s.SizeBytes.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerImage = [2]string{
	0: "names",
	1: "sizeBytes",
}

// Decode decodes IoK8sAPICoreV1ContainerImage from json.
func (s *IoK8sAPICoreV1ContainerImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerImage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "sizeBytes":
			if err := func() error {
				s.SizeBytes.Reset()
				if err := s.SizeBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerImage")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"containerPort\"" + ":")
		e.Int32(s.ContainerPort)
	}
	{
		if s.HostIP.Set {
			e.Comma()
		}
		if s.HostIP.Set {
			e.RawStr("\"hostIP\"" + ":")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.HostPort.Set {
			e.Comma()
		}
		if s.HostPort.Set {
			e.RawStr("\"hostPort\"" + ":")
			s.HostPort.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerPort = [5]string{
	0: "containerPort",
	1: "hostIP",
	2: "hostPort",
	3: "name",
	4: "protocol",
}

// Decode decodes IoK8sAPICoreV1ContainerPort from json.
func (s *IoK8sAPICoreV1ContainerPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerPort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerPort":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ContainerPort = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerPort\"")
			}
		case "hostIP":
			if err := func() error {
				s.HostIP.Reset()
				if err := s.HostIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIP\"")
			}
		case "hostPort":
			if err := func() error {
				s.HostPort.Reset()
				if err := s.HostPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPort\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerPort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerState) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Running.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Running.Set {
			e.RawStr("\"running\"" + ":")
			s.Running.Encode(e)
		}
	}
	{
		if s.Terminated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminated.Set {
			e.RawStr("\"terminated\"" + ":")
			s.Terminated.Encode(e)
		}
	}
	{
		if s.Waiting.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Waiting.Set {
			e.RawStr("\"waiting\"" + ":")
			s.Waiting.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerState = [3]string{
	0: "running",
	1: "terminated",
	2: "waiting",
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (s *IoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerState to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "running":
			if err := func() error {
				s.Running.Reset()
				if err := s.Running.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running\"")
			}
		case "terminated":
			if err := func() error {
				s.Terminated.Reset()
				if err := s.Terminated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminated\"")
			}
		case "waiting":
			if err := func() error {
				s.Waiting.Reset()
				if err := s.Waiting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"waiting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerState")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.StartedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartedAt.Set {
			e.RawStr("\"startedAt\"" + ":")
			s.StartedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateRunning = [1]string{
	0: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (s *IoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateRunning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startedAt":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateRunning")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerID.Set {
			e.RawStr("\"containerID\"" + ":")
			s.ContainerID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"exitCode\"" + ":")
		e.Int32(s.ExitCode)
	}
	{
		if s.FinishedAt.Set {
			e.Comma()
		}
		if s.FinishedAt.Set {
			e.RawStr("\"finishedAt\"" + ":")
			s.FinishedAt.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signal.Set {
			e.Comma()
		}
		if s.Signal.Set {
			e.RawStr("\"signal\"" + ":")
			s.Signal.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"startedAt\"" + ":")
			s.StartedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated = [7]string{
	0: "containerID",
	1: "exitCode",
	2: "finishedAt",
	3: "message",
	4: "reason",
	5: "signal",
	6: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (s *IoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateTerminated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerID\"")
			}
		case "exitCode":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ExitCode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exitCode\"")
			}
		case "finishedAt":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finishedAt\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signal":
			if err := func() error {
				s.Signal.Reset()
				if err := s.Signal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal\"")
			}
		case "startedAt":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateTerminated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateWaiting = [2]string{
	0: "message",
	1: "reason",
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (s *IoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateWaiting to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateWaiting")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerID.Set {
			e.RawStr("\"containerID\"" + ":")
			s.ContainerID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		e.Comma()

		e.RawStr("\"imageID\"" + ":")
		e.Str(s.ImageID)
	}
	{
		if s.LastState.Set {
			e.Comma()
		}
		if s.LastState.Set {
			e.RawStr("\"lastState\"" + ":")
			s.LastState.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"ready\"" + ":")
		e.Bool(s.Ready)
	}
	{
		e.Comma()

		e.RawStr("\"restartCount\"" + ":")
		e.Int32(s.RestartCount)
	}
	{
		if s.Started.Set {
			e.Comma()
		}
		if s.Started.Set {
			e.RawStr("\"started\"" + ":")
			s.Started.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.Comma()
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus = [9]string{
	0: "containerID",
	1: "image",
	2: "imageID",
	3: "lastState",
	4: "name",
	5: "ready",
	6: "restartCount",
	7: "started",
	8: "state",
}

// Decode decodes IoK8sAPICoreV1ContainerStatus from json.
func (s *IoK8sAPICoreV1ContainerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerID\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imageID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ImageID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageID\"")
			}
		case "lastState":
			if err := func() error {
				s.LastState.Reset()
				if err := s.LastState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastState\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ready":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Ready = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "restartCount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.RestartCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restartCount\"")
			}
		case "started":
			if err := func() error {
				s.Started.Reset()
				if err := s.Started.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"Port\"" + ":")
		e.Int32(s.Port)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint = [1]string{
	0: "Port",
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (s *IoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DaemonEndpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Port":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DaemonEndpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIProjection = [1]string{
	0: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (s *IoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1DownwardAPIVolumeFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1DownwardAPIVolumeFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIProjection")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIVolumeFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldRef.Set {
			e.RawStr("\"fieldRef\"" + ":")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ResourceFieldRef.Set {
			e.Comma()
		}
		if s.ResourceFieldRef.Set {
			e.RawStr("\"resourceFieldRef\"" + ":")
			s.ResourceFieldRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile = [4]string{
	0: "fieldRef",
	1: "mode",
	2: "path",
	3: "resourceFieldRef",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeFile from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldRef":
			if err := func() error {
				s.FieldRef.Reset()
				if err := s.FieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldRef\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "resourceFieldRef":
			if err := func() error {
				s.ResourceFieldRef.Reset()
				if err := s.ResourceFieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFieldRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIVolumeFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeSource = [2]string{
	0: "defaultMode",
	1: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1DownwardAPIVolumeFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1DownwardAPIVolumeFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Medium.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Medium.Set {
			e.RawStr("\"medium\"" + ":")
			s.Medium.Encode(e)
		}
	}
	{
		if s.SizeLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SizeLimit.Set {
			e.RawStr("\"sizeLimit\"" + ":")
			s.SizeLimit.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EmptyDirVolumeSource = [2]string{
	0: "medium",
	1: "sizeLimit",
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EmptyDirVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "medium":
			if err := func() error {
				s.Medium.Reset()
				if err := s.Medium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"medium\"")
			}
		case "sizeLimit":
			if err := func() error {
				s.SizeLimit.Reset()
				if err := s.SizeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EmptyDirVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointAddress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostname.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ip\"" + ":")
		e.Str(s.IP)
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress = [4]string{
	0: "hostname",
	1: "ip",
	2: "nodeName",
	3: "targetRef",
}

// Decode decodes IoK8sAPICoreV1EndpointAddress from json.
func (s *IoK8sAPICoreV1EndpointAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "ip":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPICoreV1EndpointPort from json.
func (s *IoK8sAPICoreV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointPort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointPort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointSubset) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Addresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Addresses != nil {
			e.RawStr("\"addresses\"" + ":")
			e.ArrStart()
			if len(s.Addresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Addresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.Addresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NotReadyAddresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotReadyAddresses != nil {
			e.RawStr("\"notReadyAddresses\"" + ":")
			e.ArrStart()
			if len(s.NotReadyAddresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NotReadyAddresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.NotReadyAddresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointSubset = [3]string{
	0: "addresses",
	1: "notReadyAddresses",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1EndpointSubset from json.
func (s *IoK8sAPICoreV1EndpointSubset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointSubset to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			if err := func() error {
				s.Addresses = make([]IoK8sAPICoreV1EndpointAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "notReadyAddresses":
			if err := func() error {
				s.NotReadyAddresses = make([]IoK8sAPICoreV1EndpointAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NotReadyAddresses = append(s.NotReadyAddresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notReadyAddresses\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointSubset")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Endpoints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Subsets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subsets != nil {
			e.RawStr("\"subsets\"" + ":")
			e.ArrStart()
			if len(s.Subsets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subsets[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subsets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Endpoints = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "subsets",
}

// Decode decodes IoK8sAPICoreV1Endpoints from json.
func (s *IoK8sAPICoreV1Endpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Endpoints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "subsets":
			if err := func() error {
				s.Subsets = make([]IoK8sAPICoreV1EndpointSubset, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointSubset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subsets = append(s.Subsets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subsets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Endpoints")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointsList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EndpointsList from json.
func (s *IoK8sAPICoreV1EndpointsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Endpoints, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Endpoints
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointsList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvFromSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMapRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMapRef.Set {
			e.RawStr("\"configMapRef\"" + ":")
			s.ConfigMapRef.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Prefix.Set {
			e.RawStr("\"prefix\"" + ":")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvFromSource = [3]string{
	0: "configMapRef",
	1: "prefix",
	2: "secretRef",
}

// Decode decodes IoK8sAPICoreV1EnvFromSource from json.
func (s *IoK8sAPICoreV1EnvFromSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvFromSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapRef":
			if err := func() error {
				s.ConfigMapRef.Reset()
				if err := s.ConfigMapRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMapRef\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvFromSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvVar) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValueFrom.Set {
			e.Comma()
		}
		if s.ValueFrom.Set {
			e.RawStr("\"valueFrom\"" + ":")
			s.ValueFrom.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVar = [3]string{
	0: "name",
	1: "value",
	2: "valueFrom",
}

// Decode decodes IoK8sAPICoreV1EnvVar from json.
func (s *IoK8sAPICoreV1EnvVar) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvVar to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "valueFrom":
			if err := func() error {
				s.ValueFrom.Reset()
				if err := s.ValueFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueFrom\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvVar")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EnvVar) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EnvVar[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvVarSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMapKeyRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMapKeyRef.Set {
			e.RawStr("\"configMapKeyRef\"" + ":")
			s.ConfigMapKeyRef.Encode(e)
		}
	}
	{
		if s.FieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldRef.Set {
			e.RawStr("\"fieldRef\"" + ":")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.ResourceFieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceFieldRef.Set {
			e.RawStr("\"resourceFieldRef\"" + ":")
			s.ResourceFieldRef.Encode(e)
		}
	}
	{
		if s.SecretKeyRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretKeyRef.Set {
			e.RawStr("\"secretKeyRef\"" + ":")
			s.SecretKeyRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVarSource = [4]string{
	0: "configMapKeyRef",
	1: "fieldRef",
	2: "resourceFieldRef",
	3: "secretKeyRef",
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (s *IoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvVarSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapKeyRef":
			if err := func() error {
				s.ConfigMapKeyRef.Reset()
				if err := s.ConfigMapKeyRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMapKeyRef\"")
			}
		case "fieldRef":
			if err := func() error {
				s.FieldRef.Reset()
				if err := s.FieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldRef\"")
			}
		case "resourceFieldRef":
			if err := func() error {
				s.ResourceFieldRef.Reset()
				if err := s.ResourceFieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFieldRef\"")
			}
		case "secretKeyRef":
			if err := func() error {
				s.SecretKeyRef.Reset()
				if err := s.SecretKeyRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretKeyRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvVarSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EphemeralContainer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Args != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Args != nil {
			e.RawStr("\"args\"" + ":")
			e.ArrStart()
			if len(s.Args) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Args[0]
					e.Str(elem)
				}
				for _, elem := range s.Args[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Env != nil {
			e.RawStr("\"env\"" + ":")
			e.ArrStart()
			if len(s.Env) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Env[0]
					elem.Encode(e)
				}
				for _, elem := range s.Env[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnvFrom != nil {
			e.RawStr("\"envFrom\"" + ":")
			e.ArrStart()
			if len(s.EnvFrom) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EnvFrom[0]
					elem.Encode(e)
				}
				for _, elem := range s.EnvFrom[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Image.Set {
			e.RawStr("\"image\"" + ":")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullPolicy.Set {
			e.RawStr("\"imagePullPolicy\"" + ":")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lifecycle.Set {
			e.RawStr("\"lifecycle\"" + ":")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LivenessProbe.Set {
			e.RawStr("\"livenessProbe\"" + ":")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.Comma()
		}
		if s.ReadinessProbe.Set {
			e.RawStr("\"readinessProbe\"" + ":")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.Comma()
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.Comma()
		}
		if s.StartupProbe.Set {
			e.RawStr("\"startupProbe\"" + ":")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.Comma()
		}
		if s.Stdin.Set {
			e.RawStr("\"stdin\"" + ":")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.Comma()
		}
		if s.StdinOnce.Set {
			e.RawStr("\"stdinOnce\"" + ":")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TargetContainerName.Set {
			e.Comma()
		}
		if s.TargetContainerName.Set {
			e.RawStr("\"targetContainerName\"" + ":")
			s.TargetContainerName.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.Comma()
		}
		if s.TerminationMessagePath.Set {
			e.RawStr("\"terminationMessagePath\"" + ":")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.Comma()
		}
		if s.TerminationMessagePolicy.Set {
			e.RawStr("\"terminationMessagePolicy\"" + ":")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.Comma()
		}
		if s.Tty.Set {
			e.RawStr("\"tty\"" + ":")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.Comma()
		}
		if s.VolumeDevices != nil {
			e.RawStr("\"volumeDevices\"" + ":")
			e.ArrStart()
			if len(s.VolumeDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.Comma()
		}
		if s.VolumeMounts != nil {
			e.RawStr("\"volumeMounts\"" + ":")
			e.ArrStart()
			if len(s.VolumeMounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeMounts[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeMounts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.Comma()
		}
		if s.WorkingDir.Set {
			e.RawStr("\"workingDir\"" + ":")
			s.WorkingDir.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer = [23]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "targetContainerName",
	17: "terminationMessagePath",
	18: "terminationMessagePolicy",
	19: "tty",
	20: "volumeDevices",
	21: "volumeMounts",
	22: "workingDir",
}

// Decode decodes IoK8sAPICoreV1EphemeralContainer from json.
func (s *IoK8sAPICoreV1EphemeralContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EphemeralContainer to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			if err := func() error {
				s.Args = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Args = append(s.Args, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]IoK8sAPICoreV1EnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "envFrom":
			if err := func() error {
				s.EnvFrom = make([]IoK8sAPICoreV1EnvFromSource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvFromSource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EnvFrom = append(s.EnvFrom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envFrom\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "lifecycle":
			if err := func() error {
				s.Lifecycle.Reset()
				if err := s.Lifecycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycle\"")
			}
		case "livenessProbe":
			if err := func() error {
				s.LivenessProbe.Reset()
				if err := s.LivenessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livenessProbe\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ContainerPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "readinessProbe":
			if err := func() error {
				s.ReadinessProbe.Reset()
				if err := s.ReadinessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessProbe\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "startupProbe":
			if err := func() error {
				s.StartupProbe.Reset()
				if err := s.StartupProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startupProbe\"")
			}
		case "stdin":
			if err := func() error {
				s.Stdin.Reset()
				if err := s.Stdin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdin\"")
			}
		case "stdinOnce":
			if err := func() error {
				s.StdinOnce.Reset()
				if err := s.StdinOnce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdinOnce\"")
			}
		case "targetContainerName":
			if err := func() error {
				s.TargetContainerName.Reset()
				if err := s.TargetContainerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetContainerName\"")
			}
		case "terminationMessagePath":
			if err := func() error {
				s.TerminationMessagePath.Reset()
				if err := s.TerminationMessagePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePath\"")
			}
		case "terminationMessagePolicy":
			if err := func() error {
				s.TerminationMessagePolicy.Reset()
				if err := s.TerminationMessagePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePolicy\"")
			}
		case "tty":
			if err := func() error {
				s.Tty.Reset()
				if err := s.Tty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tty\"")
			}
		case "volumeDevices":
			if err := func() error {
				s.VolumeDevices = make([]IoK8sAPICoreV1VolumeDevice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeDevice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeDevices = append(s.VolumeDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeDevices\"")
			}
		case "volumeMounts":
			if err := func() error {
				s.VolumeMounts = make([]IoK8sAPICoreV1VolumeMount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeMount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeMounts = append(s.VolumeMounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMounts\"")
			}
		case "workingDir":
			if err := func() error {
				s.WorkingDir.Reset()
				if err := s.WorkingDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workingDir\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EphemeralContainer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.VolumeClaimTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeClaimTemplate.Set {
			e.RawStr("\"volumeClaimTemplate\"" + ":")
			s.VolumeClaimTemplate.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralVolumeSource = [1]string{
	0: "volumeClaimTemplate",
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EphemeralVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "volumeClaimTemplate":
			if err := func() error {
				s.VolumeClaimTemplate.Reset()
				if err := s.VolumeClaimTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeClaimTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EphemeralVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	{
		if s.EventTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventTime.Set {
			e.RawStr("\"eventTime\"" + ":")
			s.EventTime.Encode(e)
		}
	}
	{
		if s.FirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FirstTimestamp.Set {
			e.RawStr("\"firstTimestamp\"" + ":")
			s.FirstTimestamp.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"involvedObject\"" + ":")
		s.InvolvedObject.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.LastTimestamp.Set {
			e.Comma()
		}
		if s.LastTimestamp.Set {
			e.RawStr("\"lastTimestamp\"" + ":")
			s.LastTimestamp.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"metadata\"" + ":")
		s.Metadata.Encode(e)
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingComponent.Set {
			e.Comma()
		}
		if s.ReportingComponent.Set {
			e.RawStr("\"reportingComponent\"" + ":")
			s.ReportingComponent.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "count",
	3:  "eventTime",
	4:  "firstTimestamp",
	5:  "involvedObject",
	6:  "kind",
	7:  "lastTimestamp",
	8:  "message",
	9:  "metadata",
	10: "reason",
	11: "related",
	12: "reportingComponent",
	13: "reportingInstance",
	14: "series",
	15: "source",
	16: "type",
}

// Decode decodes IoK8sAPICoreV1Event from json.
func (s *IoK8sAPICoreV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "eventTime":
			if err := func() error {
				s.EventTime.Reset()
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "firstTimestamp":
			if err := func() error {
				s.FirstTimestamp.Reset()
				if err := s.FirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTimestamp\"")
			}
		case "involvedObject":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.InvolvedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"involvedObject\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "lastTimestamp":
			if err := func() error {
				s.LastTimestamp.Reset()
				if err := s.LastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTimestamp\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingComponent":
			if err := func() error {
				s.ReportingComponent.Reset()
				if err := s.ReportingComponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingComponent\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100000,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Event) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EventList from json.
func (s *IoK8sAPICoreV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EventList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	{
		if s.LastObservedTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastObservedTime.Set {
			e.RawStr("\"lastObservedTime\"" + ":")
			s.LastObservedTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (s *IoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventSeries to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			if err := func() error {
				s.LastObservedTime.Reset()
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventSeries")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Component.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Component.Set {
			e.RawStr("\"component\"" + ":")
			s.Component.Encode(e)
		}
	}
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSource = [2]string{
	0: "component",
	1: "host",
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (s *IoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			if err := func() error {
				s.Component.Reset()
				if err := s.Component.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ExecAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ExecAction = [1]string{
	0: "command",
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (s *IoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ExecAction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ExecAction")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Lun.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lun.Set {
			e.RawStr("\"lun\"" + ":")
			s.Lun.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.TargetWWNs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetWWNs != nil {
			e.RawStr("\"targetWWNs\"" + ":")
			e.ArrStart()
			if len(s.TargetWWNs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TargetWWNs[0]
					e.Str(elem)
				}
				for _, elem := range s.TargetWWNs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Wwids != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Wwids != nil {
			e.RawStr("\"wwids\"" + ":")
			e.ArrStart()
			if len(s.Wwids) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Wwids[0]
					e.Str(elem)
				}
				for _, elem := range s.Wwids[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FCVolumeSource = [5]string{
	0: "fsType",
	1: "lun",
	2: "readOnly",
	3: "targetWWNs",
	4: "wwids",
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (s *IoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FCVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "lun":
			if err := func() error {
				s.Lun.Reset()
				if err := s.Lun.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "targetWWNs":
			if err := func() error {
				s.TargetWWNs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TargetWWNs = append(s.TargetWWNs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetWWNs\"")
			}
		case "wwids":
			if err := func() error {
				s.Wwids = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Wwids = append(s.Wwids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wwids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FCVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.Comma()
		}
		if s.Options.Set {
			e.RawStr("\"options\"" + ":")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSourceOptions = [0]string{}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions from json.
func (s IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexPersistentVolumeSourceOptions to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexPersistentVolumeSourceOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.Comma()
		}
		if s.Options.Set {
			e.RawStr("\"options\"" + ":")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (s *IoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSourceOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSourceOptions = [0]string{}

// Decode decodes IoK8sAPICoreV1FlexVolumeSourceOptions from json.
func (s IoK8sAPICoreV1FlexVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexVolumeSourceOptions to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexVolumeSourceOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DatasetName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DatasetName.Set {
			e.RawStr("\"datasetName\"" + ":")
			s.DatasetName.Encode(e)
		}
	}
	{
		if s.DatasetUUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DatasetUUID.Set {
			e.RawStr("\"datasetUUID\"" + ":")
			s.DatasetUUID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlockerVolumeSource = [2]string{
	0: "datasetName",
	1: "datasetUUID",
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (s *IoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlockerVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datasetName":
			if err := func() error {
				s.DatasetName.Reset()
				if err := s.DatasetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datasetName\"")
			}
		case "datasetUUID":
			if err := func() error {
				s.DatasetUUID.Reset()
				if err := s.DatasetUUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datasetUUID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlockerVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pdName\"" + ":")
		e.Str(s.PdName)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "pdName",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		case "pdName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PdName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdName\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GCEPersistentDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Directory.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Directory.Set {
			e.RawStr("\"directory\"" + ":")
			s.Directory.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repository\"" + ":")
		e.Str(s.Repository)
	}
	{
		if s.Revision.Set {
			e.Comma()
		}
		if s.Revision.Set {
			e.RawStr("\"revision\"" + ":")
			s.Revision.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource = [3]string{
	0: "directory",
	1: "repository",
	2: "revision",
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GitRepoVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "directory":
			if err := func() error {
				s.Directory.Reset()
				if err := s.Directory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directory\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Repository = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "revision":
			if err := func() error {
				s.Revision.Reset()
				if err := s.Revision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revision\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GitRepoVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"endpoints\"" + ":")
		e.Str(s.Endpoints)
	}
	{
		if s.EndpointsNamespace.Set {
			e.Comma()
		}
		if s.EndpointsNamespace.Set {
			e.RawStr("\"endpointsNamespace\"" + ":")
			s.EndpointsNamespace.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource = [4]string{
	0: "endpoints",
	1: "endpointsNamespace",
	2: "path",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Endpoints = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "endpointsNamespace":
			if err := func() error {
				s.EndpointsNamespace.Reset()
				if err := s.EndpointsNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpointsNamespace\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GlusterfsPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"endpoints\"" + ":")
		e.Str(s.Endpoints)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource = [3]string{
	0: "endpoints",
	1: "path",
	2: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GlusterfsVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Endpoints = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GlusterfsVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.HttpHeaders != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpHeaders != nil {
			e.RawStr("\"httpHeaders\"" + ":")
			e.ArrStart()
			if len(s.HttpHeaders) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HttpHeaders[0]
					elem.Encode(e)
				}
				for _, elem := range s.HttpHeaders[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		s.Port.Encode(e)
	}
	{
		if s.Scheme.Set {
			e.Comma()
		}
		if s.Scheme.Set {
			e.RawStr("\"scheme\"" + ":")
			s.Scheme.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction = [5]string{
	0: "host",
	1: "httpHeaders",
	2: "path",
	3: "port",
	4: "scheme",
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (s *IoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HTTPGetAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "httpHeaders":
			if err := func() error {
				s.HttpHeaders = make([]IoK8sAPICoreV1HTTPHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1HTTPHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HttpHeaders = append(s.HttpHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpHeaders\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "scheme":
			if err := func() error {
				s.Scheme.Reset()
				if err := s.Scheme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheme\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HTTPGetAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HTTPHeader) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1HTTPHeader from json.
func (s *IoK8sAPICoreV1HTTPHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HTTPHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HTTPHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Handler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Exec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exec.Set {
			e.RawStr("\"exec\"" + ":")
			s.Exec.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpGet.Set {
			e.RawStr("\"httpGet\"" + ":")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TcpSocket.Set {
			e.RawStr("\"tcpSocket\"" + ":")
			s.TcpSocket.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Handler = [3]string{
	0: "exec",
	1: "httpGet",
	2: "tcpSocket",
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (s *IoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Handler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			if err := func() error {
				s.Exec.Reset()
				if err := s.Exec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exec\"")
			}
		case "httpGet":
			if err := func() error {
				s.HttpGet.Reset()
				if err := s.HttpGet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpGet\"")
			}
		case "tcpSocket":
			if err := func() error {
				s.TcpSocket.Reset()
				if err := s.TcpSocket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tcpSocket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Handler")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HostAlias) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostnames != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostnames != nil {
			e.RawStr("\"hostnames\"" + ":")
			e.ArrStart()
			if len(s.Hostnames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hostnames[0]
					e.Str(elem)
				}
				for _, elem := range s.Hostnames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HostAlias = [2]string{
	0: "hostnames",
	1: "ip",
}

// Decode decodes IoK8sAPICoreV1HostAlias from json.
func (s *IoK8sAPICoreV1HostAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HostAlias to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostnames":
			if err := func() error {
				s.Hostnames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostnames = append(s.Hostnames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostnames\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HostAlias")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource = [2]string{
	0: "path",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (s *IoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HostPathVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HostPathVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChapAuthDiscovery.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthDiscovery.Set {
			e.RawStr("\"chapAuthDiscovery\"" + ":")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthSession.Set {
			e.RawStr("\"chapAuthSession\"" + ":")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitiatorName.Set {
			e.RawStr("\"initiatorName\"" + ":")
			s.InitiatorName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"iqn\"" + ":")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.Comma()
		}
		if s.IscsiInterface.Set {
			e.RawStr("\"iscsiInterface\"" + ":")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lun\"" + ":")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.Comma()
		}
		if s.Portals != nil {
			e.RawStr("\"portals\"" + ":")
			e.ArrStart()
			if len(s.Portals) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Portals[0]
					e.Str(elem)
				}
				for _, elem := range s.Portals[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetPortal\"" + ":")
		e.Str(s.TargetPortal)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ISCSIPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			if err := func() error {
				s.ChapAuthDiscovery.Reset()
				if err := s.ChapAuthDiscovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthDiscovery\"")
			}
		case "chapAuthSession":
			if err := func() error {
				s.ChapAuthSession.Reset()
				if err := s.ChapAuthSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthSession\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "initiatorName":
			if err := func() error {
				s.InitiatorName.Reset()
				if err := s.InitiatorName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiatorName\"")
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Iqn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iqn\"")
			}
		case "iscsiInterface":
			if err := func() error {
				s.IscsiInterface.Reset()
				if err := s.IscsiInterface.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsiInterface\"")
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Lun = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "portals":
			if err := func() error {
				s.Portals = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Portals = append(s.Portals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portals\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetPortal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPortal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ISCSIPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChapAuthDiscovery.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthDiscovery.Set {
			e.RawStr("\"chapAuthDiscovery\"" + ":")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthSession.Set {
			e.RawStr("\"chapAuthSession\"" + ":")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitiatorName.Set {
			e.RawStr("\"initiatorName\"" + ":")
			s.InitiatorName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"iqn\"" + ":")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.Comma()
		}
		if s.IscsiInterface.Set {
			e.RawStr("\"iscsiInterface\"" + ":")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lun\"" + ":")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.Comma()
		}
		if s.Portals != nil {
			e.RawStr("\"portals\"" + ":")
			e.ArrStart()
			if len(s.Portals) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Portals[0]
					e.Str(elem)
				}
				for _, elem := range s.Portals[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetPortal\"" + ":")
		e.Str(s.TargetPortal)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ISCSIVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			if err := func() error {
				s.ChapAuthDiscovery.Reset()
				if err := s.ChapAuthDiscovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthDiscovery\"")
			}
		case "chapAuthSession":
			if err := func() error {
				s.ChapAuthSession.Reset()
				if err := s.ChapAuthSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthSession\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "initiatorName":
			if err := func() error {
				s.InitiatorName.Reset()
				if err := s.InitiatorName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiatorName\"")
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Iqn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iqn\"")
			}
		case "iscsiInterface":
			if err := func() error {
				s.IscsiInterface.Reset()
				if err := s.IscsiInterface.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsiInterface\"")
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Lun = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "portals":
			if err := func() error {
				s.Portals = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Portals = append(s.Portals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portals\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetPortal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPortal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ISCSIVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1KeyToPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Mode.Set {
			e.Comma()
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1KeyToPath = [3]string{
	0: "key",
	1: "mode",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1KeyToPath from json.
func (s *IoK8sAPICoreV1KeyToPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1KeyToPath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1KeyToPath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1KeyToPath) {
					name = jsonFieldsNameOfIoK8sAPICoreV1KeyToPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Lifecycle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PostStart.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PostStart.Set {
			e.RawStr("\"postStart\"" + ":")
			s.PostStart.Encode(e)
		}
	}
	{
		if s.PreStop.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreStop.Set {
			e.RawStr("\"preStop\"" + ":")
			s.PreStop.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Lifecycle = [2]string{
	0: "postStart",
	1: "preStop",
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (s *IoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Lifecycle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "postStart":
			if err := func() error {
				s.PostStart.Reset()
				if err := s.PostStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postStart\"")
			}
		case "preStop":
			if err := func() error {
				s.PreStop.Reset()
				if err := s.PreStop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preStop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Lifecycle")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRange = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoreV1LimitRange from json.
func (s *IoK8sAPICoreV1LimitRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRange")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.DefaultRequest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultRequest.Set {
			e.RawStr("\"defaultRequest\"" + ":")
			s.DefaultRequest.Encode(e)
		}
	}
	{
		if s.Max.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Max.Set {
			e.RawStr("\"max\"" + ":")
			s.Max.Encode(e)
		}
	}
	{
		if s.MaxLimitRequestRatio.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxLimitRequestRatio.Set {
			e.RawStr("\"maxLimitRequestRatio\"" + ":")
			s.MaxLimitRequestRatio.Encode(e)
		}
	}
	{
		if s.Min.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Min.Set {
			e.RawStr("\"min\"" + ":")
			s.Min.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem = [6]string{
	0: "default",
	1: "defaultRequest",
	2: "max",
	3: "maxLimitRequestRatio",
	4: "min",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1LimitRangeItem from json.
func (s *IoK8sAPICoreV1LimitRangeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "defaultRequest":
			if err := func() error {
				s.DefaultRequest.Reset()
				if err := s.DefaultRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRequest\"")
			}
		case "max":
			if err := func() error {
				s.Max.Reset()
				if err := s.Max.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "maxLimitRequestRatio":
			if err := func() error {
				s.MaxLimitRequestRatio.Reset()
				if err := s.MaxLimitRequestRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLimitRequestRatio\"")
			}
		case "min":
			if err := func() error {
				s.Min.Reset()
				if err := s.Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefault) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItemDefault = [0]string{}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefault from json.
func (s IoK8sAPICoreV1LimitRangeItemDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemDefault to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemDefault")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefaultRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItemDefaultRequest = [0]string{}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefaultRequest from json.
func (s IoK8sAPICoreV1LimitRangeItemDefaultRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemDefaultRequest to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemDefaultRequest")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMax) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItemMax = [0]string{}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMax from json.
func (s IoK8sAPICoreV1LimitRangeItemMax) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMax to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMax")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio = [0]string{}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio from json.
func (s IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMin) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItemMin = [0]string{}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMin from json.
func (s IoK8sAPICoreV1LimitRangeItemMin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMin to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMin")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1LimitRangeList from json.
func (s *IoK8sAPICoreV1LimitRangeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1LimitRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LimitRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limits\"" + ":")
		e.ArrStart()
		if len(s.Limits) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Limits[0]
				elem.Encode(e)
			}
			for _, elem := range s.Limits[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec = [1]string{
	0: "limits",
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (s *IoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Limits = make([]IoK8sAPICoreV1LimitRangeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LimitRangeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Limits = append(s.Limits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LoadBalancerIngress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostname.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerIngress = [3]string{
	0: "hostname",
	1: "ip",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerIngress from json.
func (s *IoK8sAPICoreV1LoadBalancerIngress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LoadBalancerIngress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1PortStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PortStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LoadBalancerIngress")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ingress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ingress != nil {
			e.RawStr("\"ingress\"" + ":")
			e.ArrStart()
			if len(s.Ingress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ingress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ingress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerStatus = [1]string{
	0: "ingress",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (s *IoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LoadBalancerStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ingress":
			if err := func() error {
				s.Ingress = make([]IoK8sAPICoreV1LoadBalancerIngress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LoadBalancerIngress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ingress = append(s.Ingress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LoadBalancerStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalObjectReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (s *IoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LocalObjectReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LocalObjectReference")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource = [2]string{
	0: "fsType",
	1: "path",
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (s *IoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LocalVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LocalVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"server\"" + ":")
		e.Str(s.Server)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource = [3]string{
	0: "path",
	1: "readOnly",
	2: "server",
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (s *IoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NFSVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "server":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Server = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NFSVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Namespace) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Namespace = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Namespace from json.
func (s *IoK8sAPICoreV1Namespace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Namespace to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Namespace")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1NamespaceCondition from json.
func (s *IoK8sAPICoreV1NamespaceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NamespaceList from json.
func (s *IoK8sAPICoreV1NamespaceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Namespace, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Namespace
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Finalizers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Finalizers != nil {
			e.RawStr("\"finalizers\"" + ":")
			e.ArrStart()
			if len(s.Finalizers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Finalizers[0]
					e.Str(elem)
				}
				for _, elem := range s.Finalizers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceSpec = [1]string{
	0: "finalizers",
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (s *IoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "finalizers":
			if err := func() error {
				s.Finalizers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Finalizers = append(s.Finalizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalizers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceStatus = [2]string{
	0: "conditions",
	1: "phase",
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (s *IoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1NamespaceCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NamespaceCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Node) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Node = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Node from json.
func (s *IoK8sAPICoreV1Node) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Node to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Node")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeAddress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAddress = [2]string{
	0: "address",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1NodeAddress from json.
func (s *IoK8sAPICoreV1NodeAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			s.RequiredDuringSchedulingIgnoredDuringExecution.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (s *IoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PreferredSchedulingTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PreferredSchedulingTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution.Reset()
				if err := s.RequiredDuringSchedulingIgnoredDuringExecution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeAffinity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastHeartbeatTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastHeartbeatTime.Set {
			e.RawStr("\"lastHeartbeatTime\"" + ":")
			s.LastHeartbeatTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeCondition = [6]string{
	0: "lastHeartbeatTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1NodeCondition from json.
func (s *IoK8sAPICoreV1NodeCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastHeartbeatTime":
			if err := func() error {
				s.LastHeartbeatTime.Reset()
				if err := s.LastHeartbeatTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastHeartbeatTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigSource = [1]string{
	0: "configMap",
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (s *IoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeConfigSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeConfigSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Assigned.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assigned.Set {
			e.RawStr("\"assigned\"" + ":")
			s.Assigned.Encode(e)
		}
	}
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if s.LastKnownGood.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastKnownGood.Set {
			e.RawStr("\"lastKnownGood\"" + ":")
			s.LastKnownGood.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigStatus = [4]string{
	0: "active",
	1: "assigned",
	2: "error",
	3: "lastKnownGood",
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (s *IoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeConfigStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "assigned":
			if err := func() error {
				s.Assigned.Reset()
				if err := s.Assigned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "lastKnownGood":
			if err := func() error {
				s.LastKnownGood.Reset()
				if err := s.LastKnownGood.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastKnownGood\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeConfigStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.KubeletEndpoint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KubeletEndpoint.Set {
			e.RawStr("\"kubeletEndpoint\"" + ":")
			s.KubeletEndpoint.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeDaemonEndpoints = [1]string{
	0: "kubeletEndpoint",
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeDaemonEndpoints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletEndpoint":
			if err := func() error {
				s.KubeletEndpoint.Reset()
				if err := s.KubeletEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletEndpoint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeDaemonEndpoints")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NodeList from json.
func (s *IoK8sAPICoreV1NodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Node, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Node
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nodeSelectorTerms\"" + ":")
		e.ArrStart()
		if len(s.NodeSelectorTerms) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NodeSelectorTerms[0]
				elem.Encode(e)
			}
			for _, elem := range s.NodeSelectorTerms[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelector = [1]string{
	0: "nodeSelectorTerms",
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (s *IoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelectorTerms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NodeSelectorTerms = make([]IoK8sAPICoreV1NodeSelectorTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeSelectorTerms = append(s.NodeSelectorTerms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelectorTerms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorRequirement from json.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelectorTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchFields != nil {
			e.RawStr("\"matchFields\"" + ":")
			e.ArrStart()
			if len(s.MatchFields) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchFields[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchFields[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorTerm = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorTerm from json.
func (s *IoK8sAPICoreV1NodeSelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelectorTerm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sAPICoreV1NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchFields":
			if err := func() error {
				s.MatchFields = make([]IoK8sAPICoreV1NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchFields = append(s.MatchFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelectorTerm")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigSource.Set {
			e.RawStr("\"configSource\"" + ":")
			s.ConfigSource.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalID.Set {
			e.RawStr("\"externalID\"" + ":")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.PodCIDR.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodCIDR.Set {
			e.RawStr("\"podCIDR\"" + ":")
			s.PodCIDR.Encode(e)
		}
	}
	{
		if s.PodCIDRs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodCIDRs != nil {
			e.RawStr("\"podCIDRs\"" + ":")
			e.ArrStart()
			if len(s.PodCIDRs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PodCIDRs[0]
					e.Str(elem)
				}
				for _, elem := range s.PodCIDRs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProviderID.Set {
			e.RawStr("\"providerID\"" + ":")
			s.ProviderID.Encode(e)
		}
	}
	{
		if s.Taints != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Taints != nil {
			e.RawStr("\"taints\"" + ":")
			e.ArrStart()
			if len(s.Taints) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Taints[0]
					elem.Encode(e)
				}
				for _, elem := range s.Taints[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Unschedulable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Unschedulable.Set {
			e.RawStr("\"unschedulable\"" + ":")
			s.Unschedulable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSpec = [7]string{
	0: "configSource",
	1: "externalID",
	2: "podCIDR",
	3: "podCIDRs",
	4: "providerID",
	5: "taints",
	6: "unschedulable",
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (s *IoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configSource":
			if err := func() error {
				s.ConfigSource.Reset()
				if err := s.ConfigSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configSource\"")
			}
		case "externalID":
			if err := func() error {
				s.ExternalID.Reset()
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalID\"")
			}
		case "podCIDR":
			if err := func() error {
				s.PodCIDR.Reset()
				if err := s.PodCIDR.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podCIDR\"")
			}
		case "podCIDRs":
			if err := func() error {
				s.PodCIDRs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PodCIDRs = append(s.PodCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podCIDRs\"")
			}
		case "providerID":
			if err := func() error {
				s.ProviderID.Reset()
				if err := s.ProviderID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerID\"")
			}
		case "taints":
			if err := func() error {
				s.Taints = make([]IoK8sAPICoreV1Taint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Taint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Taints = append(s.Taints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taints\"")
			}
		case "unschedulable":
			if err := func() error {
				s.Unschedulable.Reset()
				if err := s.Unschedulable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unschedulable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Addresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Addresses != nil {
			e.RawStr("\"addresses\"" + ":")
			e.ArrStart()
			if len(s.Addresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Addresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.Addresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Allocatable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Allocatable.Set {
			e.RawStr("\"allocatable\"" + ":")
			s.Allocatable.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.DaemonEndpoints.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DaemonEndpoints.Set {
			e.RawStr("\"daemonEndpoints\"" + ":")
			s.DaemonEndpoints.Encode(e)
		}
	}
	{
		if s.Images != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Images != nil {
			e.RawStr("\"images\"" + ":")
			e.ArrStart()
			if len(s.Images) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Images[0]
					elem.Encode(e)
				}
				for _, elem := range s.Images[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeInfo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeInfo.Set {
			e.RawStr("\"nodeInfo\"" + ":")
			s.NodeInfo.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.VolumesAttached != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumesAttached != nil {
			e.RawStr("\"volumesAttached\"" + ":")
			e.ArrStart()
			if len(s.VolumesAttached) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumesAttached[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumesAttached[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumesInUse != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumesInUse != nil {
			e.RawStr("\"volumesInUse\"" + ":")
			e.ArrStart()
			if len(s.VolumesInUse) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumesInUse[0]
					e.Str(elem)
				}
				for _, elem := range s.VolumesInUse[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeStatus = [11]string{
	0:  "addresses",
	1:  "allocatable",
	2:  "capacity",
	3:  "conditions",
	4:  "config",
	5:  "daemonEndpoints",
	6:  "images",
	7:  "nodeInfo",
	8:  "phase",
	9:  "volumesAttached",
	10: "volumesInUse",
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (s *IoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			if err := func() error {
				s.Addresses = make([]IoK8sAPICoreV1NodeAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "allocatable":
			if err := func() error {
				s.Allocatable.Reset()
				if err := s.Allocatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocatable\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1NodeCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "daemonEndpoints":
			if err := func() error {
				s.DaemonEndpoints.Reset()
				if err := s.DaemonEndpoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daemonEndpoints\"")
			}
		case "images":
			if err := func() error {
				s.Images = make([]IoK8sAPICoreV1ContainerImage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerImage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Images = append(s.Images, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"images\"")
			}
		case "nodeInfo":
			if err := func() error {
				s.NodeInfo.Reset()
				if err := s.NodeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeInfo\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "volumesAttached":
			if err := func() error {
				s.VolumesAttached = make([]IoK8sAPICoreV1AttachedVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1AttachedVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumesAttached = append(s.VolumesAttached, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumesAttached\"")
			}
		case "volumesInUse":
			if err := func() error {
				s.VolumesInUse = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VolumesInUse = append(s.VolumesInUse, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumesInUse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusAllocatable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeStatusAllocatable = [0]string{}

// Decode decodes IoK8sAPICoreV1NodeStatusAllocatable from json.
func (s IoK8sAPICoreV1NodeStatusAllocatable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatusAllocatable to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatusAllocatable")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeStatusCapacity = [0]string{}

// Decode decodes IoK8sAPICoreV1NodeStatusCapacity from json.
func (s IoK8sAPICoreV1NodeStatusCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatusCapacity to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatusCapacity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"architecture\"" + ":")
		e.Str(s.Architecture)
	}
	{
		e.Comma()

		e.RawStr("\"bootID\"" + ":")
		e.Str(s.BootID)
	}
	{
		e.Comma()

		e.RawStr("\"containerRuntimeVersion\"" + ":")
		e.Str(s.ContainerRuntimeVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kernelVersion\"" + ":")
		e.Str(s.KernelVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kubeProxyVersion\"" + ":")
		e.Str(s.KubeProxyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kubeletVersion\"" + ":")
		e.Str(s.KubeletVersion)
	}
	{
		e.Comma()

		e.RawStr("\"machineID\"" + ":")
		e.Str(s.MachineID)
	}
	{
		e.Comma()

		e.RawStr("\"operatingSystem\"" + ":")
		e.Str(s.OperatingSystem)
	}
	{
		e.Comma()

		e.RawStr("\"osImage\"" + ":")
		e.Str(s.OsImage)
	}
	{
		e.Comma()

		e.RawStr("\"systemUUID\"" + ":")
		e.Str(s.SystemUUID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo = [10]string{
	0: "architecture",
	1: "bootID",
	2: "containerRuntimeVersion",
	3: "kernelVersion",
	4: "kubeProxyVersion",
	5: "kubeletVersion",
	6: "machineID",
	7: "operatingSystem",
	8: "osImage",
	9: "systemUUID",
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (s *IoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSystemInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Architecture = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "bootID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BootID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bootID\"")
			}
		case "containerRuntimeVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContainerRuntimeVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerRuntimeVersion\"")
			}
		case "kernelVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KernelVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kernelVersion\"")
			}
		case "kubeProxyVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.KubeProxyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeProxyVersion\"")
			}
		case "kubeletVersion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.KubeletVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletVersion\"")
			}
		case "machineID":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MachineID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machineID\"")
			}
		case "operatingSystem":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.OperatingSystem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operatingSystem\"")
			}
		case "osImage":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OsImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osImage\"")
			}
		case "systemUUID":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SystemUUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemUUID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSystemInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"fieldPath\"" + ":")
		e.Str(s.FieldPath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector = [2]string{
	0: "apiVersion",
	1: "fieldPath",
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (s *IoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ObjectFieldSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FieldPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ObjectFieldSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldPath.Set {
			e.RawStr("\"fieldPath\"" + ":")
			s.FieldPath.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectReference = [7]string{
	0: "apiVersion",
	1: "fieldPath",
	2: "kind",
	3: "name",
	4: "namespace",
	5: "resourceVersion",
	6: "uid",
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (s *IoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ObjectReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldPath":
			if err := func() error {
				s.FieldPath.Reset()
				if err := s.FieldPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldPath\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ObjectReference")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolume = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolume from json.
func (s *IoK8sAPICoreV1PersistentVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolume to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolume")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaim) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaim = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaim from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaim to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaim")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimCondition from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimList from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PersistentVolumeClaim, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaim
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DataSource.Set {
			e.RawStr("\"dataSource\"" + ":")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.DataSourceRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DataSourceRef.Set {
			e.RawStr("\"dataSourceRef\"" + ":")
			s.DataSourceRef.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageClassName.Set {
			e.RawStr("\"storageClassName\"" + ":")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeMode.Set {
			e.RawStr("\"volumeMode\"" + ":")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimSpec = [8]string{
	0: "accessModes",
	1: "dataSource",
	2: "dataSourceRef",
	3: "resources",
	4: "selector",
	5: "storageClassName",
	6: "volumeMode",
	7: "volumeName",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "dataSourceRef":
			if err := func() error {
				s.DataSourceRef.Reset()
				if err := s.DataSourceRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceRef\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		case "volumeMode":
			if err := func() error {
				s.VolumeMode.Reset()
				if err := s.VolumeMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMode\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimStatus = [4]string{
	0: "accessModes",
	1: "capacity",
	2: "conditions",
	3: "phase",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1PersistentVolumeClaimCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaimCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity = [0]string{}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity from json.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"claimName\"" + ":")
		e.Str(s.ClaimName)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource = [2]string{
	0: "claimName",
	1: "readOnly",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claimName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClaimName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimName\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeList from json.
func (s *IoK8sAPICoreV1PersistentVolumeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PersistentVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AwsElasticBlockStore.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AwsElasticBlockStore.Set {
			e.RawStr("\"awsElasticBlockStore\"" + ":")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureDisk.Set {
			e.RawStr("\"azureDisk\"" + ":")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureFile.Set {
			e.RawStr("\"azureFile\"" + ":")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cephfs.Set {
			e.RawStr("\"cephfs\"" + ":")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cinder.Set {
			e.RawStr("\"cinder\"" + ":")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ClaimRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClaimRef.Set {
			e.RawStr("\"claimRef\"" + ":")
			s.ClaimRef.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Csi.Set {
			e.RawStr("\"csi\"" + ":")
			s.Csi.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fc.Set {
			e.RawStr("\"fc\"" + ":")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FlexVolume.Set {
			e.RawStr("\"flexVolume\"" + ":")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Flocker.Set {
			e.RawStr("\"flocker\"" + ":")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GcePersistentDisk.Set {
			e.RawStr("\"gcePersistentDisk\"" + ":")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Glusterfs.Set {
			e.RawStr("\"glusterfs\"" + ":")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostPath.Set {
			e.RawStr("\"hostPath\"" + ":")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Iscsi.Set {
			e.RawStr("\"iscsi\"" + ":")
			s.Iscsi.Encode(e)
		}
	}
	{
		if s.Local.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Local.Set {
			e.RawStr("\"local\"" + ":")
			s.Local.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MountOptions != nil {
			e.RawStr("\"mountOptions\"" + ":")
			e.ArrStart()
			if len(s.MountOptions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MountOptions[0]
					e.Str(elem)
				}
				for _, elem := range s.MountOptions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Nfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nfs.Set {
			e.RawStr("\"nfs\"" + ":")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.NodeAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeAffinity.Set {
			e.RawStr("\"nodeAffinity\"" + ":")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PersistentVolumeReclaimPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PersistentVolumeReclaimPolicy.Set {
			e.RawStr("\"persistentVolumeReclaimPolicy\"" + ":")
			s.PersistentVolumeReclaimPolicy.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PhotonPersistentDisk.Set {
			e.RawStr("\"photonPersistentDisk\"" + ":")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PortworxVolume.Set {
			e.RawStr("\"portworxVolume\"" + ":")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Quobyte.Set {
			e.RawStr("\"quobyte\"" + ":")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rbd.Set {
			e.RawStr("\"rbd\"" + ":")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleIO.Set {
			e.RawStr("\"scaleIO\"" + ":")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageClassName.Set {
			e.RawStr("\"storageClassName\"" + ":")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Storageos.Set {
			e.RawStr("\"storageos\"" + ":")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeMode.Set {
			e.RawStr("\"volumeMode\"" + ":")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VsphereVolume.Set {
			e.RawStr("\"vsphereVolume\"" + ":")
			s.VsphereVolume.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeSpec = [30]string{
	0:  "accessModes",
	1:  "awsElasticBlockStore",
	2:  "azureDisk",
	3:  "azureFile",
	4:  "capacity",
	5:  "cephfs",
	6:  "cinder",
	7:  "claimRef",
	8:  "csi",
	9:  "fc",
	10: "flexVolume",
	11: "flocker",
	12: "gcePersistentDisk",
	13: "glusterfs",
	14: "hostPath",
	15: "iscsi",
	16: "local",
	17: "mountOptions",
	18: "nfs",
	19: "nodeAffinity",
	20: "persistentVolumeReclaimPolicy",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "quobyte",
	24: "rbd",
	25: "scaleIO",
	26: "storageClassName",
	27: "storageos",
	28: "volumeMode",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "awsElasticBlockStore":
			if err := func() error {
				s.AwsElasticBlockStore.Reset()
				if err := s.AwsElasticBlockStore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"awsElasticBlockStore\"")
			}
		case "azureDisk":
			if err := func() error {
				s.AzureDisk.Reset()
				if err := s.AzureDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureDisk\"")
			}
		case "azureFile":
			if err := func() error {
				s.AzureFile.Reset()
				if err := s.AzureFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureFile\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "cephfs":
			if err := func() error {
				s.Cephfs.Reset()
				if err := s.Cephfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cephfs\"")
			}
		case "cinder":
			if err := func() error {
				s.Cinder.Reset()
				if err := s.Cinder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cinder\"")
			}
		case "claimRef":
			if err := func() error {
				s.ClaimRef.Reset()
				if err := s.ClaimRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimRef\"")
			}
		case "csi":
			if err := func() error {
				s.Csi.Reset()
				if err := s.Csi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csi\"")
			}
		case "fc":
			if err := func() error {
				s.Fc.Reset()
				if err := s.Fc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fc\"")
			}
		case "flexVolume":
			if err := func() error {
				s.FlexVolume.Reset()
				if err := s.FlexVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flexVolume\"")
			}
		case "flocker":
			if err := func() error {
				s.Flocker.Reset()
				if err := s.Flocker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flocker\"")
			}
		case "gcePersistentDisk":
			if err := func() error {
				s.GcePersistentDisk.Reset()
				if err := s.GcePersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gcePersistentDisk\"")
			}
		case "glusterfs":
			if err := func() error {
				s.Glusterfs.Reset()
				if err := s.Glusterfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"glusterfs\"")
			}
		case "hostPath":
			if err := func() error {
				s.HostPath.Reset()
				if err := s.HostPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPath\"")
			}
		case "iscsi":
			if err := func() error {
				s.Iscsi.Reset()
				if err := s.Iscsi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsi\"")
			}
		case "local":
			if err := func() error {
				s.Local.Reset()
				if err := s.Local.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"local\"")
			}
		case "mountOptions":
			if err := func() error {
				s.MountOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MountOptions = append(s.MountOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountOptions\"")
			}
		case "nfs":
			if err := func() error {
				s.Nfs.Reset()
				if err := s.Nfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nfs\"")
			}
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "persistentVolumeReclaimPolicy":
			if err := func() error {
				s.PersistentVolumeReclaimPolicy.Reset()
				if err := s.PersistentVolumeReclaimPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeReclaimPolicy\"")
			}
		case "photonPersistentDisk":
			if err := func() error {
				s.PhotonPersistentDisk.Reset()
				if err := s.PhotonPersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photonPersistentDisk\"")
			}
		case "portworxVolume":
			if err := func() error {
				s.PortworxVolume.Reset()
				if err := s.PortworxVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portworxVolume\"")
			}
		case "quobyte":
			if err := func() error {
				s.Quobyte.Reset()
				if err := s.Quobyte.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quobyte\"")
			}
		case "rbd":
			if err := func() error {
				s.Rbd.Reset()
				if err := s.Rbd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rbd\"")
			}
		case "scaleIO":
			if err := func() error {
				s.ScaleIO.Reset()
				if err := s.ScaleIO.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleIO\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		case "storageos":
			if err := func() error {
				s.Storageos.Reset()
				if err := s.Storageos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageos\"")
			}
		case "volumeMode":
			if err := func() error {
				s.VolumeMode.Reset()
				if err := s.VolumeMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMode\"")
			}
		case "vsphereVolume":
			if err := func() error {
				s.VsphereVolume.Reset()
				if err := s.VsphereVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereVolume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpecCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeSpecCapacity = [0]string{}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpecCapacity from json.
func (s IoK8sAPICoreV1PersistentVolumeSpecCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeSpecCapacity to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeSpecCapacity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeStatus = [3]string{
	0: "message",
	1: "phase",
	2: "reason",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pdID\"" + ":")
		e.Str(s.PdID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource = [2]string{
	0: "fsType",
	1: "pdID",
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "pdID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PdID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PhotonPersistentDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Pod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Pod = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Pod from json.
func (s *IoK8sAPICoreV1Pod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Pod to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Pod")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.RequiredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (s *IoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1WeightedPodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1WeightedPodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAffinity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAffinityTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelector.Set {
			e.RawStr("\"labelSelector\"" + ":")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"topologyKey\"" + ":")
		e.Str(s.TopologyKey)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes IoK8sAPICoreV1PodAffinityTerm from json.
func (s *IoK8sAPICoreV1PodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.RequiredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAntiAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (s *IoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAntiAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1WeightedPodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1WeightedPodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAntiAffinity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PodCondition from json.
func (s *IoK8sAPICoreV1PodCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Nameservers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers != nil {
			e.RawStr("\"nameservers\"" + ":")
			e.ArrStart()
			if len(s.Nameservers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Nameservers[0]
					e.Str(elem)
				}
				for _, elem := range s.Nameservers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Options != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Options != nil {
			e.RawStr("\"options\"" + ":")
			e.ArrStart()
			if len(s.Options) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Options[0]
					elem.Encode(e)
				}
				for _, elem := range s.Options[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Searches != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Searches != nil {
			e.RawStr("\"searches\"" + ":")
			e.ArrStart()
			if len(s.Searches) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Searches[0]
					e.Str(elem)
				}
				for _, elem := range s.Searches[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfig = [3]string{
	0: "nameservers",
	1: "options",
	2: "searches",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (s *IoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodDNSConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nameservers":
			if err := func() error {
				s.Nameservers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nameservers = append(s.Nameservers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "options":
			if err := func() error {
				s.Options = make([]IoK8sAPICoreV1PodDNSConfigOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodDNSConfigOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "searches":
			if err := func() error {
				s.Searches = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Searches = append(s.Searches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"searches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodDNSConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodDNSConfigOption) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfigOption = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfigOption from json.
func (s *IoK8sAPICoreV1PodDNSConfigOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodDNSConfigOption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodDNSConfigOption")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodIP) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodIP = [1]string{
	0: "ip",
}

// Decode decodes IoK8sAPICoreV1PodIP from json.
func (s *IoK8sAPICoreV1PodIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodIP to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodIP")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodList from json.
func (s *IoK8sAPICoreV1PodList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Pod, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Pod
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodReadinessGate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditionType\"" + ":")
		e.Str(s.ConditionType)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate = [1]string{
	0: "conditionType",
}

// Decode decodes IoK8sAPICoreV1PodReadinessGate from json.
func (s *IoK8sAPICoreV1PodReadinessGate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodReadinessGate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ConditionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditionType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodReadinessGate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroup.Set {
			e.RawStr("\"fsGroup\"" + ":")
			s.FsGroup.Encode(e)
		}
	}
	{
		if s.FsGroupChangePolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroupChangePolicy.Set {
			e.RawStr("\"fsGroupChangePolicy\"" + ":")
			s.FsGroupChangePolicy.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsNonRoot.Set {
			e.RawStr("\"runAsNonRoot\"" + ":")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUser.Set {
			e.RawStr("\"runAsUser\"" + ":")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeccompProfile.Set {
			e.RawStr("\"seccompProfile\"" + ":")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.SupplementalGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SupplementalGroups != nil {
			e.RawStr("\"supplementalGroups\"" + ":")
			e.ArrStart()
			if len(s.SupplementalGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SupplementalGroups[0]
					e.Int64(elem)
				}
				for _, elem := range s.SupplementalGroups[1:] {
					e.Comma()
					e.Int64(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sysctls != nil {
			e.RawStr("\"sysctls\"" + ":")
			e.ArrStart()
			if len(s.Sysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Sysctls[0]
					elem.Encode(e)
				}
				for _, elem := range s.Sysctls[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WindowsOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WindowsOptions.Set {
			e.RawStr("\"windowsOptions\"" + ":")
			s.WindowsOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSecurityContext = [10]string{
	0: "fsGroup",
	1: "fsGroupChangePolicy",
	2: "runAsGroup",
	3: "runAsNonRoot",
	4: "runAsUser",
	5: "seLinuxOptions",
	6: "seccompProfile",
	7: "supplementalGroups",
	8: "sysctls",
	9: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (s *IoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsGroup":
			if err := func() error {
				s.FsGroup.Reset()
				if err := s.FsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroup\"")
			}
		case "fsGroupChangePolicy":
			if err := func() error {
				s.FsGroupChangePolicy.Reset()
				if err := s.FsGroupChangePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroupChangePolicy\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "supplementalGroups":
			if err := func() error {
				s.SupplementalGroups = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.SupplementalGroups = append(s.SupplementalGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementalGroups\"")
			}
		case "sysctls":
			if err := func() error {
				s.Sysctls = make([]IoK8sAPICoreV1Sysctl, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Sysctl
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sysctls = append(s.Sysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sysctls\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSecurityContext")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ActiveDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveDeadlineSeconds.Set {
			e.RawStr("\"activeDeadlineSeconds\"" + ":")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Affinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Affinity.Set {
			e.RawStr("\"affinity\"" + ":")
			s.Affinity.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutomountServiceAccountToken.Set {
			e.RawStr("\"automountServiceAccountToken\"" + ":")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"containers\"" + ":")
		e.ArrStart()
		if len(s.Containers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Containers[0]
				elem.Encode(e)
			}
			for _, elem := range s.Containers[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.DnsConfig.Set {
			e.Comma()
		}
		if s.DnsConfig.Set {
			e.RawStr("\"dnsConfig\"" + ":")
			s.DnsConfig.Encode(e)
		}
	}
	{
		if s.DnsPolicy.Set {
			e.Comma()
		}
		if s.DnsPolicy.Set {
			e.RawStr("\"dnsPolicy\"" + ":")
			s.DnsPolicy.Encode(e)
		}
	}
	{
		if s.EnableServiceLinks.Set {
			e.Comma()
		}
		if s.EnableServiceLinks.Set {
			e.RawStr("\"enableServiceLinks\"" + ":")
			s.EnableServiceLinks.Encode(e)
		}
	}
	{
		if s.EphemeralContainers != nil {
			e.Comma()
		}
		if s.EphemeralContainers != nil {
			e.RawStr("\"ephemeralContainers\"" + ":")
			e.ArrStart()
			if len(s.EphemeralContainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EphemeralContainers[0]
					elem.Encode(e)
				}
				for _, elem := range s.EphemeralContainers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostAliases != nil {
			e.Comma()
		}
		if s.HostAliases != nil {
			e.RawStr("\"hostAliases\"" + ":")
			e.ArrStart()
			if len(s.HostAliases) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HostAliases[0]
					elem.Encode(e)
				}
				for _, elem := range s.HostAliases[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIPC.Set {
			e.Comma()
		}
		if s.HostIPC.Set {
			e.RawStr("\"hostIPC\"" + ":")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.Comma()
		}
		if s.HostNetwork.Set {
			e.RawStr("\"hostNetwork\"" + ":")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.Comma()
		}
		if s.HostPID.Set {
			e.RawStr("\"hostPID\"" + ":")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			e.Comma()
		}
		if s.ImagePullSecrets != nil {
			e.RawStr("\"imagePullSecrets\"" + ":")
			e.ArrStart()
			if len(s.ImagePullSecrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ImagePullSecrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.ImagePullSecrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.InitContainers != nil {
			e.Comma()
		}
		if s.InitContainers != nil {
			e.RawStr("\"initContainers\"" + ":")
			e.ArrStart()
			if len(s.InitContainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.InitContainers[0]
					elem.Encode(e)
				}
				for _, elem := range s.InitContainers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.NodeSelector.Set {
			e.Comma()
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			e.Comma()
		}
		if s.PreemptionPolicy.Set {
			e.RawStr("\"preemptionPolicy\"" + ":")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.Comma()
		}
		if s.Priority.Set {
			e.RawStr("\"priority\"" + ":")
			s.Priority.Encode(e)
		}
	}
	{
		if s.PriorityClassName.Set {
			e.Comma()
		}
		if s.PriorityClassName.Set {
			e.RawStr("\"priorityClassName\"" + ":")
			s.PriorityClassName.Encode(e)
		}
	}
	{
		if s.ReadinessGates != nil {
			e.Comma()
		}
		if s.ReadinessGates != nil {
			e.RawStr("\"readinessGates\"" + ":")
			e.ArrStart()
			if len(s.ReadinessGates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ReadinessGates[0]
					elem.Encode(e)
				}
				for _, elem := range s.ReadinessGates[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RestartPolicy.Set {
			e.Comma()
		}
		if s.RestartPolicy.Set {
			e.RawStr("\"restartPolicy\"" + ":")
			s.RestartPolicy.Encode(e)
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.Comma()
		}
		if s.RuntimeClassName.Set {
			e.RawStr("\"runtimeClassName\"" + ":")
			s.RuntimeClassName.Encode(e)
		}
	}
	{
		if s.SchedulerName.Set {
			e.Comma()
		}
		if s.SchedulerName.Set {
			e.RawStr("\"schedulerName\"" + ":")
			s.SchedulerName.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.ServiceAccountName.Set {
			e.Comma()
		}
		if s.ServiceAccountName.Set {
			e.RawStr("\"serviceAccountName\"" + ":")
			s.ServiceAccountName.Encode(e)
		}
	}
	{
		if s.SetHostnameAsFQDN.Set {
			e.Comma()
		}
		if s.SetHostnameAsFQDN.Set {
			e.RawStr("\"setHostnameAsFQDN\"" + ":")
			s.SetHostnameAsFQDN.Encode(e)
		}
	}
	{
		if s.ShareProcessNamespace.Set {
			e.Comma()
		}
		if s.ShareProcessNamespace.Set {
			e.RawStr("\"shareProcessNamespace\"" + ":")
			s.ShareProcessNamespace.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			e.Comma()
		}
		if s.Subdomain.Set {
			e.RawStr("\"subdomain\"" + ":")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			e.Comma()
		}
		if s.TerminationGracePeriodSeconds.Set {
			e.RawStr("\"terminationGracePeriodSeconds\"" + ":")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.Comma()
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TopologySpreadConstraints != nil {
			e.Comma()
		}
		if s.TopologySpreadConstraints != nil {
			e.RawStr("\"topologySpreadConstraints\"" + ":")
			e.ArrStart()
			if len(s.TopologySpreadConstraints) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TopologySpreadConstraints[0]
					elem.Encode(e)
				}
				for _, elem := range s.TopologySpreadConstraints[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Volumes != nil {
			e.Comma()
		}
		if s.Volumes != nil {
			e.RawStr("\"volumes\"" + ":")
			e.ArrStart()
			if len(s.Volumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Volumes[0]
					elem.Encode(e)
				}
				for _, elem := range s.Volumes[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSpec = [35]string{
	0:  "activeDeadlineSeconds",
	1:  "affinity",
	2:  "automountServiceAccountToken",
	3:  "containers",
	4:  "dnsConfig",
	5:  "dnsPolicy",
	6:  "enableServiceLinks",
	7:  "ephemeralContainers",
	8:  "hostAliases",
	9:  "hostIPC",
	10: "hostNetwork",
	11: "hostPID",
	12: "hostname",
	13: "imagePullSecrets",
	14: "initContainers",
	15: "nodeName",
	16: "nodeSelector",
	17: "overhead",
	18: "preemptionPolicy",
	19: "priority",
	20: "priorityClassName",
	21: "readinessGates",
	22: "restartPolicy",
	23: "runtimeClassName",
	24: "schedulerName",
	25: "securityContext",
	26: "serviceAccount",
	27: "serviceAccountName",
	28: "setHostnameAsFQDN",
	29: "shareProcessNamespace",
	30: "subdomain",
	31: "terminationGracePeriodSeconds",
	32: "tolerations",
	33: "topologySpreadConstraints",
	34: "volumes",
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (s *IoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpec to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			if err := func() error {
				s.ActiveDeadlineSeconds.Reset()
				if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeDeadlineSeconds\"")
			}
		case "affinity":
			if err := func() error {
				s.Affinity.Reset()
				if err := s.Affinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affinity\"")
			}
		case "automountServiceAccountToken":
			if err := func() error {
				s.AutomountServiceAccountToken.Reset()
				if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automountServiceAccountToken\"")
			}
		case "containers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Containers = make([]IoK8sAPICoreV1Container, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Container
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Containers = append(s.Containers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containers\"")
			}
		case "dnsConfig":
			if err := func() error {
				s.DnsConfig.Reset()
				if err := s.DnsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsConfig\"")
			}
		case "dnsPolicy":
			if err := func() error {
				s.DnsPolicy.Reset()
				if err := s.DnsPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsPolicy\"")
			}
		case "enableServiceLinks":
			if err := func() error {
				s.EnableServiceLinks.Reset()
				if err := s.EnableServiceLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableServiceLinks\"")
			}
		case "ephemeralContainers":
			if err := func() error {
				s.EphemeralContainers = make([]IoK8sAPICoreV1EphemeralContainer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EphemeralContainer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EphemeralContainers = append(s.EphemeralContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeralContainers\"")
			}
		case "hostAliases":
			if err := func() error {
				s.HostAliases = make([]IoK8sAPICoreV1HostAlias, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1HostAlias
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostAliases = append(s.HostAliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostAliases\"")
			}
		case "hostIPC":
			if err := func() error {
				s.HostIPC.Reset()
				if err := s.HostIPC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIPC\"")
			}
		case "hostNetwork":
			if err := func() error {
				s.HostNetwork.Reset()
				if err := s.HostNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetwork\"")
			}
		case "hostPID":
			if err := func() error {
				s.HostPID.Reset()
				if err := s.HostPID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPID\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "imagePullSecrets":
			if err := func() error {
				s.ImagePullSecrets = make([]IoK8sAPICoreV1LocalObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LocalObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullSecrets\"")
			}
		case "initContainers":
			if err := func() error {
				s.InitContainers = make([]IoK8sAPICoreV1Container, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Container
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InitContainers = append(s.InitContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initContainers\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "preemptionPolicy":
			if err := func() error {
				s.PreemptionPolicy.Reset()
				if err := s.PreemptionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preemptionPolicy\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "priorityClassName":
			if err := func() error {
				s.PriorityClassName.Reset()
				if err := s.PriorityClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityClassName\"")
			}
		case "readinessGates":
			if err := func() error {
				s.ReadinessGates = make([]IoK8sAPICoreV1PodReadinessGate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodReadinessGate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadinessGates = append(s.ReadinessGates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessGates\"")
			}
		case "restartPolicy":
			if err := func() error {
				s.RestartPolicy.Reset()
				if err := s.RestartPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restartPolicy\"")
			}
		case "runtimeClassName":
			if err := func() error {
				s.RuntimeClassName.Reset()
				if err := s.RuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClassName\"")
			}
		case "schedulerName":
			if err := func() error {
				s.SchedulerName.Reset()
				if err := s.SchedulerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedulerName\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "serviceAccountName":
			if err := func() error {
				s.ServiceAccountName.Reset()
				if err := s.ServiceAccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountName\"")
			}
		case "setHostnameAsFQDN":
			if err := func() error {
				s.SetHostnameAsFQDN.Reset()
				if err := s.SetHostnameAsFQDN.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setHostnameAsFQDN\"")
			}
		case "shareProcessNamespace":
			if err := func() error {
				s.ShareProcessNamespace.Reset()
				if err := s.ShareProcessNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareProcessNamespace\"")
			}
		case "subdomain":
			if err := func() error {
				s.Subdomain.Reset()
				if err := s.Subdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdomain\"")
			}
		case "terminationGracePeriodSeconds":
			if err := func() error {
				s.TerminationGracePeriodSeconds.Reset()
				if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationGracePeriodSeconds\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		case "topologySpreadConstraints":
			if err := func() error {
				s.TopologySpreadConstraints = make([]IoK8sAPICoreV1TopologySpreadConstraint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySpreadConstraint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopologySpreadConstraints = append(s.TopologySpreadConstraints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologySpreadConstraints\"")
			}
		case "volumes":
			if err := func() error {
				s.Volumes = make([]IoK8sAPICoreV1Volume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Volume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Volumes = append(s.Volumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecNodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSpecNodeSelector = [0]string{}

// Decode decodes IoK8sAPICoreV1PodSpecNodeSelector from json.
func (s IoK8sAPICoreV1PodSpecNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpecNodeSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpecNodeSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecOverhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSpecOverhead = [0]string{}

// Decode decodes IoK8sAPICoreV1PodSpecOverhead from json.
func (s IoK8sAPICoreV1PodSpecOverhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpecOverhead to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpecOverhead")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerStatuses != nil {
			e.RawStr("\"containerStatuses\"" + ":")
			e.ArrStart()
			if len(s.ContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.ContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EphemeralContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EphemeralContainerStatuses != nil {
			e.RawStr("\"ephemeralContainerStatuses\"" + ":")
			e.ArrStart()
			if len(s.EphemeralContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EphemeralContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.EphemeralContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostIP.Set {
			e.RawStr("\"hostIP\"" + ":")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.InitContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitContainerStatuses != nil {
			e.RawStr("\"initContainerStatuses\"" + ":")
			e.ArrStart()
			if len(s.InitContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.InitContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.InitContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.NominatedNodeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NominatedNodeName.Set {
			e.RawStr("\"nominatedNodeName\"" + ":")
			s.NominatedNodeName.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.PodIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodIP.Set {
			e.RawStr("\"podIP\"" + ":")
			s.PodIP.Encode(e)
		}
	}
	{
		if s.PodIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodIPs != nil {
			e.RawStr("\"podIPs\"" + ":")
			e.ArrStart()
			if len(s.PodIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PodIPs[0]
					elem.Encode(e)
				}
				for _, elem := range s.PodIPs[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.QosClass.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QosClass.Set {
			e.RawStr("\"qosClass\"" + ":")
			s.QosClass.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartTime.Set {
			e.RawStr("\"startTime\"" + ":")
			s.StartTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodStatus = [13]string{
	0:  "conditions",
	1:  "containerStatuses",
	2:  "ephemeralContainerStatuses",
	3:  "hostIP",
	4:  "initContainerStatuses",
	5:  "message",
	6:  "nominatedNodeName",
	7:  "phase",
	8:  "podIP",
	9:  "podIPs",
	10: "qosClass",
	11: "reason",
	12: "startTime",
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (s *IoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1PodCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "containerStatuses":
			if err := func() error {
				s.ContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ContainerStatuses = append(s.ContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerStatuses\"")
			}
		case "ephemeralContainerStatuses":
			if err := func() error {
				s.EphemeralContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EphemeralContainerStatuses = append(s.EphemeralContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeralContainerStatuses\"")
			}
		case "hostIP":
			if err := func() error {
				s.HostIP.Reset()
				if err := s.HostIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIP\"")
			}
		case "initContainerStatuses":
			if err := func() error {
				s.InitContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InitContainerStatuses = append(s.InitContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initContainerStatuses\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "nominatedNodeName":
			if err := func() error {
				s.NominatedNodeName.Reset()
				if err := s.NominatedNodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominatedNodeName\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "podIP":
			if err := func() error {
				s.PodIP.Reset()
				if err := s.PodIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podIP\"")
			}
		case "podIPs":
			if err := func() error {
				s.PodIPs = make([]IoK8sAPICoreV1PodIP, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodIP
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PodIPs = append(s.PodIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podIPs\"")
			}
		case "qosClass":
			if err := func() error {
				s.QosClass.Reset()
				if err := s.QosClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"qosClass\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Template.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplate = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1PodTemplate from json.
func (s *IoK8sAPICoreV1PodTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplate")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplateList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodTemplateList from json.
func (s *IoK8sAPICoreV1PodTemplateList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplateList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PodTemplate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodTemplate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplateList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (s *IoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplateSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PortStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		e.Comma()

		e.RawStr("\"protocol\"" + ":")
		e.Str(s.Protocol)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PortStatus = [3]string{
	0: "error",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPICoreV1PortStatus from json.
func (s *IoK8sAPICoreV1PortStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PortStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Protocol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PortStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource = [3]string{
	0: "fsType",
	1: "readOnly",
	2: "volumeID",
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (s *IoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PortworxVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PortworxVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PreferredSchedulingTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"preference\"" + ":")
		s.Preference.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"weight\"" + ":")
		e.Int32(s.Weight)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm = [2]string{
	0: "preference",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1PreferredSchedulingTerm from json.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PreferredSchedulingTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preference":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Preference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preference\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PreferredSchedulingTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Probe) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Exec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exec.Set {
			e.RawStr("\"exec\"" + ":")
			s.Exec.Encode(e)
		}
	}
	{
		if s.FailureThreshold.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailureThreshold.Set {
			e.RawStr("\"failureThreshold\"" + ":")
			s.FailureThreshold.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpGet.Set {
			e.RawStr("\"httpGet\"" + ":")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.InitialDelaySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitialDelaySeconds.Set {
			e.RawStr("\"initialDelaySeconds\"" + ":")
			s.InitialDelaySeconds.Encode(e)
		}
	}
	{
		if s.PeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PeriodSeconds.Set {
			e.RawStr("\"periodSeconds\"" + ":")
			s.PeriodSeconds.Encode(e)
		}
	}
	{
		if s.SuccessThreshold.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SuccessThreshold.Set {
			e.RawStr("\"successThreshold\"" + ":")
			s.SuccessThreshold.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TcpSocket.Set {
			e.RawStr("\"tcpSocket\"" + ":")
			s.TcpSocket.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TerminationGracePeriodSeconds.Set {
			e.RawStr("\"terminationGracePeriodSeconds\"" + ":")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.TimeoutSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Probe = [9]string{
	0: "exec",
	1: "failureThreshold",
	2: "httpGet",
	3: "initialDelaySeconds",
	4: "periodSeconds",
	5: "successThreshold",
	6: "tcpSocket",
	7: "terminationGracePeriodSeconds",
	8: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (s *IoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Probe to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			if err := func() error {
				s.Exec.Reset()
				if err := s.Exec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exec\"")
			}
		case "failureThreshold":
			if err := func() error {
				s.FailureThreshold.Reset()
				if err := s.FailureThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failureThreshold\"")
			}
		case "httpGet":
			if err := func() error {
				s.HttpGet.Reset()
				if err := s.HttpGet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpGet\"")
			}
		case "initialDelaySeconds":
			if err := func() error {
				s.InitialDelaySeconds.Reset()
				if err := s.InitialDelaySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialDelaySeconds\"")
			}
		case "periodSeconds":
			if err := func() error {
				s.PeriodSeconds.Reset()
				if err := s.PeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"periodSeconds\"")
			}
		case "successThreshold":
			if err := func() error {
				s.SuccessThreshold.Reset()
				if err := s.SuccessThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successThreshold\"")
			}
		case "tcpSocket":
			if err := func() error {
				s.TcpSocket.Reset()
				if err := s.TcpSocket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tcpSocket\"")
			}
		case "terminationGracePeriodSeconds":
			if err := func() error {
				s.TerminationGracePeriodSeconds.Reset()
				if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationGracePeriodSeconds\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Probe")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Sources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sources != nil {
			e.RawStr("\"sources\"" + ":")
			e.ArrStart()
			if len(s.Sources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Sources[0]
					elem.Encode(e)
				}
				for _, elem := range s.Sources[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ProjectedVolumeSource = [2]string{
	0: "defaultMode",
	1: "sources",
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ProjectedVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "sources":
			if err := func() error {
				s.Sources = make([]IoK8sAPICoreV1VolumeProjection, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeProjection
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sources = append(s.Sources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ProjectedVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"registry\"" + ":")
		e.Str(s.Registry)
	}
	{
		if s.Tenant.Set {
			e.Comma()
		}
		if s.Tenant.Set {
			e.RawStr("\"tenant\"" + ":")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"volume\"" + ":")
		e.Str(s.Volume)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource = [6]string{
	0: "group",
	1: "readOnly",
	2: "registry",
	3: "tenant",
	4: "user",
	5: "volume",
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1QuobyteVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "registry":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Registry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registry\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "volume":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Volume = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1QuobyteVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.Comma()
		}
		if s.Keyring.Set {
			e.RawStr("\"keyring\"" + ":")
			s.Keyring.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.Comma()
		}
		if s.Pool.Set {
			e.RawStr("\"pool\"" + ":")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1RBDPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "keyring":
			if err := func() error {
				s.Keyring.Reset()
				if err := s.Keyring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyring\"")
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "pool":
			if err := func() error {
				s.Pool.Reset()
				if err := s.Pool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1RBDPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.Comma()
		}
		if s.Keyring.Set {
			e.RawStr("\"keyring\"" + ":")
			s.Keyring.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.Comma()
		}
		if s.Pool.Set {
			e.RawStr("\"pool\"" + ":")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (s *IoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1RBDVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "keyring":
			if err := func() error {
				s.Keyring.Reset()
				if err := s.Keyring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyring\"")
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "pool":
			if err := func() error {
				s.Pool.Reset()
				if err := s.Pool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1RBDVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationController) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationController = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ReplicationController from json.
func (s *IoK8sAPICoreV1ReplicationController) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationController to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationController")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerCondition from json.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerList from json.
func (s *IoK8sAPICoreV1ReplicationControllerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ReplicationController, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ReplicationController
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Template.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpecSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerSpecSelector = [0]string{}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpecSelector from json.
func (s IoK8sAPICoreV1ReplicationControllerSpecSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerSpecSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerSpecSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullyLabeledReplicas.Set {
			e.RawStr("\"fullyLabeledReplicas\"" + ":")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1ReplicationControllerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ReplicationControllerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "fullyLabeledReplicas":
			if err := func() error {
				s.FullyLabeledReplicas.Reset()
				if err := s.FullyLabeledReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullyLabeledReplicas\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerName.Set {
			e.RawStr("\"containerName\"" + ":")
			s.ContainerName.Encode(e)
		}
	}
	{
		if s.Divisor.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Divisor.Set {
			e.RawStr("\"divisor\"" + ":")
			s.Divisor.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"resource\"" + ":")
		e.Str(s.Resource)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector = [3]string{
	0: "containerName",
	1: "divisor",
	2: "resource",
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (s *IoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceFieldSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerName":
			if err := func() error {
				s.ContainerName.Reset()
				if err := s.ContainerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerName\"")
			}
		case "divisor":
			if err := func() error {
				s.Divisor.Reset()
				if err := s.Divisor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divisor\"")
			}
		case "resource":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Resource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceFieldSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuota) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuota = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ResourceQuota from json.
func (s *IoK8sAPICoreV1ResourceQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuota")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaList from json.
func (s *IoK8sAPICoreV1ResourceQuotaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ResourceQuota, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ResourceQuota
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hard.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hard.Set {
			e.RawStr("\"hard\"" + ":")
			s.Hard.Encode(e)
		}
	}
	{
		if s.ScopeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScopeSelector.Set {
			e.RawStr("\"scopeSelector\"" + ":")
			s.ScopeSelector.Encode(e)
		}
	}
	{
		if s.Scopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes != nil {
			e.RawStr("\"scopes\"" + ":")
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaSpec = [3]string{
	0: "hard",
	1: "scopeSelector",
	2: "scopes",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			if err := func() error {
				s.Hard.Reset()
				if err := s.Hard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard\"")
			}
		case "scopeSelector":
			if err := func() error {
				s.ScopeSelector.Reset()
				if err := s.ScopeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopeSelector\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpecHard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaSpecHard = [0]string{}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpecHard from json.
func (s IoK8sAPICoreV1ResourceQuotaSpecHard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaSpecHard to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaSpecHard")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hard.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hard.Set {
			e.RawStr("\"hard\"" + ":")
			s.Hard.Encode(e)
		}
	}
	{
		if s.Used.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Used.Set {
			e.RawStr("\"used\"" + ":")
			s.Used.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaStatus = [2]string{
	0: "hard",
	1: "used",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			if err := func() error {
				s.Hard.Reset()
				if err := s.Hard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusHard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaStatusHard = [0]string{}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusHard from json.
func (s IoK8sAPICoreV1ResourceQuotaStatusHard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatusHard to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatusHard")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusUsed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaStatusUsed = [0]string{}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusUsed from json.
func (s IoK8sAPICoreV1ResourceQuotaStatusUsed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatusUsed to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatusUsed")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limits.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limits.Set {
			e.RawStr("\"limits\"" + ":")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Requests.Set {
			e.RawStr("\"requests\"" + ":")
			s.Requests.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceRequirements = [2]string{
	0: "limits",
	1: "requests",
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (s *IoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirements")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsLimits) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceRequirementsLimits = [0]string{}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsLimits from json.
func (s IoK8sAPICoreV1ResourceRequirementsLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirementsLimits to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirementsLimits")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsRequests) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceRequirementsRequests = [0]string{}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsRequests from json.
func (s IoK8sAPICoreV1ResourceRequirementsRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirementsRequests to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirementsRequests")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Level.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Level.Set {
			e.RawStr("\"level\"" + ":")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SELinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (s *IoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SELinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SELinuxOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"gateway\"" + ":")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.Comma()
		}
		if s.ProtectionDomain.Set {
			e.RawStr("\"protectionDomain\"" + ":")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"secretRef\"" + ":")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.Comma()
		}
		if s.SslEnabled.Set {
			e.RawStr("\"sslEnabled\"" + ":")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.Comma()
		}
		if s.StorageMode.Set {
			e.RawStr("\"storageMode\"" + ":")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.Comma()
		}
		if s.StoragePool.Set {
			e.RawStr("\"storagePool\"" + ":")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"system\"" + ":")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.Comma()
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "protectionDomain":
			if err := func() error {
				s.ProtectionDomain.Reset()
				if err := s.ProtectionDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protectionDomain\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "sslEnabled":
			if err := func() error {
				s.SslEnabled.Reset()
				if err := s.SslEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslEnabled\"")
			}
		case "storageMode":
			if err := func() error {
				s.StorageMode.Reset()
				if err := s.StorageMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageMode\"")
			}
		case "storagePool":
			if err := func() error {
				s.StoragePool.Reset()
				if err := s.StoragePool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePool\"")
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.System = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScaleIOPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"gateway\"" + ":")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.Comma()
		}
		if s.ProtectionDomain.Set {
			e.RawStr("\"protectionDomain\"" + ":")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"secretRef\"" + ":")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.Comma()
		}
		if s.SslEnabled.Set {
			e.RawStr("\"sslEnabled\"" + ":")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.Comma()
		}
		if s.StorageMode.Set {
			e.RawStr("\"storageMode\"" + ":")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.Comma()
		}
		if s.StoragePool.Set {
			e.RawStr("\"storagePool\"" + ":")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"system\"" + ":")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.Comma()
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScaleIOVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "protectionDomain":
			if err := func() error {
				s.ProtectionDomain.Reset()
				if err := s.ProtectionDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protectionDomain\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "sslEnabled":
			if err := func() error {
				s.SslEnabled.Reset()
				if err := s.SslEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslEnabled\"")
			}
		case "storageMode":
			if err := func() error {
				s.StorageMode.Reset()
				if err := s.StorageMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageMode\"")
			}
		case "storagePool":
			if err := func() error {
				s.StoragePool.Reset()
				if err := s.StoragePool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePool\"")
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.System = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScaleIOVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScopeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopeSelector = [1]string{
	0: "matchExpressions",
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (s *IoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScopeSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sAPICoreV1ScopedResourceSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ScopedResourceSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScopeSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScopedResourceSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		e.Comma()

		e.RawStr("\"scopeName\"" + ":")
		e.Str(s.ScopeName)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement = [3]string{
	0: "operator",
	1: "scopeName",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1ScopedResourceSelectorRequirement from json.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScopedResourceSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operator":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "scopeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ScopeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopeName\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScopedResourceSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SeccompProfile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LocalhostProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocalhostProfile.Set {
			e.RawStr("\"localhostProfile\"" + ":")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (s *IoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Secret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Immutable.Set {
			e.RawStr("\"immutable\"" + ":")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.StringData.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StringData.Set {
			e.RawStr("\"stringData\"" + ":")
			s.StringData.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Secret = [7]string{
	0: "apiVersion",
	1: "data",
	2: "immutable",
	3: "kind",
	4: "metadata",
	5: "stringData",
	6: "type",
}

// Decode decodes IoK8sAPICoreV1Secret from json.
func (s *IoK8sAPICoreV1Secret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Secret to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "immutable":
			if err := func() error {
				s.Immutable.Reset()
				if err := s.Immutable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immutable\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "stringData":
			if err := func() error {
				s.StringData.Reset()
				if err := s.StringData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stringData\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Secret")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Base64(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretData = [0]string{}

// Decode decodes IoK8sAPICoreV1SecretData from json.
func (s IoK8sAPICoreV1SecretData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretData to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem []byte
			if err := func() error {
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretData")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (s *IoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretEnvSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretEnvSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.Comma()
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (s *IoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretKeySelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretKeySelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1SecretList from json.
func (s *IoK8sAPICoreV1SecretList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Secret, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Secret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (s *IoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretProjection")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretReference = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (s *IoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretReference")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretStringData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretStringData = [0]string{}

// Decode decodes IoK8sAPICoreV1SecretStringData from json.
func (s IoK8sAPICoreV1SecretStringData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretStringData to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretStringData")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	{
		if s.SecretName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretName.Set {
			e.RawStr("\"secretName\"" + ":")
			s.SecretName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "optional",
	3: "secretName",
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (s *IoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		case "secretName":
			if err := func() error {
				s.SecretName.Reset()
				if err := s.SecretName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecurityContext) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowPrivilegeEscalation.Set {
			e.RawStr("\"allowPrivilegeEscalation\"" + ":")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capabilities.Set {
			e.RawStr("\"capabilities\"" + ":")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privileged.Set {
			e.RawStr("\"privileged\"" + ":")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProcMount.Set {
			e.RawStr("\"procMount\"" + ":")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnlyRootFilesystem.Set {
			e.RawStr("\"readOnlyRootFilesystem\"" + ":")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsNonRoot.Set {
			e.RawStr("\"runAsNonRoot\"" + ":")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUser.Set {
			e.RawStr("\"runAsUser\"" + ":")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeccompProfile.Set {
			e.RawStr("\"seccompProfile\"" + ":")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WindowsOptions.Set {
			e.RawStr("\"windowsOptions\"" + ":")
			s.WindowsOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (s *IoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "procMount":
			if err := func() error {
				s.ProcMount.Reset()
				if err := s.ProcMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"procMount\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecurityContext")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Service) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Service = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Service from json.
func (s *IoK8sAPICoreV1Service) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Service to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Service")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutomountServiceAccountToken.Set {
			e.RawStr("\"automountServiceAccountToken\"" + ":")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullSecrets != nil {
			e.RawStr("\"imagePullSecrets\"" + ":")
			e.ArrStart()
			if len(s.ImagePullSecrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ImagePullSecrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.ImagePullSecrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Secrets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secrets != nil {
			e.RawStr("\"secrets\"" + ":")
			e.ArrStart()
			if len(s.Secrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Secrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.Secrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccount = [6]string{
	0: "apiVersion",
	1: "automountServiceAccountToken",
	2: "imagePullSecrets",
	3: "kind",
	4: "metadata",
	5: "secrets",
}

// Decode decodes IoK8sAPICoreV1ServiceAccount from json.
func (s *IoK8sAPICoreV1ServiceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "automountServiceAccountToken":
			if err := func() error {
				s.AutomountServiceAccountToken.Reset()
				if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automountServiceAccountToken\"")
			}
		case "imagePullSecrets":
			if err := func() error {
				s.ImagePullSecrets = make([]IoK8sAPICoreV1LocalObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LocalObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullSecrets\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccount")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccountList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountList from json.
func (s *IoK8sAPICoreV1ServiceAccountList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccountList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ServiceAccount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ServiceAccount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccountList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Audience.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Audience.Set {
			e.RawStr("\"audience\"" + ":")
			s.Audience.Encode(e)
		}
	}
	{
		if s.ExpirationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection = [3]string{
	0: "audience",
	1: "expirationSeconds",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccountTokenProjection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			if err := func() error {
				s.Audience.Reset()
				if err := s.Audience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audience\"")
			}
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccountTokenProjection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceList from json.
func (s *IoK8sAPICoreV1ServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Service, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Service
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServicePort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodePort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodePort.Set {
			e.RawStr("\"nodePort\"" + ":")
			s.NodePort.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.TargetPort.Set {
			e.Comma()
		}
		if s.TargetPort.Set {
			e.RawStr("\"targetPort\"" + ":")
			s.TargetPort.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServicePort = [6]string{
	0: "appProtocol",
	1: "name",
	2: "nodePort",
	3: "port",
	4: "protocol",
	5: "targetPort",
}

// Decode decodes IoK8sAPICoreV1ServicePort from json.
func (s *IoK8sAPICoreV1ServicePort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServicePort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodePort":
			if err := func() error {
				s.NodePort.Reset()
				if err := s.NodePort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePort\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "targetPort":
			if err := func() error {
				s.TargetPort.Reset()
				if err := s.TargetPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPort\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServicePort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServicePort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServicePort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllocateLoadBalancerNodePorts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllocateLoadBalancerNodePorts.Set {
			e.RawStr("\"allocateLoadBalancerNodePorts\"" + ":")
			s.AllocateLoadBalancerNodePorts.Encode(e)
		}
	}
	{
		if s.ClusterIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterIP.Set {
			e.RawStr("\"clusterIP\"" + ":")
			s.ClusterIP.Encode(e)
		}
	}
	{
		if s.ClusterIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterIPs != nil {
			e.RawStr("\"clusterIPs\"" + ":")
			e.ArrStart()
			if len(s.ClusterIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ClusterIPs[0]
					e.Str(elem)
				}
				for _, elem := range s.ClusterIPs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalIPs != nil {
			e.RawStr("\"externalIPs\"" + ":")
			e.ArrStart()
			if len(s.ExternalIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ExternalIPs[0]
					e.Str(elem)
				}
				for _, elem := range s.ExternalIPs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalName.Set {
			e.RawStr("\"externalName\"" + ":")
			s.ExternalName.Encode(e)
		}
	}
	{
		if s.ExternalTrafficPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalTrafficPolicy.Set {
			e.RawStr("\"externalTrafficPolicy\"" + ":")
			s.ExternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.HealthCheckNodePort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HealthCheckNodePort.Set {
			e.RawStr("\"healthCheckNodePort\"" + ":")
			s.HealthCheckNodePort.Encode(e)
		}
	}
	{
		if s.InternalTrafficPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InternalTrafficPolicy.Set {
			e.RawStr("\"internalTrafficPolicy\"" + ":")
			s.InternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.IpFamilies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpFamilies != nil {
			e.RawStr("\"ipFamilies\"" + ":")
			e.ArrStart()
			if len(s.IpFamilies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.IpFamilies[0]
					e.Str(elem)
				}
				for _, elem := range s.IpFamilies[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.IpFamilyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpFamilyPolicy.Set {
			e.RawStr("\"ipFamilyPolicy\"" + ":")
			s.IpFamilyPolicy.Encode(e)
		}
	}
	{
		if s.LoadBalancerClass.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerClass.Set {
			e.RawStr("\"loadBalancerClass\"" + ":")
			s.LoadBalancerClass.Encode(e)
		}
	}
	{
		if s.LoadBalancerIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerIP.Set {
			e.RawStr("\"loadBalancerIP\"" + ":")
			s.LoadBalancerIP.Encode(e)
		}
	}
	{
		if s.LoadBalancerSourceRanges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerSourceRanges != nil {
			e.RawStr("\"loadBalancerSourceRanges\"" + ":")
			e.ArrStart()
			if len(s.LoadBalancerSourceRanges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LoadBalancerSourceRanges[0]
					e.Str(elem)
				}
				for _, elem := range s.LoadBalancerSourceRanges[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.PublishNotReadyAddresses.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublishNotReadyAddresses.Set {
			e.RawStr("\"publishNotReadyAddresses\"" + ":")
			s.PublishNotReadyAddresses.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.SessionAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SessionAffinity.Set {
			e.RawStr("\"sessionAffinity\"" + ":")
			s.SessionAffinity.Encode(e)
		}
	}
	{
		if s.SessionAffinityConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SessionAffinityConfig.Set {
			e.RawStr("\"sessionAffinityConfig\"" + ":")
			s.SessionAffinityConfig.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceSpec = [19]string{
	0:  "allocateLoadBalancerNodePorts",
	1:  "clusterIP",
	2:  "clusterIPs",
	3:  "externalIPs",
	4:  "externalName",
	5:  "externalTrafficPolicy",
	6:  "healthCheckNodePort",
	7:  "internalTrafficPolicy",
	8:  "ipFamilies",
	9:  "ipFamilyPolicy",
	10: "loadBalancerClass",
	11: "loadBalancerIP",
	12: "loadBalancerSourceRanges",
	13: "ports",
	14: "publishNotReadyAddresses",
	15: "selector",
	16: "sessionAffinity",
	17: "sessionAffinityConfig",
	18: "type",
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (s *IoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocateLoadBalancerNodePorts":
			if err := func() error {
				s.AllocateLoadBalancerNodePorts.Reset()
				if err := s.AllocateLoadBalancerNodePorts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocateLoadBalancerNodePorts\"")
			}
		case "clusterIP":
			if err := func() error {
				s.ClusterIP.Reset()
				if err := s.ClusterIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIP\"")
			}
		case "clusterIPs":
			if err := func() error {
				s.ClusterIPs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ClusterIPs = append(s.ClusterIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIPs\"")
			}
		case "externalIPs":
			if err := func() error {
				s.ExternalIPs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExternalIPs = append(s.ExternalIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalIPs\"")
			}
		case "externalName":
			if err := func() error {
				s.ExternalName.Reset()
				if err := s.ExternalName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalName\"")
			}
		case "externalTrafficPolicy":
			if err := func() error {
				s.ExternalTrafficPolicy.Reset()
				if err := s.ExternalTrafficPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalTrafficPolicy\"")
			}
		case "healthCheckNodePort":
			if err := func() error {
				s.HealthCheckNodePort.Reset()
				if err := s.HealthCheckNodePort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthCheckNodePort\"")
			}
		case "internalTrafficPolicy":
			if err := func() error {
				s.InternalTrafficPolicy.Reset()
				if err := s.InternalTrafficPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalTrafficPolicy\"")
			}
		case "ipFamilies":
			if err := func() error {
				s.IpFamilies = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IpFamilies = append(s.IpFamilies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipFamilies\"")
			}
		case "ipFamilyPolicy":
			if err := func() error {
				s.IpFamilyPolicy.Reset()
				if err := s.IpFamilyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipFamilyPolicy\"")
			}
		case "loadBalancerClass":
			if err := func() error {
				s.LoadBalancerClass.Reset()
				if err := s.LoadBalancerClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerClass\"")
			}
		case "loadBalancerIP":
			if err := func() error {
				s.LoadBalancerIP.Reset()
				if err := s.LoadBalancerIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIP\"")
			}
		case "loadBalancerSourceRanges":
			if err := func() error {
				s.LoadBalancerSourceRanges = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LoadBalancerSourceRanges = append(s.LoadBalancerSourceRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerSourceRanges\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ServicePort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ServicePort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "publishNotReadyAddresses":
			if err := func() error {
				s.PublishNotReadyAddresses.Reset()
				if err := s.PublishNotReadyAddresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishNotReadyAddresses\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "sessionAffinity":
			if err := func() error {
				s.SessionAffinity.Reset()
				if err := s.SessionAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionAffinity\"")
			}
		case "sessionAffinityConfig":
			if err := func() error {
				s.SessionAffinityConfig.Reset()
				if err := s.SessionAffinityConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionAffinityConfig\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceSpecSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceSpecSelector = [0]string{}

// Decode decodes IoK8sAPICoreV1ServiceSpecSelector from json.
func (s IoK8sAPICoreV1ServiceSpecSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceSpecSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceSpecSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LoadBalancer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancer.Set {
			e.RawStr("\"loadBalancer\"" + ":")
			s.LoadBalancer.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceStatus = [2]string{
	0: "conditions",
	1: "loadBalancer",
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (s *IoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "loadBalancer":
			if err := func() error {
				s.LoadBalancer.Reset()
				if err := s.LoadBalancer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClientIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientIP.Set {
			e.RawStr("\"clientIP\"" + ":")
			s.ClientIP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SessionAffinityConfig = [1]string{
	0: "clientIP",
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (s *IoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SessionAffinityConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientIP":
			if err := func() error {
				s.ClientIP.Reset()
				if err := s.ClientIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientIP\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SessionAffinityConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeNamespace.Set {
			e.RawStr("\"volumeNamespace\"" + ":")
			s.VolumeNamespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSPersistentVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1StorageOSPersistentVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		case "volumeNamespace":
			if err := func() error {
				s.VolumeNamespace.Reset()
				if err := s.VolumeNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeNamespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1StorageOSPersistentVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeNamespace.Set {
			e.RawStr("\"volumeNamespace\"" + ":")
			s.VolumeNamespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1StorageOSVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		case "volumeNamespace":
			if err := func() error {
				s.VolumeNamespace.Reset()
				if err := s.VolumeNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeNamespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1StorageOSVolumeSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Sysctl) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Sysctl = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1Sysctl from json.
func (s *IoK8sAPICoreV1Sysctl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Sysctl to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Sysctl")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Sysctl) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Sysctl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		s.Port.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction = [2]string{
	0: "host",
	1: "port",
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (s *IoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TCPSocketAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TCPSocketAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Taint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"effect\"" + ":")
		e.Str(s.Effect)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.TimeAdded.Set {
			e.Comma()
		}
		if s.TimeAdded.Set {
			e.RawStr("\"timeAdded\"" + ":")
			s.TimeAdded.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Taint = [4]string{
	0: "effect",
	1: "key",
	2: "timeAdded",
	3: "value",
}

// Decode decodes IoK8sAPICoreV1Taint from json.
func (s *IoK8sAPICoreV1Taint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Taint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Effect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "timeAdded":
			if err := func() error {
				s.TimeAdded.Reset()
				if err := s.TimeAdded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeAdded\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Taint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Taint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Taint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Toleration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Effect.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Effect.Set {
			e.RawStr("\"effect\"" + ":")
			s.Effect.Encode(e)
		}
	}
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operator.Set {
			e.RawStr("\"operator\"" + ":")
			s.Operator.Encode(e)
		}
	}
	{
		if s.TolerationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TolerationSeconds.Set {
			e.RawStr("\"tolerationSeconds\"" + ":")
			s.TolerationSeconds.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Toleration = [5]string{
	0: "effect",
	1: "key",
	2: "operator",
	3: "tolerationSeconds",
	4: "value",
}

// Decode decodes IoK8sAPICoreV1Toleration from json.
func (s *IoK8sAPICoreV1Toleration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Toleration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			if err := func() error {
				s.Effect.Reset()
				if err := s.Effect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "tolerationSeconds":
			if err := func() error {
				s.TolerationSeconds.Reset()
				if err := s.TolerationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerationSeconds\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Toleration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySelectorLabelRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"values\"" + ":")
		e.ArrStart()
		if len(s.Values) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Values[0]
				e.Str(elem)
			}
			for _, elem := range s.Values[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement = [2]string{
	0: "key",
	1: "values",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorLabelRequirement from json.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySelectorLabelRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySelectorLabelRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySelectorTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchLabelExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchLabelExpressions != nil {
			e.RawStr("\"matchLabelExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchLabelExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchLabelExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchLabelExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorTerm = [1]string{
	0: "matchLabelExpressions",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorTerm from json.
func (s *IoK8sAPICoreV1TopologySelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySelectorTerm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchLabelExpressions":
			if err := func() error {
				s.MatchLabelExpressions = make([]IoK8sAPICoreV1TopologySelectorLabelRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySelectorLabelRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchLabelExpressions = append(s.MatchLabelExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabelExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySelectorTerm")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySpreadConstraint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelector.Set {
			e.RawStr("\"labelSelector\"" + ":")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxSkew\"" + ":")
		e.Int32(s.MaxSkew)
	}
	{
		e.Comma()

		e.RawStr("\"topologyKey\"" + ":")
		e.Str(s.TopologyKey)
	}
	{
		e.Comma()

		e.RawStr("\"whenUnsatisfiable\"" + ":")
		e.Str(s.WhenUnsatisfiable)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint = [4]string{
	0: "labelSelector",
	1: "maxSkew",
	2: "topologyKey",
	3: "whenUnsatisfiable",
}

// Decode decodes IoK8sAPICoreV1TopologySpreadConstraint from json.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySpreadConstraint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "maxSkew":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxSkew = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSkew\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		case "whenUnsatisfiable":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WhenUnsatisfiable = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whenUnsatisfiable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySpreadConstraint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TypedLocalObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TypedLocalObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Volume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AwsElasticBlockStore.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AwsElasticBlockStore.Set {
			e.RawStr("\"awsElasticBlockStore\"" + ":")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureDisk.Set {
			e.RawStr("\"azureDisk\"" + ":")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureFile.Set {
			e.RawStr("\"azureFile\"" + ":")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cephfs.Set {
			e.RawStr("\"cephfs\"" + ":")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cinder.Set {
			e.RawStr("\"cinder\"" + ":")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Csi.Set {
			e.RawStr("\"csi\"" + ":")
			s.Csi.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownwardAPI.Set {
			e.RawStr("\"downwardAPI\"" + ":")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.EmptyDir.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EmptyDir.Set {
			e.RawStr("\"emptyDir\"" + ":")
			s.EmptyDir.Encode(e)
		}
	}
	{
		if s.Ephemeral.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ephemeral.Set {
			e.RawStr("\"ephemeral\"" + ":")
			s.Ephemeral.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fc.Set {
			e.RawStr("\"fc\"" + ":")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FlexVolume.Set {
			e.RawStr("\"flexVolume\"" + ":")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Flocker.Set {
			e.RawStr("\"flocker\"" + ":")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GcePersistentDisk.Set {
			e.RawStr("\"gcePersistentDisk\"" + ":")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.GitRepo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRepo.Set {
			e.RawStr("\"gitRepo\"" + ":")
			s.GitRepo.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Glusterfs.Set {
			e.RawStr("\"glusterfs\"" + ":")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostPath.Set {
			e.RawStr("\"hostPath\"" + ":")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Iscsi.Set {
			e.RawStr("\"iscsi\"" + ":")
			s.Iscsi.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Nfs.Set {
			e.Comma()
		}
		if s.Nfs.Set {
			e.RawStr("\"nfs\"" + ":")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.PersistentVolumeClaim.Set {
			e.Comma()
		}
		if s.PersistentVolumeClaim.Set {
			e.RawStr("\"persistentVolumeClaim\"" + ":")
			s.PersistentVolumeClaim.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			e.Comma()
		}
		if s.PhotonPersistentDisk.Set {
			e.RawStr("\"photonPersistentDisk\"" + ":")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			e.Comma()
		}
		if s.PortworxVolume.Set {
			e.RawStr("\"portworxVolume\"" + ":")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Projected.Set {
			e.Comma()
		}
		if s.Projected.Set {
			e.RawStr("\"projected\"" + ":")
			s.Projected.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			e.Comma()
		}
		if s.Quobyte.Set {
			e.RawStr("\"quobyte\"" + ":")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			e.Comma()
		}
		if s.Rbd.Set {
			e.RawStr("\"rbd\"" + ":")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			e.Comma()
		}
		if s.ScaleIO.Set {
			e.RawStr("\"scaleIO\"" + ":")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			e.Comma()
		}
		if s.Storageos.Set {
			e.RawStr("\"storageos\"" + ":")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			e.Comma()
		}
		if s.VsphereVolume.Set {
			e.RawStr("\"vsphereVolume\"" + ":")
			s.VsphereVolume.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Volume = [30]string{
	0:  "awsElasticBlockStore",
	1:  "azureDisk",
	2:  "azureFile",
	3:  "cephfs",
	4:  "cinder",
	5:  "configMap",
	6:  "csi",
	7:  "downwardAPI",
	8:  "emptyDir",
	9:  "ephemeral",
	10: "fc",
	11: "flexVolume",
	12: "flocker",
	13: "gcePersistentDisk",
	14: "gitRepo",
	15: "glusterfs",
	16: "hostPath",
	17: "iscsi",
	18: "name",
	19: "nfs",
	20: "persistentVolumeClaim",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "projected",
	24: "quobyte",
	25: "rbd",
	26: "scaleIO",
	27: "secret",
	28: "storageos",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1Volume from json.
func (s *IoK8sAPICoreV1Volume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Volume to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "awsElasticBlockStore":
			if err := func() error {
				s.AwsElasticBlockStore.Reset()
				if err := s.AwsElasticBlockStore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"awsElasticBlockStore\"")
			}
		case "azureDisk":
			if err := func() error {
				s.AzureDisk.Reset()
				if err := s.AzureDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureDisk\"")
			}
		case "azureFile":
			if err := func() error {
				s.AzureFile.Reset()
				if err := s.AzureFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureFile\"")
			}
		case "cephfs":
			if err := func() error {
				s.Cephfs.Reset()
				if err := s.Cephfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cephfs\"")
			}
		case "cinder":
			if err := func() error {
				s.Cinder.Reset()
				if err := s.Cinder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cinder\"")
			}
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		case "csi":
			if err := func() error {
				s.Csi.Reset()
				if err := s.Csi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csi\"")
			}
		case "downwardAPI":
			if err := func() error {
				s.DownwardAPI.Reset()
				if err := s.DownwardAPI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downwardAPI\"")
			}
		case "emptyDir":
			if err := func() error {
				s.EmptyDir.Reset()
				if err := s.EmptyDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emptyDir\"")
			}
		case "ephemeral":
			if err := func() error {
				s.Ephemeral.Reset()
				if err := s.Ephemeral.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeral\"")
			}
		case "fc":
			if err := func() error {
				s.Fc.Reset()
				if err := s.Fc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fc\"")
			}
		case "flexVolume":
			if err := func() error {
				s.FlexVolume.Reset()
				if err := s.FlexVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flexVolume\"")
			}
		case "flocker":
			if err := func() error {
				s.Flocker.Reset()
				if err := s.Flocker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flocker\"")
			}
		case "gcePersistentDisk":
			if err := func() error {
				s.GcePersistentDisk.Reset()
				if err := s.GcePersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gcePersistentDisk\"")
			}
		case "gitRepo":
			if err := func() error {
				s.GitRepo.Reset()
				if err := s.GitRepo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitRepo\"")
			}
		case "glusterfs":
			if err := func() error {
				s.Glusterfs.Reset()
				if err := s.Glusterfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"glusterfs\"")
			}
		case "hostPath":
			if err := func() error {
				s.HostPath.Reset()
				if err := s.HostPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPath\"")
			}
		case "iscsi":
			if err := func() error {
				s.Iscsi.Reset()
				if err := s.Iscsi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsi\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nfs":
			if err := func() error {
				s.Nfs.Reset()
				if err := s.Nfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nfs\"")
			}
		case "persistentVolumeClaim":
			if err := func() error {
				s.PersistentVolumeClaim.Reset()
				if err := s.PersistentVolumeClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeClaim\"")
			}
		case "photonPersistentDisk":
			if err := func() error {
				s.PhotonPersistentDisk.Reset()
				if err := s.PhotonPersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photonPersistentDisk\"")
			}
		case "portworxVolume":
			if err := func() error {
				s.PortworxVolume.Reset()
				if err := s.PortworxVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portworxVolume\"")
			}
		case "projected":
			if err := func() error {
				s.Projected.Reset()
				if err := s.Projected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projected\"")
			}
		case "quobyte":
			if err := func() error {
				s.Quobyte.Reset()
				if err := s.Quobyte.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quobyte\"")
			}
		case "rbd":
			if err := func() error {
				s.Rbd.Reset()
				if err := s.Rbd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rbd\"")
			}
		case "scaleIO":
			if err := func() error {
				s.ScaleIO.Reset()
				if err := s.ScaleIO.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleIO\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "storageos":
			if err := func() error {
				s.Storageos.Reset()
				if err := s.Storageos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageos\"")
			}
		case "vsphereVolume":
			if err := func() error {
				s.VsphereVolume.Reset()
				if err := s.VsphereVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereVolume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Volume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000000,
		0b00000000,
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Volume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Volume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeDevice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"devicePath\"" + ":")
		e.Str(s.DevicePath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1VolumeDevice from json.
func (s *IoK8sAPICoreV1VolumeDevice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeDevice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DevicePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devicePath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeDevice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeMount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"mountPath\"" + ":")
		e.Str(s.MountPath)
	}
	{
		if s.MountPropagation.Set {
			e.Comma()
		}
		if s.MountPropagation.Set {
			e.RawStr("\"mountPropagation\"" + ":")
			s.MountPropagation.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SubPath.Set {
			e.Comma()
		}
		if s.SubPath.Set {
			e.RawStr("\"subPath\"" + ":")
			s.SubPath.Encode(e)
		}
	}
	{
		if s.SubPathExpr.Set {
			e.Comma()
		}
		if s.SubPathExpr.Set {
			e.RawStr("\"subPathExpr\"" + ":")
			s.SubPathExpr.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeMount = [6]string{
	0: "mountPath",
	1: "mountPropagation",
	2: "name",
	3: "readOnly",
	4: "subPath",
	5: "subPathExpr",
}

// Decode decodes IoK8sAPICoreV1VolumeMount from json.
func (s *IoK8sAPICoreV1VolumeMount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeMount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mountPath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MountPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountPath\"")
			}
		case "mountPropagation":
			if err := func() error {
				s.MountPropagation.Reset()
				if err := s.MountPropagation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountPropagation\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "subPath":
			if err := func() error {
				s.SubPath.Reset()
				if err := s.SubPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subPath\"")
			}
		case "subPathExpr":
			if err := func() error {
				s.SubPathExpr.Reset()
				if err := s.SubPathExpr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subPathExpr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeMount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeMount) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeMount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Required.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Required.Set {
			e.RawStr("\"required\"" + ":")
			s.Required.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeNodeAffinity = [1]string{
	0: "required",
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeNodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeNodeAffinity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownwardAPI.Set {
			e.RawStr("\"downwardAPI\"" + ":")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.ServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ServiceAccountToken.Set {
			e.RawStr("\"serviceAccountToken\"" + ":")
			s.ServiceAccountToken.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeProjection = [4]string{
	0: "configMap",
	1: "downwardAPI",
	2: "secret",
	3: "serviceAccountToken",
}

// Decode decodes IoK8sAPICoreV1VolumeProjection from json.
func (s *IoK8sAPICoreV1VolumeProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		case "downwardAPI":
			if err := func() error {
				s.DownwardAPI.Reset()
				if err := s.DownwardAPI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downwardAPI\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "serviceAccountToken":
			if err := func() error {
				s.ServiceAccountToken.Reset()
				if err := s.ServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeProjection")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.StoragePolicyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoragePolicyID.Set {
			e.RawStr("\"storagePolicyID\"" + ":")
			s.StoragePolicyID.Encode(e)
		}
	}
	{
		if s.StoragePolicyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoragePolicyName.Set {
			e.RawStr("\"storagePolicyName\"" + ":")
			s.StoragePolicyName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumePath\"" + ":")
		e.Str(s.VolumePath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource = [4]string{
	0: "fsType",
	1: "storagePolicyID",
	2: "storagePolicyName",
	3: "volumePath",
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "storagePolicyID":
			if err := func() error {
				s.StoragePolicyID.Reset()
				if err := s.StoragePolicyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePolicyID\"")
			}
		case "storagePolicyName":
			if err := func() error {
				s.StoragePolicyName.Reset()
				if err := s.StoragePolicyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePolicyName\"")
			}
		case "volumePath":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VsphereVirtualDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1WeightedPodAffinityTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"podAffinityTerm\"" + ":")
		s.PodAffinityTerm.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"weight\"" + ":")
		e.Int32(s.Weight)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm = [2]string{
	0: "podAffinityTerm",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1WeightedPodAffinityTerm from json.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1WeightedPodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PodAffinityTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinityTerm\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1WeightedPodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GmsaCredentialSpec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GmsaCredentialSpec.Set {
			e.RawStr("\"gmsaCredentialSpec\"" + ":")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GmsaCredentialSpecName.Set {
			e.RawStr("\"gmsaCredentialSpecName\"" + ":")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostProcess.Set {
			e.RawStr("\"hostProcess\"" + ":")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUserName.Set {
			e.RawStr("\"runAsUserName\"" + ":")
			s.RunAsUserName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1WindowsSecurityContextOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1WindowsSecurityContextOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1WindowsSecurityContextOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1Endpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addresses\"" + ":")
		e.ArrStart()
		if len(s.Addresses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Addresses[0]
				e.Str(elem)
			}
			for _, elem := range s.Addresses[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.Comma()
		}
		if s.Conditions.Set {
			e.RawStr("\"conditions\"" + ":")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.DeprecatedTopology.Set {
			e.Comma()
		}
		if s.DeprecatedTopology.Set {
			e.RawStr("\"deprecatedTopology\"" + ":")
			s.DeprecatedTopology.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.Comma()
		}
		if s.Hints.Set {
			e.RawStr("\"hints\"" + ":")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.Comma()
		}
		if s.Zone.Set {
			e.RawStr("\"zone\"" + ":")
			s.Zone.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint = [8]string{
	0: "addresses",
	1: "conditions",
	2: "deprecatedTopology",
	3: "hints",
	4: "hostname",
	5: "nodeName",
	6: "targetRef",
	7: "zone",
}

// Decode decodes IoK8sAPIDiscoveryV1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1Endpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions.Reset()
				if err := s.Conditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "deprecatedTopology":
			if err := func() error {
				s.DeprecatedTopology.Reset()
				if err := s.DeprecatedTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedTopology\"")
			}
		case "hints":
			if err := func() error {
				s.Hints.Reset()
				if err := s.Hints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hints\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		case "zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1Endpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ready.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ready.Set {
			e.RawStr("\"ready\"" + ":")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Serving.Set {
			e.RawStr("\"serving\"" + ":")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminating.Set {
			e.RawStr("\"terminating\"" + ":")
			s.Terminating.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "serving":
			if err := func() error {
				s.Serving.Reset()
				if err := s.Serving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serving\"")
			}
		case "terminating":
			if err := func() error {
				s.Terminating.Reset()
				if err := s.Terminating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointConditions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointDeprecatedTopology = [0]string{}

// Decode decodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology from json.
func (s IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointDeprecatedTopology to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointDeprecatedTopology")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ForZones != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForZones != nil {
			e.RawStr("\"forZones\"" + ":")
			e.ArrStart()
			if len(s.ForZones) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForZones[0]
					elem.Encode(e)
				}
				for _, elem := range s.ForZones[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointHints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			if err := func() error {
				s.ForZones = make([]IoK8sAPIDiscoveryV1ForZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1ForZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ForZones = append(s.ForZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forZones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointHints")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointPort")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointSlice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addressType\"" + ":")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.Comma()
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"endpoints\"" + ":")
		e.ArrStart()
		if len(s.Endpoints) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Endpoints[0]
				elem.Encode(e)
			}
			for _, elem := range s.Endpoints[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSlice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AddressType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressType\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Endpoints = make([]IoK8sAPIDiscoveryV1Endpoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1Endpoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Endpoints = append(s.Endpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPIDiscoveryV1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointSlice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointSliceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSliceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIDiscoveryV1EndpointSlice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1EndpointSlice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointSliceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1ForZone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1ForZone from json.
func (s *IoK8sAPIDiscoveryV1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1ForZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1ForZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1Endpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addresses\"" + ":")
		e.ArrStart()
		if len(s.Addresses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Addresses[0]
				e.Str(elem)
			}
			for _, elem := range s.Addresses[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.Comma()
		}
		if s.Conditions.Set {
			e.RawStr("\"conditions\"" + ":")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.Comma()
		}
		if s.Hints.Set {
			e.RawStr("\"hints\"" + ":")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Topology.Set {
			e.Comma()
		}
		if s.Topology.Set {
			e.RawStr("\"topology\"" + ":")
			s.Topology.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint = [7]string{
	0: "addresses",
	1: "conditions",
	2: "hints",
	3: "hostname",
	4: "nodeName",
	5: "targetRef",
	6: "topology",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1Endpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions.Reset()
				if err := s.Conditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "hints":
			if err := func() error {
				s.Hints.Reset()
				if err := s.Hints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hints\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		case "topology":
			if err := func() error {
				s.Topology.Reset()
				if err := s.Topology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topology\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1Endpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ready.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ready.Set {
			e.RawStr("\"ready\"" + ":")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Serving.Set {
			e.RawStr("\"serving\"" + ":")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminating.Set {
			e.RawStr("\"terminating\"" + ":")
			s.Terminating.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "serving":
			if err := func() error {
				s.Serving.Reset()
				if err := s.Serving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serving\"")
			}
		case "terminating":
			if err := func() error {
				s.Terminating.Reset()
				if err := s.Terminating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointConditions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ForZones != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForZones != nil {
			e.RawStr("\"forZones\"" + ":")
			e.ArrStart()
			if len(s.ForZones) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForZones[0]
					elem.Encode(e)
				}
				for _, elem := range s.ForZones[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointHints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			if err := func() error {
				s.ForZones = make([]IoK8sAPIDiscoveryV1beta1ForZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1ForZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ForZones = append(s.ForZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forZones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointHints")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointPort")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointSlice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addressType\"" + ":")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.Comma()
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"endpoints\"" + ":")
		e.ArrStart()
		if len(s.Endpoints) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Endpoints[0]
				elem.Encode(e)
			}
			for _, elem := range s.Endpoints[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSlice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AddressType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressType\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Endpoints = make([]IoK8sAPIDiscoveryV1beta1Endpoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1Endpoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Endpoints = append(s.Endpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPIDiscoveryV1beta1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointSlice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointSliceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSliceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIDiscoveryV1beta1EndpointSlice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1EndpointSlice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointSliceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointTopology) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointTopology = [0]string{}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointTopology from json.
func (s IoK8sAPIDiscoveryV1beta1EndpointTopology) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointTopology to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointTopology")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1ForZone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1ForZone from json.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1ForZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1ForZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedCount.Set {
			e.RawStr("\"deprecatedCount\"" + ":")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedFirstTimestamp.Set {
			e.RawStr("\"deprecatedFirstTimestamp\"" + ":")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedLastTimestamp.Set {
			e.RawStr("\"deprecatedLastTimestamp\"" + ":")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedSource.Set {
			e.RawStr("\"deprecatedSource\"" + ":")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"eventTime\"" + ":")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.Comma()
		}
		if s.Regarding.Set {
			e.RawStr("\"regarding\"" + ":")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.Comma()
		}
		if s.ReportingController.Set {
			e.RawStr("\"reportingController\"" + ":")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1Event from json.
func (s *IoK8sAPIEventsV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "deprecatedCount":
			if err := func() error {
				s.DeprecatedCount.Reset()
				if err := s.DeprecatedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedCount\"")
			}
		case "deprecatedFirstTimestamp":
			if err := func() error {
				s.DeprecatedFirstTimestamp.Reset()
				if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedFirstTimestamp\"")
			}
		case "deprecatedLastTimestamp":
			if err := func() error {
				s.DeprecatedLastTimestamp.Reset()
				if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedLastTimestamp\"")
			}
		case "deprecatedSource":
			if err := func() error {
				s.DeprecatedSource.Reset()
				if err := s.DeprecatedSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedSource\"")
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "regarding":
			if err := func() error {
				s.Regarding.Reset()
				if err := s.Regarding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regarding\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingController":
			if err := func() error {
				s.ReportingController.Reset()
				if err := s.ReportingController.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingController\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1EventList from json.
func (s *IoK8sAPIEventsV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIEventsV1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIEventsV1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int32(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"lastObservedTime\"" + ":")
		s.LastObservedTime.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (s *IoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1EventSeries to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Count = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1EventSeries")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedCount.Set {
			e.RawStr("\"deprecatedCount\"" + ":")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedFirstTimestamp.Set {
			e.RawStr("\"deprecatedFirstTimestamp\"" + ":")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedLastTimestamp.Set {
			e.RawStr("\"deprecatedLastTimestamp\"" + ":")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedSource.Set {
			e.RawStr("\"deprecatedSource\"" + ":")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"eventTime\"" + ":")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.Comma()
		}
		if s.Regarding.Set {
			e.RawStr("\"regarding\"" + ":")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.Comma()
		}
		if s.ReportingController.Set {
			e.RawStr("\"reportingController\"" + ":")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1beta1Event from json.
func (s *IoK8sAPIEventsV1beta1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "deprecatedCount":
			if err := func() error {
				s.DeprecatedCount.Reset()
				if err := s.DeprecatedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedCount\"")
			}
		case "deprecatedFirstTimestamp":
			if err := func() error {
				s.DeprecatedFirstTimestamp.Reset()
				if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedFirstTimestamp\"")
			}
		case "deprecatedLastTimestamp":
			if err := func() error {
				s.DeprecatedLastTimestamp.Reset()
				if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedLastTimestamp\"")
			}
		case "deprecatedSource":
			if err := func() error {
				s.DeprecatedSource.Reset()
				if err := s.DeprecatedSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedSource\"")
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "regarding":
			if err := func() error {
				s.Regarding.Reset()
				if err := s.Regarding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regarding\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingController":
			if err := func() error {
				s.ReportingController.Reset()
				if err := s.ReportingController.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingController\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1beta1EventList from json.
func (s *IoK8sAPIEventsV1beta1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIEventsV1beta1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIEventsV1beta1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int32(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"lastObservedTime\"" + ":")
		s.LastObservedTime.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (s *IoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1EventSeries to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Count = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1EventSeries")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchema) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchema")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta1FlowSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1FlowSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DistinguisherMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DistinguisherMethod.Set {
			e.RawStr("\"distinguisherMethod\"" + ":")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchingPrecedence.Set {
			e.RawStr("\"matchingPrecedence\"" + ":")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"priorityLevelConfiguration\"" + ":")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			if err := func() error {
				s.DistinguisherMethod.Reset()
				if err := s.DistinguisherMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinguisherMethod\"")
			}
		case "matchingPrecedence":
			if err := func() error {
				s.MatchingPrecedence.Reset()
				if err := s.MatchingPrecedence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchingPrecedence\"")
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityLevelConfiguration\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1GroupSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1GroupSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Queuing.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queuing.Set {
			e.RawStr("\"queuing\"" + ":")
			s.Queuing.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			if err := func() error {
				s.Queuing.Reset()
				if err := s.Queuing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queuing\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1LimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AssuredConcurrencyShares.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssuredConcurrencyShares.Set {
			e.RawStr("\"assuredConcurrencyShares\"" + ":")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitResponse.Set {
			e.RawStr("\"limitResponse\"" + ":")
			s.LimitResponse.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			if err := func() error {
				s.AssuredConcurrencyShares.Reset()
				if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assuredConcurrencyShares\"")
			}
		case "limitResponse":
			if err := func() error {
				s.LimitResponse.Reset()
				if err := s.LimitResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nonResourceURLs\"" + ":")
		e.ArrStart()
		if len(s.NonResourceURLs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NonResourceURLs[0]
				e.Str(elem)
			}
			for _, elem := range s.NonResourceURLs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NonResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceRules != nil {
			e.RawStr("\"nonResourceRules\"" + ":")
			e.ArrStart()
			if len(s.NonResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.NonResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceRules != nil {
			e.RawStr("\"resourceRules\"" + ":")
			e.ArrStart()
			if len(s.ResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.ResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subjects\"" + ":")
		e.ArrStart()
		if len(s.Subjects) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subjects[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subjects[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			if err := func() error {
				s.NonResourceRules = make([]IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NonResourceRules = append(s.NonResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceRules\"")
			}
		case "resourceRules":
			if err := func() error {
				s.ResourceRules = make([]IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceRules = append(s.ResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceRules\"")
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Subjects = make([]IoK8sAPIFlowcontrolV1beta1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limited.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limited.Set {
			e.RawStr("\"limited\"" + ":")
			s.Limited.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			if err := func() error {
				s.Limited.Reset()
				if err := s.Limited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.HandSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HandSize.Set {
			e.RawStr("\"handSize\"" + ":")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QueueLengthLimit.Set {
			e.RawStr("\"queueLengthLimit\"" + ":")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queues.Set {
			e.RawStr("\"queues\"" + ":")
			s.Queues.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			if err := func() error {
				s.HandSize.Reset()
				if err := s.HandSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handSize\"")
			}
		case "queueLengthLimit":
			if err := func() error {
				s.QueueLengthLimit.Reset()
				if err := s.QueueLengthLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueLengthLimit\"")
			}
		case "queues":
			if err := func() error {
				s.Queues.Reset()
				if err := s.Queues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1QueuingConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroups\"" + ":")
		e.ArrStart()
		if len(s.ApiGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ApiGroups[0]
				e.Str(elem)
			}
			for _, elem := range s.ApiGroups[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.Comma()
		}
		if s.ClusterScope.Set {
			e.RawStr("\"clusterScope\"" + ":")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.Comma()
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				e.Str(elem)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "clusterScope":
			if err := func() error {
				s.ClusterScope.Reset()
				if err := s.ClusterScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterScope\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1UserSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1UserSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchema) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchema")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta2FlowSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2FlowSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DistinguisherMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DistinguisherMethod.Set {
			e.RawStr("\"distinguisherMethod\"" + ":")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchingPrecedence.Set {
			e.RawStr("\"matchingPrecedence\"" + ":")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"priorityLevelConfiguration\"" + ":")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			if err := func() error {
				s.DistinguisherMethod.Reset()
				if err := s.DistinguisherMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinguisherMethod\"")
			}
		case "matchingPrecedence":
			if err := func() error {
				s.MatchingPrecedence.Reset()
				if err := s.MatchingPrecedence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchingPrecedence\"")
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityLevelConfiguration\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2GroupSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2GroupSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Queuing.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queuing.Set {
			e.RawStr("\"queuing\"" + ":")
			s.Queuing.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			if err := func() error {
				s.Queuing.Reset()
				if err := s.Queuing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queuing\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2LimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AssuredConcurrencyShares.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssuredConcurrencyShares.Set {
			e.RawStr("\"assuredConcurrencyShares\"" + ":")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitResponse.Set {
			e.RawStr("\"limitResponse\"" + ":")
			s.LimitResponse.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			if err := func() error {
				s.AssuredConcurrencyShares.Reset()
				if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assuredConcurrencyShares\"")
			}
		case "limitResponse":
			if err := func() error {
				s.LimitResponse.Reset()
				if err := s.LimitResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nonResourceURLs\"" + ":")
		e.ArrStart()
		if len(s.NonResourceURLs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NonResourceURLs[0]
				e.Str(elem)
			}
			for _, elem := range s.NonResourceURLs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NonResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceRules != nil {
			e.RawStr("\"nonResourceRules\"" + ":")
			e.ArrStart()
			if len(s.NonResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.NonResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceRules != nil {
			e.RawStr("\"resourceRules\"" + ":")
			e.ArrStart()
			if len(s.ResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.ResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subjects\"" + ":")
		e.ArrStart()
		if len(s.Subjects) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subjects[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subjects[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			if err := func() error {
				s.NonResourceRules = make([]IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NonResourceRules = append(s.NonResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceRules\"")
			}
		case "resourceRules":
			if err := func() error {
				s.ResourceRules = make([]IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceRules = append(s.ResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceRules\"")
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Subjects = make([]IoK8sAPIFlowcontrolV1beta2Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limited.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limited.Set {
			e.RawStr("\"limited\"" + ":")
			s.Limited.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			if err := func() error {
				s.Limited.Reset()
				if err := s.Limited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.HandSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HandSize.Set {
			e.RawStr("\"handSize\"" + ":")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QueueLengthLimit.Set {
			e.RawStr("\"queueLengthLimit\"" + ":")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queues.Set {
			e.RawStr("\"queues\"" + ":")
			s.Queues.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			if err := func() error {
				s.HandSize.Reset()
				if err := s.HandSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handSize\"")
			}
		case "queueLengthLimit":
			if err := func() error {
				s.QueueLengthLimit.Reset()
				if err := s.QueueLengthLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueLengthLimit\"")
			}
		case "queues":
			if err := func() error {
				s.Queues.Reset()
				if err := s.Queues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2QueuingConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroups\"" + ":")
		e.ArrStart()
		if len(s.ApiGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ApiGroups[0]
				e.Str(elem)
			}
			for _, elem := range s.ApiGroups[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.Comma()
		}
		if s.ClusterScope.Set {
			e.RawStr("\"clusterScope\"" + ":")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.Comma()
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				e.Str(elem)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "clusterScope":
			if err := func() error {
				s.ClusterScope.Reset()
				if err := s.ClusterScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterScope\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2UserSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2UserSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1HTTPIngressPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"backend\"" + ":")
		s.Backend.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pathType\"" + ":")
		e.Str(s.PathType)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath = [3]string{
	0: "backend",
	1: "path",
	2: "pathType",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressPath from json.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressPath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backend":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Backend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backend\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "pathType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PathType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1HTTPIngressPath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"paths\"" + ":")
		e.ArrStart()
		if len(s.Paths) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Paths[0]
				elem.Encode(e)
			}
			for _, elem := range s.Paths[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue = [1]string{
	0: "paths",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressRuleValue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "paths":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Paths = make([]IoK8sAPINetworkingV1HTTPIngressPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1HTTPIngressPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Paths = append(s.Paths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1HTTPIngressRuleValue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IPBlock) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"cidr\"" + ":")
		e.Str(s.Cidr)
	}
	{
		if s.Except != nil {
			e.Comma()
		}
		if s.Except != nil {
			e.RawStr("\"except\"" + ":")
			e.ArrStart()
			if len(s.Except) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Except[0]
					e.Str(elem)
				}
				for _, elem := range s.Except[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock = [2]string{
	0: "cidr",
	1: "except",
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (s *IoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IPBlock to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cidr":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Cidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		case "except":
			if err := func() error {
				s.Except = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Except = append(s.Except, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"except\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IPBlock")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1Ingress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1Ingress = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPINetworkingV1Ingress from json.
func (s *IoK8sAPINetworkingV1Ingress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1Ingress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1Ingress")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Service.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressBackend = [2]string{
	0: "resource",
	1: "service",
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (s *IoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressBackend to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressBackend")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1IngressClass from json.
func (s *IoK8sAPINetworkingV1IngressClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClass to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClass")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassList from json.
func (s *IoK8sAPINetworkingV1IngressClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1IngressClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.Comma()
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.Comma()
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference = [5]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
	4: "scope",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassParametersReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassParametersReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Controller.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Controller.Set {
			e.RawStr("\"controller\"" + ":")
			s.Controller.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parameters.Set {
			e.RawStr("\"parameters\"" + ":")
			s.Parameters.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassSpec = [2]string{
	0: "controller",
	1: "parameters",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (s *IoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controller":
			if err := func() error {
				s.Controller.Reset()
				if err := s.Controller.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controller\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressList from json.
func (s *IoK8sAPINetworkingV1IngressList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1Ingress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1Ingress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.HTTP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTP.Set {
			e.RawStr("\"http\"" + ":")
			s.HTTP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressRule = [2]string{
	0: "host",
	1: "http",
}

// Decode decodes IoK8sAPINetworkingV1IngressRule from json.
func (s *IoK8sAPINetworkingV1IngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "http":
			if err := func() error {
				s.HTTP.Reset()
				if err := s.HTTP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"http\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressRule")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend = [2]string{
	0: "name",
	1: "port",
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressServiceBackend to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressServiceBackend")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultBackend.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBackend.Set {
			e.RawStr("\"defaultBackend\"" + ":")
			s.DefaultBackend.Encode(e)
		}
	}
	{
		if s.IngressClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IngressClassName.Set {
			e.RawStr("\"ingressClassName\"" + ":")
			s.IngressClassName.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TLS != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TLS != nil {
			e.RawStr("\"tls\"" + ":")
			e.ArrStart()
			if len(s.TLS) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TLS[0]
					elem.Encode(e)
				}
				for _, elem := range s.TLS[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressSpec = [4]string{
	0: "defaultBackend",
	1: "ingressClassName",
	2: "rules",
	3: "tls",
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (s *IoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultBackend":
			if err := func() error {
				s.DefaultBackend.Reset()
				if err := s.DefaultBackend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultBackend\"")
			}
		case "ingressClassName":
			if err := func() error {
				s.IngressClassName.Reset()
				if err := s.IngressClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingressClassName\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPINetworkingV1IngressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "tls":
			if err := func() error {
				s.TLS = make([]IoK8sAPINetworkingV1IngressTLS, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressTLS
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TLS = append(s.TLS, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LoadBalancer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancer.Set {
			e.RawStr("\"loadBalancer\"" + ":")
			s.LoadBalancer.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressStatus = [1]string{
	0: "loadBalancer",
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (s *IoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loadBalancer":
			if err := func() error {
				s.LoadBalancer.Reset()
				if err := s.LoadBalancer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressTLS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hosts != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hosts != nil {
			e.RawStr("\"hosts\"" + ":")
			e.ArrStart()
			if len(s.Hosts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hosts[0]
					e.Str(elem)
				}
				for _, elem := range s.Hosts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecretName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretName.Set {
			e.RawStr("\"secretName\"" + ":")
			s.SecretName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressTLS = [2]string{
	0: "hosts",
	1: "secretName",
}

// Decode decodes IoK8sAPINetworkingV1IngressTLS from json.
func (s *IoK8sAPINetworkingV1IngressTLS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressTLS to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "secretName":
			if err := func() error {
				s.SecretName.Reset()
				if err := s.SecretName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressTLS")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicy from json.
func (s *IoK8sAPINetworkingV1NetworkPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyEgressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.To != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.To != nil {
			e.RawStr("\"to\"" + ":")
			e.ArrStart()
			if len(s.To) >= 1 {
				// Encode first element without comma.
				{
					elem := s.To[0]
					elem.Encode(e)
				}
				for _, elem := range s.To[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyEgressRule = [2]string{
	0: "ports",
	1: "to",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyEgressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyEgressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPINetworkingV1NetworkPolicyPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "to":
			if err := func() error {
				s.To = make([]IoK8sAPINetworkingV1NetworkPolicyPeer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPeer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.To = append(s.To, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyEgressRule")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyIngressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.From != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.From != nil {
			e.RawStr("\"from\"" + ":")
			e.ArrStart()
			if len(s.From) >= 1 {
				// Encode first element without comma.
				{
					elem := s.From[0]
					elem.Encode(e)
				}
				for _, elem := range s.From[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyIngressRule = [2]string{
	0: "from",
	1: "ports",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyIngressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyIngressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From = make([]IoK8sAPINetworkingV1NetworkPolicyPeer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPeer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.From = append(s.From, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPINetworkingV1NetworkPolicyPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyIngressRule")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyList from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1NetworkPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyPeer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IpBlock.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpBlock.Set {
			e.RawStr("\"ipBlock\"" + ":")
			s.IpBlock.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.PodSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodSelector.Set {
			e.RawStr("\"podSelector\"" + ":")
			s.PodSelector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPeer = [3]string{
	0: "ipBlock",
	1: "namespaceSelector",
	2: "podSelector",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPeer from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPeer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipBlock":
			if err := func() error {
				s.IpBlock.Reset()
				if err := s.IpBlock.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipBlock\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "podSelector":
			if err := func() error {
				s.PodSelector.Reset()
				if err := s.PodSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podSelector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyPeer")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EndPort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndPort.Set {
			e.RawStr("\"endPort\"" + ":")
			s.EndPort.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPort = [3]string{
	0: "endPort",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPort from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endPort":
			if err := func() error {
				s.EndPort.Reset()
				if err := s.EndPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endPort\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyPort")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Egress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Egress != nil {
			e.RawStr("\"egress\"" + ":")
			e.ArrStart()
			if len(s.Egress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Egress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Egress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ingress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ingress != nil {
			e.RawStr("\"ingress\"" + ":")
			e.ArrStart()
			if len(s.Ingress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ingress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ingress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"podSelector\"" + ":")
		s.PodSelector.Encode(e)
	}
	{
		if s.PolicyTypes != nil {
			e.Comma()
		}
		if s.PolicyTypes != nil {
			e.RawStr("\"policyTypes\"" + ":")
			e.ArrStart()
			if len(s.PolicyTypes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PolicyTypes[0]
					e.Str(elem)
				}
				for _, elem := range s.PolicyTypes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec = [4]string{
	0: "egress",
	1: "ingress",
	2: "podSelector",
	3: "policyTypes",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "egress":
			if err := func() error {
				s.Egress = make([]IoK8sAPINetworkingV1NetworkPolicyEgressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyEgressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Egress = append(s.Egress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"egress\"")
			}
		case "ingress":
			if err := func() error {
				s.Ingress = make([]IoK8sAPINetworkingV1NetworkPolicyIngressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyIngressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ingress = append(s.Ingress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingress\"")
			}
		case "podSelector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PodSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podSelector\"")
			}
		case "policyTypes":
			if err := func() error {
				s.PolicyTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PolicyTypes = append(s.PolicyTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policyTypes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1ServiceBackendPort = [2]string{
	0: "name",
	1: "number",
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1ServiceBackendPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1ServiceBackendPort")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (s *IoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1Overhead")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1OverheadPodFixed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1OverheadPodFixed = [0]string{}

// Decode decodes IoK8sAPINodeV1OverheadPodFixed from json.
func (s IoK8sAPINodeV1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1OverheadPodFixed to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1OverheadPodFixed")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"handler\"" + ":")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1RuntimeClass from json.
func (s *IoK8sAPINodeV1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Handler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handler\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1RuntimeClassList from json.
func (s *IoK8sAPINodeV1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (s *IoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1Scheduling")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1SchedulingNodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1SchedulingNodeSelector = [0]string{}

// Decode decodes IoK8sAPINodeV1SchedulingNodeSelector from json.
func (s IoK8sAPINodeV1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1SchedulingNodeSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1SchedulingNodeSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (s *IoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1Overhead")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1OverheadPodFixed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1OverheadPodFixed = [0]string{}

// Decode decodes IoK8sAPINodeV1alpha1OverheadPodFixed from json.
func (s IoK8sAPINodeV1alpha1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1OverheadPodFixed to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1OverheadPodFixed")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClass from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassList from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1alpha1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1alpha1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClassSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Overhead.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runtimeHandler\"" + ":")
		e.Str(s.RuntimeHandler)
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec = [3]string{
	0: "overhead",
	1: "runtimeHandler",
	2: "scheduling",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassSpec from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "runtimeHandler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RuntimeHandler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeHandler\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClassSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (s *IoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1Scheduling")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1SchedulingNodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1SchedulingNodeSelector = [0]string{}

// Decode decodes IoK8sAPINodeV1alpha1SchedulingNodeSelector from json.
func (s IoK8sAPINodeV1alpha1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1SchedulingNodeSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1SchedulingNodeSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (s *IoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1Overhead")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1OverheadPodFixed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1OverheadPodFixed = [0]string{}

// Decode decodes IoK8sAPINodeV1beta1OverheadPodFixed from json.
func (s IoK8sAPINodeV1beta1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1OverheadPodFixed to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgAPIResourceQuantity
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1OverheadPodFixed")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"handler\"" + ":")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClass from json.
func (s *IoK8sAPINodeV1beta1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Handler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handler\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClassList from json.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1beta1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1beta1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (s *IoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1Scheduling")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1SchedulingNodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1SchedulingNodeSelector = [0]string{}

// Decode decodes IoK8sAPINodeV1beta1SchedulingNodeSelector from json.
func (s IoK8sAPINodeV1beta1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1SchedulingNodeSelector to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1SchedulingNodeSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudget")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1PodDisruptionBudget, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1PodDisruptionBudget
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinAvailable.Set {
			e.RawStr("\"minAvailable\"" + ":")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		case "minAvailable":
			if err := func() error {
				s.MinAvailable.Reset()
				if err := s.MinAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minAvailable\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentHealthy\"" + ":")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.Comma()

		e.RawStr("\"desiredHealthy\"" + ":")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.Comma()
		}
		if s.DisruptedPods.Set {
			e.RawStr("\"disruptedPods\"" + ":")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"disruptionsAllowed\"" + ":")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.Comma()

		e.RawStr("\"expectedPods\"" + ":")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentHealthy\"")
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredHealthy\"")
			}
		case "disruptedPods":
			if err := func() error {
				s.DisruptedPods.Reset()
				if err := s.DisruptedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptedPods\"")
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DisruptionsAllowed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptionsAllowed\"")
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ExpectedPods = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedPods\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods = [0]string{}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods from json.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgApisMetaV1Time
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedCSIDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedCSIDriver from json.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedCSIDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedCSIDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedFlexVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume = [1]string{
	0: "driver",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedFlexVolume from json.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedFlexVolume to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedFlexVolume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedHostPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PathPrefix.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PathPrefix.Set {
			e.RawStr("\"pathPrefix\"" + ":")
			s.PathPrefix.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedHostPath = [2]string{
	0: "pathPrefix",
	1: "readOnly",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedHostPath from json.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedHostPath to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pathPrefix":
			if err := func() error {
				s.PathPrefix.Reset()
				if err := s.PathPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathPrefix\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedHostPath")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rule.Set {
			e.RawStr("\"rule\"" + ":")
			s.Rule.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1FSGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1FSGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1FSGroupStrategyOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			if err := func() error {
				s.Rule.Reset()
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1FSGroupStrategyOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1HostPortRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"max\"" + ":")
		e.Int32(s.Max)
	}
	{
		e.Comma()

		e.RawStr("\"min\"" + ":")
		e.Int32(s.Min)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1HostPortRange from json.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1HostPortRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Max = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Min = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1HostPortRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1IDRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"max\"" + ":")
		e.Int64(s.Max)
	}
	{
		e.Comma()

		e.RawStr("\"min\"" + ":")
		e.Int64(s.Min)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1IDRange from json.
func (s *IoK8sAPIPolicyV1beta1IDRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1IDRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Max = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Min = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1IDRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudget")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1beta1PodDisruptionBudget, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1PodDisruptionBudget
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinAvailable.Set {
			e.RawStr("\"minAvailable\"" + ":")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		case "minAvailable":
			if err := func() error {
				s.MinAvailable.Reset()
				if err := s.MinAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minAvailable\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentHealthy\"" + ":")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.Comma()

		e.RawStr("\"desiredHealthy\"" + ":")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.Comma()
		}
		if s.DisruptedPods.Set {
			e.RawStr("\"disruptedPods\"" + ":")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"disruptionsAllowed\"" + ":")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.Comma()

		e.RawStr("\"expectedPods\"" + ":")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentHealthy\"")
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredHealthy\"")
			}
		case "disruptedPods":
			if err := func() error {
				s.DisruptedPods.Reset()
				if err := s.DisruptedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptedPods\"")
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DisruptionsAllowed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptionsAllowed\"")
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ExpectedPods = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedPods\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods = [0]string{}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods from json.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApimachineryPkgApisMetaV1Time
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicy from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicy")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicyList from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1beta1PodSecurityPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1PodSecurityPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowPrivilegeEscalation.Set {
			e.RawStr("\"allowPrivilegeEscalation\"" + ":")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.AllowedCSIDrivers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedCSIDrivers != nil {
			e.RawStr("\"allowedCSIDrivers\"" + ":")
			e.ArrStart()
			if len(s.AllowedCSIDrivers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedCSIDrivers[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedCSIDrivers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedCapabilities != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedCapabilities != nil {
			e.RawStr("\"allowedCapabilities\"" + ":")
			e.ArrStart()
			if len(s.AllowedCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedFlexVolumes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedFlexVolumes != nil {
			e.RawStr("\"allowedFlexVolumes\"" + ":")
			e.ArrStart()
			if len(s.AllowedFlexVolumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedFlexVolumes[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedFlexVolumes[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedHostPaths != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedHostPaths != nil {
			e.RawStr("\"allowedHostPaths\"" + ":")
			e.ArrStart()
			if len(s.AllowedHostPaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedHostPaths[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedHostPaths[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedProcMountTypes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedProcMountTypes != nil {
			e.RawStr("\"allowedProcMountTypes\"" + ":")
			e.ArrStart()
			if len(s.AllowedProcMountTypes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedProcMountTypes[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedProcMountTypes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedUnsafeSysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedUnsafeSysctls != nil {
			e.RawStr("\"allowedUnsafeSysctls\"" + ":")
			e.ArrStart()
			if len(s.AllowedUnsafeSysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedUnsafeSysctls[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedUnsafeSysctls[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAddCapabilities != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultAddCapabilities != nil {
			e.RawStr("\"defaultAddCapabilities\"" + ":")
			e.ArrStart()
			if len(s.DefaultAddCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.DefaultAddCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.DefaultAddCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultAllowPrivilegeEscalation.Set {
			e.RawStr("\"defaultAllowPrivilegeEscalation\"" + ":")
			s.DefaultAllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.ForbiddenSysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForbiddenSysctls != nil {
			e.RawStr("\"forbiddenSysctls\"" + ":")
			e.ArrStart()
			if len(s.ForbiddenSysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForbiddenSysctls[0]
					e.Str(elem)
				}
				for _, elem := range s.ForbiddenSysctls[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"fsGroup\"" + ":")
		s.FsGroup.Encode(e)
	}
	{
		if s.HostIPC.Set {
			e.Comma()
		}
		if s.HostIPC.Set {
			e.RawStr("\"hostIPC\"" + ":")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.Comma()
		}
		if s.HostNetwork.Set {
			e.RawStr("\"hostNetwork\"" + ":")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.Comma()
		}
		if s.HostPID.Set {
			e.RawStr("\"hostPID\"" + ":")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.HostPorts != nil {
			e.Comma()
		}
		if s.HostPorts != nil {
			e.RawStr("\"hostPorts\"" + ":")
			e.ArrStart()
			if len(s.HostPorts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HostPorts[0]
					elem.Encode(e)
				}
				for _, elem := range s.HostPorts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privileged.Set {
			e.Comma()
		}
		if s.Privileged.Set {
			e.RawStr("\"privileged\"" + ":")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.Comma()
		}
		if s.ReadOnlyRootFilesystem.Set {
			e.RawStr("\"readOnlyRootFilesystem\"" + ":")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RequiredDropCapabilities != nil {
			e.Comma()
		}
		if s.RequiredDropCapabilities != nil {
			e.RawStr("\"requiredDropCapabilities\"" + ":")
			e.ArrStart()
			if len(s.RequiredDropCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDropCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.RequiredDropCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RunAsGroup.Set {
			e.Comma()
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runAsUser\"" + ":")
		s.RunAsUser.Encode(e)
	}
	{
		if s.RuntimeClass.Set {
			e.Comma()
		}
		if s.RuntimeClass.Set {
			e.RawStr("\"runtimeClass\"" + ":")
			s.RuntimeClass.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"seLinux\"" + ":")
		s.SeLinux.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"supplementalGroups\"" + ":")
		s.SupplementalGroups.Encode(e)
	}
	{
		if s.Volumes != nil {
			e.Comma()
		}
		if s.Volumes != nil {
			e.RawStr("\"volumes\"" + ":")
			e.ArrStart()
			if len(s.Volumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Volumes[0]
					e.Str(elem)
				}
				for _, elem := range s.Volumes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec = [24]string{
	0:  "allowPrivilegeEscalation",
	1:  "allowedCSIDrivers",
	2:  "allowedCapabilities",
	3:  "allowedFlexVolumes",
	4:  "allowedHostPaths",
	5:  "allowedProcMountTypes",
	6:  "allowedUnsafeSysctls",
	7:  "defaultAddCapabilities",
	8:  "defaultAllowPrivilegeEscalation",
	9:  "forbiddenSysctls",
	10: "fsGroup",
	11: "hostIPC",
	12: "hostNetwork",
	13: "hostPID",
	14: "hostPorts",
	15: "privileged",
	16: "readOnlyRootFilesystem",
	17: "requiredDropCapabilities",
	18: "runAsGroup",
	19: "runAsUser",
	20: "runtimeClass",
	21: "seLinux",
	22: "supplementalGroups",
	23: "volumes",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "allowedCSIDrivers":
			if err := func() error {
				s.AllowedCSIDrivers = make([]IoK8sAPIPolicyV1beta1AllowedCSIDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedCSIDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedCSIDrivers = append(s.AllowedCSIDrivers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedCSIDrivers\"")
			}
		case "allowedCapabilities":
			if err := func() error {
				s.AllowedCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedCapabilities = append(s.AllowedCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedCapabilities\"")
			}
		case "allowedFlexVolumes":
			if err := func() error {
				s.AllowedFlexVolumes = make([]IoK8sAPIPolicyV1beta1AllowedFlexVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedFlexVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedFlexVolumes = append(s.AllowedFlexVolumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedFlexVolumes\"")
			}
		case "allowedHostPaths":
			if err := func() error {
				s.AllowedHostPaths = make([]IoK8sAPIPolicyV1beta1AllowedHostPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedHostPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedHostPaths = append(s.AllowedHostPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedHostPaths\"")
			}
		case "allowedProcMountTypes":
			if err := func() error {
				s.AllowedProcMountTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedProcMountTypes = append(s.AllowedProcMountTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedProcMountTypes\"")
			}
		case "allowedUnsafeSysctls":
			if err := func() error {
				s.AllowedUnsafeSysctls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUnsafeSysctls = append(s.AllowedUnsafeSysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedUnsafeSysctls\"")
			}
		case "defaultAddCapabilities":
			if err := func() error {
				s.DefaultAddCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DefaultAddCapabilities = append(s.DefaultAddCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAddCapabilities\"")
			}
		case "defaultAllowPrivilegeEscalation":
			if err := func() error {
				s.DefaultAllowPrivilegeEscalation.Reset()
				if err := s.DefaultAllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAllowPrivilegeEscalation\"")
			}
		case "forbiddenSysctls":
			if err := func() error {
				s.ForbiddenSysctls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ForbiddenSysctls = append(s.ForbiddenSysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forbiddenSysctls\"")
			}
		case "fsGroup":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.FsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroup\"")
			}
		case "hostIPC":
			if err := func() error {
				s.HostIPC.Reset()
				if err := s.HostIPC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIPC\"")
			}
		case "hostNetwork":
			if err := func() error {
				s.HostNetwork.Reset()
				if err := s.HostNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetwork\"")
			}
		case "hostPID":
			if err := func() error {
				s.HostPID.Reset()
				if err := s.HostPID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPID\"")
			}
		case "hostPorts":
			if err := func() error {
				s.HostPorts = make([]IoK8sAPIPolicyV1beta1HostPortRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1HostPortRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostPorts = append(s.HostPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPorts\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "requiredDropCapabilities":
			if err := func() error {
				s.RequiredDropCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredDropCapabilities = append(s.RequiredDropCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDropCapabilities\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsUser":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "runtimeClass":
			if err := func() error {
				s.RuntimeClass.Reset()
				if err := s.RuntimeClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClass\"")
			}
		case "seLinux":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.SeLinux.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinux\"")
			}
		case "supplementalGroups":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.SupplementalGroups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementalGroups\"")
			}
		case "volumes":
			if err := func() error {
				s.Volumes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Volumes = append(s.Volumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000100,
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"allowedRuntimeClassNames\"" + ":")
		e.ArrStart()
		if len(s.AllowedRuntimeClassNames) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AllowedRuntimeClassNames[0]
				e.Str(elem)
			}
			for _, elem := range s.AllowedRuntimeClassNames[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.DefaultRuntimeClassName.Set {
			e.Comma()
		}
		if s.DefaultRuntimeClassName.Set {
			e.RawStr("\"defaultRuntimeClassName\"" + ":")
			s.DefaultRuntimeClassName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions = [2]string{
	0: "allowedRuntimeClassNames",
	1: "defaultRuntimeClassName",
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedRuntimeClassNames":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AllowedRuntimeClassNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedRuntimeClassNames = append(s.AllowedRuntimeClassNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedRuntimeClassNames\"")
			}
		case "defaultRuntimeClassName":
			if err := func() error {
				s.DefaultRuntimeClassName.Reset()
				if err := s.DefaultRuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRuntimeClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	{
		if s.SeLinuxOptions.Set {
			e.Comma()
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions = [2]string{
	0: "rule",
	1: "seLinuxOptions",
}

// Decode decodes IoK8sAPIPolicyV1beta1SELinuxStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1SELinuxStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1SELinuxStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rule.Set {
			e.RawStr("\"rule\"" + ":")
			s.Rule.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			if err := func() error {
				s.Rule.Reset()
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1AggregationRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClusterRoleSelectors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterRoleSelectors != nil {
			e.RawStr("\"clusterRoleSelectors\"" + ":")
			e.ArrStart()
			if len(s.ClusterRoleSelectors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ClusterRoleSelectors[0]
					elem.Encode(e)
				}
				for _, elem := range s.ClusterRoleSelectors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1AggregationRule = [1]string{
	0: "clusterRoleSelectors",
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (s *IoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1AggregationRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterRoleSelectors":
			if err := func() error {
				s.ClusterRoleSelectors = make([]IoK8sApimachineryPkgApisMetaV1LabelSelector, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1LabelSelector
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClusterRoleSelectors = append(s.ClusterRoleSelectors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterRoleSelectors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1AggregationRule")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRole) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AggregationRule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AggregationRule.Set {
			e.RawStr("\"aggregationRule\"" + ":")
			s.AggregationRule.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRole = [5]string{
	0: "aggregationRule",
	1: "apiVersion",
	2: "kind",
	3: "metadata",
	4: "rules",
}

// Decode decodes IoK8sAPIRbacV1ClusterRole from json.
func (s *IoK8sAPIRbacV1ClusterRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRole to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aggregationRule":
			if err := func() error {
				s.AggregationRule.Reset()
				if err := s.AggregationRule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggregationRule\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIRbacV1PolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1PolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRole")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleBinding) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"roleRef\"" + ":")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.Comma()
		}
		if s.Subjects != nil {
			e.RawStr("\"subjects\"" + ":")
			e.ArrStart()
			if len(s.Subjects) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subjects[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subjects[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBinding from json.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBinding to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RoleRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roleRef\"")
			}
		case "subjects":
			if err := func() error {
				s.Subjects = make([]IoK8sAPIRbacV1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleBinding")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleBindingList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBindingList from json.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBindingList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1ClusterRoleBinding, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1ClusterRoleBinding
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleBindingList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleList from json.
func (s *IoK8sAPIRbacV1ClusterRoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1ClusterRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1ClusterRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1PolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroups != nil {
			e.RawStr("\"apiGroups\"" + ":")
			e.ArrStart()
			if len(s.ApiGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiGroups[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiGroups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NonResourceURLs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceURLs != nil {
			e.RawStr("\"nonResourceURLs\"" + ":")
			e.ArrStart()
			if len(s.NonResourceURLs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceURLs[0]
					e.Str(elem)
				}
				for _, elem := range s.NonResourceURLs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceNames != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceNames != nil {
			e.RawStr("\"resourceNames\"" + ":")
			e.ArrStart()
			if len(s.ResourceNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ResourceNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources != nil {
			e.RawStr("\"resources\"" + ":")
			e.ArrStart()
			if len(s.Resources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Resources[0]
					e.Str(elem)
				}
				for _, elem := range s.Resources[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule = [5]string{
	0: "apiGroups",
	1: "nonResourceURLs",
	2: "resourceNames",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIRbacV1PolicyRule from json.
func (s *IoK8sAPIRbacV1PolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1PolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "nonResourceURLs":
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "resourceNames":
			if err := func() error {
				s.ResourceNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ResourceNames = append(s.ResourceNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceNames\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1PolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1Role) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1Role = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "rules",
}

// Decode decodes IoK8sAPIRbacV1Role from json.
func (s *IoK8sAPIRbacV1Role) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1Role to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIRbacV1PolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1PolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1Role")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleBinding) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"roleRef\"" + ":")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.Comma()
		}
		if s.Subjects != nil {
			e.RawStr("\"subjects\"" + ":")
			e.ArrStart()
			if len(s.Subjects) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subjects[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subjects[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1RoleBinding from json.
func (s *IoK8sAPIRbacV1RoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleBinding to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RoleRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roleRef\"")
			}
		case "subjects":
			if err := func() error {
				s.Subjects = make([]IoK8sAPIRbacV1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleBinding")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleBindingList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleBindingList from json.
func (s *IoK8sAPIRbacV1RoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleBindingList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1RoleBinding, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1RoleBinding
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleBindingList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleList from json.
func (s *IoK8sAPIRbacV1RoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1Role, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Role
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleRef) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroup\"" + ":")
		e.Str(s.ApiGroup)
	}
	{
		e.Comma()

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleRef = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIRbacV1RoleRef from json.
func (s *IoK8sAPIRbacV1RoleRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleRef to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiGroup = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleRef")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleRef) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.Comma()
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1Subject = [4]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
}

// Decode decodes IoK8sAPIRbacV1Subject from json.
func (s *IoK8sAPIRbacV1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1Subject) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPISchedulingV1PriorityClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.GlobalDefault.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GlobalDefault.Set {
			e.RawStr("\"globalDefault\"" + ":")
			s.GlobalDefault.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreemptionPolicy.Set {
			e.RawStr("\"preemptionPolicy\"" + ":")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Int32(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass = [7]string{
	0: "apiVersion",
	1: "description",
	2: "globalDefault",
	3: "kind",
	4: "metadata",
	5: "preemptionPolicy",
	6: "value",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClass from json.
func (s *IoK8sAPISchedulingV1PriorityClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPISchedulingV1PriorityClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "globalDefault":
			if err := func() error {
				s.GlobalDefault.Reset()
				if err := s.GlobalDefault.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"globalDefault\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "preemptionPolicy":
			if err := func() error {
				s.PreemptionPolicy.Reset()
				if err := s.PreemptionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preemptionPolicy\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Value = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPISchedulingV1PriorityClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPISchedulingV1PriorityClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClassList from json.
func (s *IoK8sAPISchedulingV1PriorityClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPISchedulingV1PriorityClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPISchedulingV1PriorityClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPISchedulingV1PriorityClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPISchedulingV1PriorityClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSIDriver from json.
func (s *IoK8sAPIStorageV1CSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriverList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverList from json.
func (s *IoK8sAPIStorageV1CSIDriverList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriverList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1CSIDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSIDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriverList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriverSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AttachRequired.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AttachRequired.Set {
			e.RawStr("\"attachRequired\"" + ":")
			s.AttachRequired.Encode(e)
		}
	}
	{
		if s.FsGroupPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroupPolicy.Set {
			e.RawStr("\"fsGroupPolicy\"" + ":")
			s.FsGroupPolicy.Encode(e)
		}
	}
	{
		if s.PodInfoOnMount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodInfoOnMount.Set {
			e.RawStr("\"podInfoOnMount\"" + ":")
			s.PodInfoOnMount.Encode(e)
		}
	}
	{
		if s.RequiresRepublish.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiresRepublish.Set {
			e.RawStr("\"requiresRepublish\"" + ":")
			s.RequiresRepublish.Encode(e)
		}
	}
	{
		if s.StorageCapacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageCapacity.Set {
			e.RawStr("\"storageCapacity\"" + ":")
			s.StorageCapacity.Encode(e)
		}
	}
	{
		if s.TokenRequests != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TokenRequests != nil {
			e.RawStr("\"tokenRequests\"" + ":")
			e.ArrStart()
			if len(s.TokenRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TokenRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.TokenRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeLifecycleModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeLifecycleModes != nil {
			e.RawStr("\"volumeLifecycleModes\"" + ":")
			e.ArrStart()
			if len(s.VolumeLifecycleModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeLifecycleModes[0]
					e.Str(elem)
				}
				for _, elem := range s.VolumeLifecycleModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverSpec = [7]string{
	0: "attachRequired",
	1: "fsGroupPolicy",
	2: "podInfoOnMount",
	3: "requiresRepublish",
	4: "storageCapacity",
	5: "tokenRequests",
	6: "volumeLifecycleModes",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverSpec from json.
func (s *IoK8sAPIStorageV1CSIDriverSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriverSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachRequired":
			if err := func() error {
				s.AttachRequired.Reset()
				if err := s.AttachRequired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachRequired\"")
			}
		case "fsGroupPolicy":
			if err := func() error {
				s.FsGroupPolicy.Reset()
				if err := s.FsGroupPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroupPolicy\"")
			}
		case "podInfoOnMount":
			if err := func() error {
				s.PodInfoOnMount.Reset()
				if err := s.PodInfoOnMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podInfoOnMount\"")
			}
		case "requiresRepublish":
			if err := func() error {
				s.RequiresRepublish.Reset()
				if err := s.RequiresRepublish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiresRepublish\"")
			}
		case "storageCapacity":
			if err := func() error {
				s.StorageCapacity.Reset()
				if err := s.StorageCapacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageCapacity\"")
			}
		case "tokenRequests":
			if err := func() error {
				s.TokenRequests = make([]IoK8sAPIStorageV1TokenRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1TokenRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TokenRequests = append(s.TokenRequests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenRequests\"")
			}
		case "volumeLifecycleModes":
			if err := func() error {
				s.VolumeLifecycleModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VolumeLifecycleModes = append(s.VolumeLifecycleModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeLifecycleModes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriverSpec")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINode) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINode = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSINode from json.
func (s *IoK8sAPIStorageV1CSINode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINode) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Allocatable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Allocatable.Set {
			e.RawStr("\"allocatable\"" + ":")
			s.Allocatable.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"nodeID\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.TopologyKeys != nil {
			e.Comma()
		}
		if s.TopologyKeys != nil {
			e.RawStr("\"topologyKeys\"" + ":")
			e.ArrStart()
			if len(s.TopologyKeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TopologyKeys[0]
					e.Str(elem)
				}
				for _, elem := range s.TopologyKeys[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver = [4]string{
	0: "allocatable",
	1: "name",
	2: "nodeID",
	3: "topologyKeys",
}

// Decode decodes IoK8sAPIStorageV1CSINodeDriver from json.
func (s *IoK8sAPIStorageV1CSINodeDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocatable":
			if err := func() error {
				s.Allocatable.Reset()
				if err := s.Allocatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocatable\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodeID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeID\"")
			}
		case "topologyKeys":
			if err := func() error {
				s.TopologyKeys = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TopologyKeys = append(s.TopologyKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSINodeList from json.
func (s *IoK8sAPIStorageV1CSINodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1CSINode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSINode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"drivers\"" + ":")
		e.ArrStart()
		if len(s.Drivers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Drivers[0]
				elem.Encode(e)
			}
			for _, elem := range s.Drivers[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec = [1]string{
	0: "drivers",
}

// Decode decodes IoK8sAPIStorageV1CSINodeSpec from json.
func (s *IoK8sAPIStorageV1CSINodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drivers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Drivers = make([]IoK8sAPIStorageV1CSINodeDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSINodeDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drivers = append(s.Drivers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drivers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowVolumeExpansion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowVolumeExpansion.Set {
			e.RawStr("\"allowVolumeExpansion\"" + ":")
			s.AllowVolumeExpansion.Encode(e)
		}
	}
	{
		if s.AllowedTopologies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedTopologies != nil {
			e.RawStr("\"allowedTopologies\"" + ":")
			e.ArrStart()
			if len(s.AllowedTopologies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedTopologies[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedTopologies[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MountOptions != nil {
			e.RawStr("\"mountOptions\"" + ":")
			e.ArrStart()
			if len(s.MountOptions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MountOptions[0]
					e.Str(elem)
				}
				for _, elem := range s.MountOptions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Parameters.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parameters.Set {
			e.RawStr("\"parameters\"" + ":")
			s.Parameters.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"provisioner\"" + ":")
		e.Str(s.Provisioner)
	}
	{
		if s.ReclaimPolicy.Set {
			e.Comma()
		}
		if s.ReclaimPolicy.Set {
			e.RawStr("\"reclaimPolicy\"" + ":")
			s.ReclaimPolicy.Encode(e)
		}
	}
	{
		if s.VolumeBindingMode.Set {
			e.Comma()
		}
		if s.VolumeBindingMode.Set {
			e.RawStr("\"volumeBindingMode\"" + ":")
			s.VolumeBindingMode.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClass = [10]string{
	0: "allowVolumeExpansion",
	1: "allowedTopologies",
	2: "apiVersion",
	3: "kind",
	4: "metadata",
	5: "mountOptions",
	6: "parameters",
	7: "provisioner",
	8: "reclaimPolicy",
	9: "volumeBindingMode",
}

// Decode decodes IoK8sAPIStorageV1StorageClass from json.
func (s *IoK8sAPIStorageV1StorageClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClass to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowVolumeExpansion":
			if err := func() error {
				s.AllowVolumeExpansion.Reset()
				if err := s.AllowVolumeExpansion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowVolumeExpansion\"")
			}
		case "allowedTopologies":
			if err := func() error {
				s.AllowedTopologies = make([]IoK8sAPICoreV1TopologySelectorTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySelectorTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedTopologies = append(s.AllowedTopologies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedTopologies\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "mountOptions":
			if err := func() error {
				s.MountOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MountOptions = append(s.MountOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountOptions\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "provisioner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Provisioner = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provisioner\"")
			}
		case "reclaimPolicy":
			if err := func() error {
				s.ReclaimPolicy.Reset()
				if err := s.ReclaimPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reclaimPolicy\"")
			}
		case "volumeBindingMode":
			if err := func() error {
				s.VolumeBindingMode.Reset()
				if err := s.VolumeBindingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeBindingMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClass) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1StorageClassList from json.
func (s *IoK8sAPIStorageV1StorageClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1StorageClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1StorageClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClassParameters) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClassParameters = [0]string{}

// Decode decodes IoK8sAPIStorageV1StorageClassParameters from json.
func (s IoK8sAPIStorageV1StorageClassParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClassParameters to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClassParameters")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1TokenRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"audience\"" + ":")
		e.Str(s.Audience)
	}
	{
		if s.ExpirationSeconds.Set {
			e.Comma()
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest = [2]string{
	0: "audience",
	1: "expirationSeconds",
}

// Decode decodes IoK8sAPIStorageV1TokenRequest from json.
func (s *IoK8sAPIStorageV1TokenRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1TokenRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Audience = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audience\"")
			}
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1TokenRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachment from json.
func (s *IoK8sAPIStorageV1VolumeAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentList from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1VolumeAttachment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1VolumeAttachment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.InlineVolumeSpec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineVolumeSpec.Set {
			e.RawStr("\"inlineVolumeSpec\"" + ":")
			s.InlineVolumeSpec.Encode(e)
		}
	}
	{
		if s.PersistentVolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PersistentVolumeName.Set {
			e.RawStr("\"persistentVolumeName\"" + ":")
			s.PersistentVolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSource = [2]string{
	0: "inlineVolumeSpec",
	1: "persistentVolumeName",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSource from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inlineVolumeSpec":
			if err := func() error {
				s.InlineVolumeSpec.Reset()
				if err := s.InlineVolumeSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inlineVolumeSpec\"")
			}
		case "persistentVolumeName":
			if err := func() error {
				s.PersistentVolumeName.Reset()
				if err := s.PersistentVolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentSource")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"attacher\"" + ":")
		e.Str(s.Attacher)
	}
	{
		e.Comma()

		e.RawStr("\"nodeName\"" + ":")
		e.Str(s.NodeName)
	}
	{
		e.Comma()

		e.RawStr("\"source\"" + ":")
		s.Source.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec = [3]string{
	0: "attacher",
	1: "nodeName",
	2: "source",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSpec from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacher":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Attacher = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacher\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AttachError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AttachError.Set {
			e.RawStr("\"attachError\"" + ":")
			s.AttachError.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"attached\"" + ":")
		e.Bool(s.Attached)
	}
	{
		if s.AttachmentMetadata.Set {
			e.Comma()
		}
		if s.AttachmentMetadata.Set {
			e.RawStr("\"attachmentMetadata\"" + ":")
			s.AttachmentMetadata.Encode(e)
		}
	}
	{
		if s.DetachError.Set {
			e.Comma()
		}
		if s.DetachError.Set {
			e.RawStr("\"detachError\"" + ":")
			s.DetachError.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus = [4]string{
	0: "attachError",
	1: "attached",
	2: "attachmentMetadata",
	3: "detachError",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachError":
			if err := func() error {
				s.AttachError.Reset()
				if err := s.AttachError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachError\"")
			}
		case "attached":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Attached = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attached\"")
			}
		case "attachmentMetadata":
			if err := func() error {
				s.AttachmentMetadata.Reset()
				if err := s.AttachmentMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachmentMetadata\"")
			}
		case "detachError":
			if err := func() error {
				s.DetachError.Reset()
				if err := s.DetachError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detachError\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata = [0]string{}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata from json.
func (s IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Time.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Time.Set {
			e.RawStr("\"time\"" + ":")
			s.Time.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeError = [2]string{
	0: "message",
	1: "time",
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (s *IoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeError")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeNodeResources = [1]string{
	0: "count",
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (s *IoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeNodeResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeNodeResources")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1alpha1CSIStorageCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaximumVolumeSize.Set {
			e.RawStr("\"maximumVolumeSize\"" + ":")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeTopology.Set {
			e.RawStr("\"nodeTopology\"" + ":")
			s.NodeTopology.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"storageClassName\"" + ":")
		e.Str(s.StorageClassName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "maximumVolumeSize":
			if err := func() error {
				s.MaximumVolumeSize.Reset()
				if err := s.MaximumVolumeSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximumVolumeSize\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "nodeTopology":
			if err := func() error {
				s.NodeTopology.Reset()
				if err := s.NodeTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeTopology\"")
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StorageClassName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1alpha1CSIStorageCapacity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacityList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1alpha1CSIStorageCapacity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1alpha1CSIStorageCapacity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1alpha1CSIStorageCapacityList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1beta1CSIStorageCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaximumVolumeSize.Set {
			e.RawStr("\"maximumVolumeSize\"" + ":")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeTopology.Set {
			e.RawStr("\"nodeTopology\"" + ":")
			s.NodeTopology.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"storageClassName\"" + ":")
		e.Str(s.StorageClassName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "maximumVolumeSize":
			if err := func() error {
				s.MaximumVolumeSize.Reset()
				if err := s.MaximumVolumeSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximumVolumeSize\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "nodeTopology":
			if err := func() error {
				s.NodeTopology.Reset()
				if err := s.NodeTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeTopology\"")
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StorageClassName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1beta1CSIStorageCapacity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1beta1CSIStorageCapacityList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacityList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1beta1CSIStorageCapacity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1beta1CSIStorageCapacity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1beta1CSIStorageCapacityList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Format.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Format.Set {
			e.RawStr("\"format\"" + ":")
			s.Format.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jsonPath\"" + ":")
		e.Str(s.JsonPath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Priority.Set {
			e.Comma()
		}
		if s.Priority.Set {
			e.RawStr("\"priority\"" + ":")
			s.Priority.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition = [6]string{
	0: "description",
	1: "format",
	2: "jsonPath",
	3: "name",
	4: "priority",
	5: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "jsonPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.JsonPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jsonPath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"strategy\"" + ":")
		e.Str(s.Strategy)
	}
	{
		if s.Webhook.Set {
			e.Comma()
		}
		if s.Webhook.Set {
			e.RawStr("\"webhook\"" + ":")
			s.Webhook.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion = [2]string{
	0: "strategy",
	1: "webhook",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strategy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Strategy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "webhook":
			if err := func() error {
				s.Webhook.Reset()
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Categories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Str(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ListKind.Set {
			e.Comma()
		}
		if s.ListKind.Set {
			e.RawStr("\"listKind\"" + ":")
			s.ListKind.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"plural\"" + ":")
		e.Str(s.Plural)
	}
	{
		if s.ShortNames != nil {
			e.Comma()
		}
		if s.ShortNames != nil {
			e.RawStr("\"shortNames\"" + ":")
			e.ArrStart()
			if len(s.ShortNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ShortNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ShortNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Singular.Set {
			e.Comma()
		}
		if s.Singular.Set {
			e.RawStr("\"singular\"" + ":")
			s.Singular.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames = [6]string{
	0: "categories",
	1: "kind",
	2: "listKind",
	3: "plural",
	4: "shortNames",
	5: "singular",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "listKind":
			if err := func() error {
				s.ListKind.Reset()
				if err := s.ListKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"listKind\"")
			}
		case "plural":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Plural = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plural\"")
			}
		case "shortNames":
			if err := func() error {
				s.ShortNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ShortNames = append(s.ShortNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortNames\"")
			}
		case "singular":
			if err := func() error {
				s.Singular.Reset()
				if err := s.Singular.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"singular\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conversion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conversion.Set {
			e.RawStr("\"conversion\"" + ":")
			s.Conversion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group\"" + ":")
		e.Str(s.Group)
	}
	{
		e.Comma()

		e.RawStr("\"names\"" + ":")
		s.Names.Encode(e)
	}
	{
		if s.PreserveUnknownFields.Set {
			e.Comma()
		}
		if s.PreserveUnknownFields.Set {
			e.RawStr("\"preserveUnknownFields\"" + ":")
			s.PreserveUnknownFields.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scope\"" + ":")
		e.Str(s.Scope)
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec = [6]string{
	0: "conversion",
	1: "group",
	2: "names",
	3: "preserveUnknownFields",
	4: "scope",
	5: "versions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversion":
			if err := func() error {
				s.Conversion.Reset()
				if err := s.Conversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversion\"")
			}
		case "group":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Group = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "names":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Names.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "preserveUnknownFields":
			if err := func() error {
				s.PreserveUnknownFields.Reset()
				if err := s.PreserveUnknownFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preserveUnknownFields\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Scope = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Versions = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AcceptedNames.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AcceptedNames.Set {
			e.RawStr("\"acceptedNames\"" + ":")
			s.AcceptedNames.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StoredVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoredVersions != nil {
			e.RawStr("\"storedVersions\"" + ":")
			e.ArrStart()
			if len(s.StoredVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StoredVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.StoredVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus = [3]string{
	0: "acceptedNames",
	1: "conditions",
	2: "storedVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acceptedNames":
			if err := func() error {
				s.AcceptedNames.Reset()
				if err := s.AcceptedNames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptedNames\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "storedVersions":
			if err := func() error {
				s.StoredVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StoredVersions = append(s.StoredVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storedVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdditionalPrinterColumns != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalPrinterColumns != nil {
			e.RawStr("\"additionalPrinterColumns\"" + ":")
			e.ArrStart()
			if len(s.AdditionalPrinterColumns) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AdditionalPrinterColumns[0]
					elem.Encode(e)
				}
				for _, elem := range s.AdditionalPrinterColumns[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Deprecated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deprecated.Set {
			e.RawStr("\"deprecated\"" + ":")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.DeprecationWarning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecationWarning.Set {
			e.RawStr("\"deprecationWarning\"" + ":")
			s.DeprecationWarning.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Schema.Set {
			e.Comma()
		}
		if s.Schema.Set {
			e.RawStr("\"schema\"" + ":")
			s.Schema.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"served\"" + ":")
		e.Bool(s.Served)
	}
	{
		e.Comma()

		e.RawStr("\"storage\"" + ":")
		e.Bool(s.Storage)
	}
	{
		if s.Subresources.Set {
			e.Comma()
		}
		if s.Subresources.Set {
			e.RawStr("\"subresources\"" + ":")
			s.Subresources.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion = [8]string{
	0: "additionalPrinterColumns",
	1: "deprecated",
	2: "deprecationWarning",
	3: "name",
	4: "schema",
	5: "served",
	6: "storage",
	7: "subresources",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additionalPrinterColumns":
			if err := func() error {
				s.AdditionalPrinterColumns = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AdditionalPrinterColumns = append(s.AdditionalPrinterColumns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalPrinterColumns\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "deprecationWarning":
			if err := func() error {
				s.DeprecationWarning.Reset()
				if err := s.DeprecationWarning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecationWarning\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "served":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Served = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"served\"")
			}
		case "storage":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Storage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storage\"")
			}
		case "subresources":
			if err := func() error {
				s.Subresources.Reset()
				if err := s.Subresources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelectorPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelectorPath.Set {
			e.RawStr("\"labelSelectorPath\"" + ":")
			s.LabelSelectorPath.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"specReplicasPath\"" + ":")
		e.Str(s.SpecReplicasPath)
	}
	{
		e.Comma()

		e.RawStr("\"statusReplicasPath\"" + ":")
		e.Str(s.StatusReplicasPath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale = [3]string{
	0: "labelSelectorPath",
	1: "specReplicasPath",
	2: "statusReplicasPath",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelectorPath":
			if err := func() error {
				s.LabelSelectorPath.Reset()
				if err := s.LabelSelectorPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelectorPath\"")
			}
		case "specReplicasPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SpecReplicasPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specReplicasPath\"")
			}
		case "statusReplicasPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StatusReplicasPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusReplicasPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scale.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scale.Set {
			e.RawStr("\"scale\"" + ":")
			s.Scale.Encode(e)
		}
	}
	{
		if s.Status != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status != nil {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources = [2]string{
	0: "scale",
	1: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scale":
			if err := func() error {
				s.Scale.Reset()
				if err := s.Scale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scale\"")
			}
		case "status":
			if err := func() error {
				s.Status = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Status = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.OpenAPIV3Schema.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenAPIV3Schema.Set {
			e.RawStr("\"openAPIV3Schema\"" + ":")
			s.OpenAPIV3Schema.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation = [1]string{
	0: "openAPIV3Schema",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openAPIV3Schema":
			if err := func() error {
				s.OpenAPIV3Schema.Reset()
				if err := s.OpenAPIV3Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openAPIV3Schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation = [2]string{
	0: "description",
	1: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schema.Set {
			e.RawStr("\"$schema\"" + ":")
			s.Schema.Encode(e)
		}
	}
	{
		if s.AdditionalItems != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalItems != nil {
			e.RawStr("\"additionalItems\"" + ":")
			s.AdditionalItems.Encode(e)
		}
	}
	{
		if s.AdditionalProperties != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalProperties != nil {
			e.RawStr("\"additionalProperties\"" + ":")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.AllOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllOf != nil {
			e.RawStr("\"allOf\"" + ":")
			e.ArrStart()
			if len(s.AllOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnyOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnyOf != nil {
			e.RawStr("\"anyOf\"" + ":")
			e.ArrStart()
			if len(s.AnyOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AnyOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.AnyOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Default != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default != nil {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.Definitions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Definitions.Set {
			e.RawStr("\"definitions\"" + ":")
			s.Definitions.Encode(e)
		}
	}
	{
		if s.Dependencies.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Dependencies.Set {
			e.RawStr("\"dependencies\"" + ":")
			s.Dependencies.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Enum != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enum != nil {
			e.RawStr("\"enum\"" + ":")
			e.ArrStart()
			if len(s.Enum) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Enum[0]
					elem.Encode(e)
				}
				for _, elem := range s.Enum[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Example != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Example != nil {
			e.RawStr("\"example\"" + ":")
			s.Example.Encode(e)
		}
	}
	{
		if s.ExclusiveMaximum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExclusiveMaximum.Set {
			e.RawStr("\"exclusiveMaximum\"" + ":")
			s.ExclusiveMaximum.Encode(e)
		}
	}
	{
		if s.ExclusiveMinimum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExclusiveMinimum.Set {
			e.RawStr("\"exclusiveMinimum\"" + ":")
			s.ExclusiveMinimum.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalDocs.Set {
			e.RawStr("\"externalDocs\"" + ":")
			s.ExternalDocs.Encode(e)
		}
	}
	{
		if s.Format.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Format.Set {
			e.RawStr("\"format\"" + ":")
			s.Format.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			s.Items.Encode(e)
		}
	}
	{
		if s.MaxItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxItems.Set {
			e.RawStr("\"maxItems\"" + ":")
			s.MaxItems.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxLength.Set {
			e.RawStr("\"maxLength\"" + ":")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.MaxProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxProperties.Set {
			e.RawStr("\"maxProperties\"" + ":")
			s.MaxProperties.Encode(e)
		}
	}
	{
		if s.Maximum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maximum.Set {
			e.RawStr("\"maximum\"" + ":")
			s.Maximum.Encode(e)
		}
	}
	{
		if s.MinItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinItems.Set {
			e.RawStr("\"minItems\"" + ":")
			s.MinItems.Encode(e)
		}
	}
	{
		if s.MinLength.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinLength.Set {
			e.RawStr("\"minLength\"" + ":")
			s.MinLength.Encode(e)
		}
	}
	{
		if s.MinProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinProperties.Set {
			e.RawStr("\"minProperties\"" + ":")
			s.MinProperties.Encode(e)
		}
	}
	{
		if s.Minimum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Minimum.Set {
			e.RawStr("\"minimum\"" + ":")
			s.Minimum.Encode(e)
		}
	}
	{
		if s.MultipleOf.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MultipleOf.Set {
			e.RawStr("\"multipleOf\"" + ":")
			s.MultipleOf.Encode(e)
		}
	}
	{
		if s.Not != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Not != nil {
			e.RawStr("\"not\"" + ":")
			s.Not.Encode(e)
		}
	}
	{
		if s.Nullable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nullable.Set {
			e.RawStr("\"nullable\"" + ":")
			s.Nullable.Encode(e)
		}
	}
	{
		if s.OneOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OneOf != nil {
			e.RawStr("\"oneOf\"" + ":")
			e.ArrStart()
			if len(s.OneOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.OneOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.OneOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pattern.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pattern.Set {
			e.RawStr("\"pattern\"" + ":")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.PatternProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PatternProperties.Set {
			e.RawStr("\"patternProperties\"" + ":")
			s.PatternProperties.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Properties.Set {
			e.RawStr("\"properties\"" + ":")
			s.Properties.Encode(e)
		}
	}
	{
		if s.Required != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Required != nil {
			e.RawStr("\"required\"" + ":")
			e.ArrStart()
			if len(s.Required) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Required[0]
					e.Str(elem)
				}
				for _, elem := range s.Required[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.UniqueItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UniqueItems.Set {
			e.RawStr("\"uniqueItems\"" + ":")
			s.UniqueItems.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusEmbeddedMinusResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusEmbeddedMinusResource.Set {
			e.RawStr("\"x-kubernetes-embedded-resource\"" + ":")
			s.XMinusKubernetesMinusEmbeddedMinusResource.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusIntMinusOrMinusString.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusIntMinusOrMinusString.Set {
			e.RawStr("\"x-kubernetes-int-or-string\"" + ":")
			s.XMinusKubernetesMinusIntMinusOrMinusString.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusMapMinusKeys != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusListMinusMapMinusKeys != nil {
			e.RawStr("\"x-kubernetes-list-map-keys\"" + ":")
			e.ArrStart()
			if len(s.XMinusKubernetesMinusListMinusMapMinusKeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.XMinusKubernetesMinusListMinusMapMinusKeys[0]
					e.Str(elem)
				}
				for _, elem := range s.XMinusKubernetesMinusListMinusMapMinusKeys[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusListMinusType.Set {
			e.RawStr("\"x-kubernetes-list-type\"" + ":")
			s.XMinusKubernetesMinusListMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusMapMinusType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusMapMinusType.Set {
			e.RawStr("\"x-kubernetes-map-type\"" + ":")
			s.XMinusKubernetesMinusMapMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Set {
			e.RawStr("\"x-kubernetes-preserve-unknown-fields\"" + ":")
			s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps = [43]string{
	0:  "$ref",
	1:  "$schema",
	2:  "additionalItems",
	3:  "additionalProperties",
	4:  "allOf",
	5:  "anyOf",
	6:  "default",
	7:  "definitions",
	8:  "dependencies",
	9:  "description",
	10: "enum",
	11: "example",
	12: "exclusiveMaximum",
	13: "exclusiveMinimum",
	14: "externalDocs",
	15: "format",
	16: "id",
	17: "items",
	18: "maxItems",
	19: "maxLength",
	20: "maxProperties",
	21: "maximum",
	22: "minItems",
	23: "minLength",
	24: "minProperties",
	25: "minimum",
	26: "multipleOf",
	27: "not",
	28: "nullable",
	29: "oneOf",
	30: "pattern",
	31: "patternProperties",
	32: "properties",
	33: "required",
	34: "title",
	35: "type",
	36: "uniqueItems",
	37: "x-kubernetes-embedded-resource",
	38: "x-kubernetes-int-or-string",
	39: "x-kubernetes-list-map-keys",
	40: "x-kubernetes-list-type",
	41: "x-kubernetes-map-type",
	42: "x-kubernetes-preserve-unknown-fields",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "$schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$schema\"")
			}
		case "additionalItems":
			if err := func() error {
				s.AdditionalItems = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalItems = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalItems\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalProperties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "allOf":
			if err := func() error {
				s.AllOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllOf = append(s.AllOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allOf\"")
			}
		case "anyOf":
			if err := func() error {
				s.AnyOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnyOf = append(s.AnyOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anyOf\"")
			}
		case "default":
			if err := func() error {
				s.Default = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Default = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "definitions":
			if err := func() error {
				s.Definitions.Reset()
				if err := s.Definitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"definitions\"")
			}
		case "dependencies":
			if err := func() error {
				s.Dependencies.Reset()
				if err := s.Dependencies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependencies\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enum":
			if err := func() error {
				s.Enum = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Enum = append(s.Enum, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "example":
			if err := func() error {
				s.Example = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Example = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "exclusiveMaximum":
			if err := func() error {
				s.ExclusiveMaximum.Reset()
				if err := s.ExclusiveMaximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMaximum\"")
			}
		case "exclusiveMinimum":
			if err := func() error {
				s.ExclusiveMinimum.Reset()
				if err := s.ExclusiveMinimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMinimum\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "items":
			if err := func() error {
				s.Items = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "maxItems":
			if err := func() error {
				s.MaxItems.Reset()
				if err := s.MaxItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxItems\"")
			}
		case "maxLength":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLength\"")
			}
		case "maxProperties":
			if err := func() error {
				s.MaxProperties.Reset()
				if err := s.MaxProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxProperties\"")
			}
		case "maximum":
			if err := func() error {
				s.Maximum.Reset()
				if err := s.Maximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum\"")
			}
		case "minItems":
			if err := func() error {
				s.MinItems.Reset()
				if err := s.MinItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minItems\"")
			}
		case "minLength":
			if err := func() error {
				s.MinLength.Reset()
				if err := s.MinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minLength\"")
			}
		case "minProperties":
			if err := func() error {
				s.MinProperties.Reset()
				if err := s.MinProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minProperties\"")
			}
		case "minimum":
			if err := func() error {
				s.Minimum.Reset()
				if err := s.Minimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum\"")
			}
		case "multipleOf":
			if err := func() error {
				s.MultipleOf.Reset()
				if err := s.MultipleOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multipleOf\"")
			}
		case "not":
			if err := func() error {
				s.Not = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Not = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"not\"")
			}
		case "nullable":
			if err := func() error {
				s.Nullable.Reset()
				if err := s.Nullable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nullable\"")
			}
		case "oneOf":
			if err := func() error {
				s.OneOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OneOf = append(s.OneOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneOf\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "patternProperties":
			if err := func() error {
				s.PatternProperties.Reset()
				if err := s.PatternProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patternProperties\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "required":
			if err := func() error {
				s.Required = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Required = append(s.Required, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "uniqueItems":
			if err := func() error {
				s.UniqueItems.Reset()
				if err := s.UniqueItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueItems\"")
			}
		case "x-kubernetes-embedded-resource":
			if err := func() error {
				s.XMinusKubernetesMinusEmbeddedMinusResource.Reset()
				if err := s.XMinusKubernetesMinusEmbeddedMinusResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-embedded-resource\"")
			}
		case "x-kubernetes-int-or-string":
			if err := func() error {
				s.XMinusKubernetesMinusIntMinusOrMinusString.Reset()
				if err := s.XMinusKubernetesMinusIntMinusOrMinusString.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-int-or-string\"")
			}
		case "x-kubernetes-list-map-keys":
			if err := func() error {
				s.XMinusKubernetesMinusListMinusMapMinusKeys = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.XMinusKubernetesMinusListMinusMapMinusKeys = append(s.XMinusKubernetesMinusListMinusMapMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-list-map-keys\"")
			}
		case "x-kubernetes-list-type":
			if err := func() error {
				s.XMinusKubernetesMinusListMinusType.Reset()
				if err := s.XMinusKubernetesMinusListMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-list-type\"")
			}
		case "x-kubernetes-map-type":
			if err := func() error {
				s.XMinusKubernetesMinusMapMinusType.Reset()
				if err := s.XMinusKubernetesMinusMapMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-map-type\"")
			}
		case "x-kubernetes-preserve-unknown-fields":
			if err := func() error {
				s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Reset()
				if err := s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-preserve-unknown-fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions from json.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies from json.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties from json.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties from json.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClientConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientConfig.Set {
			e.RawStr("\"clientConfig\"" + ":")
			s.ClientConfig.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conversionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.ConversionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ConversionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.ConversionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion = [2]string{
	0: "clientConfig",
	1: "conversionReviewVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientConfig":
			if err := func() error {
				s.ClientConfig.Reset()
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "conversionReviewVersions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ConversionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ConversionReviewVersions = append(s.ConversionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversionReviewVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (s IoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (s *IoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgAPIResourceQuantity to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIGroup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.PreferredVersion.Set {
			e.Comma()
		}
		if s.PreferredVersion.Set {
			e.RawStr("\"preferredVersion\"" + ":")
			s.PreferredVersion.Encode(e)
		}
	}
	{
		if s.ServerAddressByClientCIDRs != nil {
			e.Comma()
		}
		if s.ServerAddressByClientCIDRs != nil {
			e.RawStr("\"serverAddressByClientCIDRs\"" + ":")
			e.ArrStart()
			if len(s.ServerAddressByClientCIDRs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ServerAddressByClientCIDRs[0]
					elem.Encode(e)
				}
				for _, elem := range s.ServerAddressByClientCIDRs[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup = [6]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
	3: "preferredVersion",
	4: "serverAddressByClientCIDRs",
	5: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroup from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "preferredVersion":
			if err := func() error {
				s.PreferredVersion.Reset()
				if err := s.PreferredVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredVersion\"")
			}
		case "serverAddressByClientCIDRs":
			if err := func() error {
				s.ServerAddressByClientCIDRs = make([]IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddressByClientCIDRs\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Versions = make([]IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIGroupList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groups\"" + ":")
		e.ArrStart()
		if len(s.Groups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Groups[0]
				elem.Encode(e)
			}
			for _, elem := range s.Groups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList = [3]string{
	0: "apiVersion",
	1: "groups",
	2: "kind",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroupList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroupList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Groups = make([]IoK8sApimachineryPkgApisMetaV1APIGroup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1APIGroup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIGroupList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIResource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Categories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Str(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespaced\"" + ":")
		e.Bool(s.Namespaced)
	}
	{
		if s.ShortNames != nil {
			e.Comma()
		}
		if s.ShortNames != nil {
			e.RawStr("\"shortNames\"" + ":")
			e.ArrStart()
			if len(s.ShortNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ShortNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ShortNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"singularName\"" + ":")
		e.Str(s.SingularName)
	}
	{
		if s.StorageVersionHash.Set {
			e.Comma()
		}
		if s.StorageVersionHash.Set {
			e.RawStr("\"storageVersionHash\"" + ":")
			s.StorageVersionHash.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Version.Set {
			e.Comma()
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource = [10]string{
	0: "categories",
	1: "group",
	2: "kind",
	3: "name",
	4: "namespaced",
	5: "shortNames",
	6: "singularName",
	7: "storageVersionHash",
	8: "verbs",
	9: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResource from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaced":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Namespaced = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaced\"")
			}
		case "shortNames":
			if err := func() error {
				s.ShortNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ShortNames = append(s.ShortNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortNames\"")
			}
		case "singularName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.SingularName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"singularName\"")
			}
		case "storageVersionHash":
			if err := func() error {
				s.StorageVersionHash.Reset()
				if err := s.StorageVersionHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageVersionHash\"")
			}
		case "verbs":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIResourceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groupVersion\"" + ":")
		e.Str(s.GroupVersion)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList = [4]string{
	0: "apiVersion",
	1: "groupVersion",
	2: "kind",
	3: "resources",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResourceList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResourceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "groupVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]IoK8sApimachineryPkgApisMetaV1APIResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1APIResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIResourceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIVersions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"serverAddressByClientCIDRs\"" + ":")
		e.ArrStart()
		if len(s.ServerAddressByClientCIDRs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ServerAddressByClientCIDRs[0]
				elem.Encode(e)
			}
			for _, elem := range s.ServerAddressByClientCIDRs[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				e.Str(elem)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "serverAddressByClientCIDRs",
	3: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIVersions from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIVersions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serverAddressByClientCIDRs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ServerAddressByClientCIDRs = make([]IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddressByClientCIDRs\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Versions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIVersions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1Condition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lastTransitionTime\"" + ":")
		s.LastTransitionTime.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Condition from json.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Condition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1Condition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1FieldsV1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1FieldsV1 = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1FieldsV1 from json.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1FieldsV1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1FieldsV1")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groupVersion\"" + ":")
		e.Str(s.GroupVersion)
	}
	{
		e.Comma()

		e.RawStr("\"version\"" + ":")
		e.Str(s.Version)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery = [2]string{
	0: "groupVersion",
	1: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groupVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupVersion\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchLabels.Set {
			e.RawStr("\"matchLabels\"" + ":")
			s.MatchLabels.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelector")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels from json.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Continue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Continue.Set {
			e.RawStr("\"continue\"" + ":")
			s.Continue.Encode(e)
		}
	}
	{
		if s.RemainingItemCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemainingItemCount.Set {
			e.RawStr("\"remainingItemCount\"" + ":")
			s.RemainingItemCount.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelfLink.Set {
			e.RawStr("\"selfLink\"" + ":")
			s.SelfLink.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ListMeta = [4]string{
	0: "continue",
	1: "remainingItemCount",
	2: "resourceVersion",
	3: "selfLink",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ListMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continue":
			if err := func() error {
				s.Continue.Reset()
				if err := s.Continue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continue\"")
			}
		case "remainingItemCount":
			if err := func() error {
				s.RemainingItemCount.Reset()
				if err := s.RemainingItemCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remainingItemCount\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "selfLink":
			if err := func() error {
				s.SelfLink.Reset()
				if err := s.SelfLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ListMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldsType.Set {
			e.RawStr("\"fieldsType\"" + ":")
			s.FieldsType.Encode(e)
		}
	}
	{
		if s.FieldsV1 != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldsV1 != nil {
			e.RawStr("\"fieldsV1\"" + ":")
			s.FieldsV1.Encode(e)
		}
	}
	{
		if s.Manager.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Manager.Set {
			e.RawStr("\"manager\"" + ":")
			s.Manager.Encode(e)
		}
	}
	{
		if s.Operation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operation.Set {
			e.RawStr("\"operation\"" + ":")
			s.Operation.Encode(e)
		}
	}
	{
		if s.Subresource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subresource.Set {
			e.RawStr("\"subresource\"" + ":")
			s.Subresource.Encode(e)
		}
	}
	{
		if s.Time.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Time.Set {
			e.RawStr("\"time\"" + ":")
			s.Time.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry = [7]string{
	0: "apiVersion",
	1: "fieldsType",
	2: "fieldsV1",
	3: "manager",
	4: "operation",
	5: "subresource",
	6: "time",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry from json.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldsType":
			if err := func() error {
				s.FieldsType.Reset()
				if err := s.FieldsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldsType\"")
			}
		case "fieldsV1":
			if err := func() error {
				s.FieldsV1 = nil
				var elem IoK8sApimachineryPkgApisMetaV1FieldsV1
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FieldsV1 = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldsV1\"")
			}
		case "manager":
			if err := func() error {
				s.Manager.Reset()
				if err := s.Manager.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manager\"")
			}
		case "operation":
			if err := func() error {
				s.Operation.Reset()
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "subresource":
			if err := func() error {
				s.Subresource.Reset()
				if err := s.Subresource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry")
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (s IoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (s *IoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1MicroTime to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Annotations.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Annotations.Set {
			e.RawStr("\"annotations\"" + ":")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterName.Set {
			e.RawStr("\"clusterName\"" + ":")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreationTimestamp.Set {
			e.RawStr("\"creationTimestamp\"" + ":")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.DeletionGracePeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeletionGracePeriodSeconds.Set {
			e.RawStr("\"deletionGracePeriodSeconds\"" + ":")
			s.DeletionGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.DeletionTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeletionTimestamp.Set {
			e.RawStr("\"deletionTimestamp\"" + ":")
			s.DeletionTimestamp.Encode(e)
		}
	}
	{
		if s.Finalizers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Finalizers != nil {
			e.RawStr("\"finalizers\"" + ":")
			e.ArrStart()
			if len(s.Finalizers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Finalizers[0]
					e.Str(elem)
				}
				for _, elem := range s.Finalizers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.GenerateName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GenerateName.Set {
			e.RawStr("\"generateName\"" + ":")
			s.GenerateName.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Generation.Set {
			e.RawStr("\"generation\"" + ":")
			s.Generation.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Labels.Set {
			e.RawStr("\"labels\"" + ":")
			s.Labels.Encode(e)
		}
	}
	{
		if s.ManagedFields != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ManagedFields != nil {
			e.RawStr("\"managedFields\"" + ":")
			e.ArrStart()
			if len(s.ManagedFields) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ManagedFields[0]
					elem.Encode(e)
				}
				for _, elem := range s.ManagedFields[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.OwnerReferences != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OwnerReferences != nil {
			e.RawStr("\"ownerReferences\"" + ":")
			e.ArrStart()
			if len(s.OwnerReferences) >= 1 {
				// Encode first element without comma.
				{
					elem := s.OwnerReferences[0]
					elem.Encode(e)
				}
				for _, elem := range s.OwnerReferences[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelfLink.Set {
			e.RawStr("\"selfLink\"" + ":")
			s.SelfLink.Encode(e)
		}
	}
	{
		if s.UID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ObjectMeta = [16]string{
	0:  "annotations",
	1:  "clusterName",
	2:  "creationTimestamp",
	3:  "deletionGracePeriodSeconds",
	4:  "deletionTimestamp",
	5:  "finalizers",
	6:  "generateName",
	7:  "generation",
	8:  "labels",
	9:  "managedFields",
	10: "name",
	11: "namespace",
	12: "ownerReferences",
	13: "resourceVersion",
	14: "selfLink",
	15: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "clusterName":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "deletionGracePeriodSeconds":
			if err := func() error {
				s.DeletionGracePeriodSeconds.Reset()
				if err := s.DeletionGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletionGracePeriodSeconds\"")
			}
		case "deletionTimestamp":
			if err := func() error {
				s.DeletionTimestamp.Reset()
				if err := s.DeletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletionTimestamp\"")
			}
		case "finalizers":
			if err := func() error {
				s.Finalizers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Finalizers = append(s.Finalizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalizers\"")
			}
		case "generateName":
			if err := func() error {
				s.GenerateName.Reset()
				if err := s.GenerateName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateName\"")
			}
		case "generation":
			if err := func() error {
				s.Generation.Reset()
				if err := s.Generation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generation\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "managedFields":
			if err := func() error {
				s.ManagedFields = make([]IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ManagedFields = append(s.ManagedFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managedFields\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "ownerReferences":
			if err := func() error {
				s.OwnerReferences = make([]IoK8sApimachineryPkgApisMetaV1OwnerReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1OwnerReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OwnerReferences = append(s.OwnerReferences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerReferences\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "selfLink":
			if err := func() error {
				s.SelfLink.Reset()
				if err := s.SelfLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfLink\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations from json.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels from json.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1OwnerReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiVersion\"" + ":")
		e.Str(s.ApiVersion)
	}
	{
		if s.BlockOwnerDeletion.Set {
			e.Comma()
		}
		if s.BlockOwnerDeletion.Set {
			e.RawStr("\"blockOwnerDeletion\"" + ":")
			s.BlockOwnerDeletion.Encode(e)
		}
	}
	{
		if s.Controller.Set {
			e.Comma()
		}
		if s.Controller.Set {
			e.RawStr("\"controller\"" + ":")
			s.Controller.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uid\"" + ":")
		e.Str(s.UID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference = [6]string{
	0: "apiVersion",
	1: "blockOwnerDeletion",
	2: "controller",
	3: "kind",
	4: "name",
	5: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1OwnerReference from json.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1OwnerReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "blockOwnerDeletion":
			if err := func() error {
				s.BlockOwnerDeletion.Reset()
				if err := s.BlockOwnerDeletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockOwnerDeletion\"")
			}
		case "controller":
			if err := func() error {
				s.Controller.Reset()
				if err := s.Controller.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controller\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1OwnerReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"clientCIDR\"" + ":")
		e.Str(s.ClientCIDR)
	}
	{
		e.Comma()

		e.RawStr("\"serverAddress\"" + ":")
		e.Str(s.ServerAddress)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR = [2]string{
	0: "clientCIDR",
	1: "serverAddress",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR from json.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientCIDR":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientCIDR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientCIDR\"")
			}
		case "serverAddress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ServerAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (s IoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (s *IoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Time to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1Time(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1WatchEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent = [2]string{
	0: "object",
	1: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1WatchEvent from json.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1WatchEvent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1WatchEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgRuntimeRawExtension) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgRuntimeRawExtension = [0]string{}

// Decode decodes IoK8sApimachineryPkgRuntimeRawExtension from json.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgRuntimeRawExtension to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgRuntimeRawExtension")
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (s IoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (s *IoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgUtilIntstrIntOrString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgUtilIntstrIntOrString(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgVersionInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"buildDate\"" + ":")
		e.Str(s.BuildDate)
	}
	{
		e.Comma()

		e.RawStr("\"compiler\"" + ":")
		e.Str(s.Compiler)
	}
	{
		e.Comma()

		e.RawStr("\"gitCommit\"" + ":")
		e.Str(s.GitCommit)
	}
	{
		e.Comma()

		e.RawStr("\"gitTreeState\"" + ":")
		e.Str(s.GitTreeState)
	}
	{
		e.Comma()

		e.RawStr("\"gitVersion\"" + ":")
		e.Str(s.GitVersion)
	}
	{
		e.Comma()

		e.RawStr("\"goVersion\"" + ":")
		e.Str(s.GoVersion)
	}
	{
		e.Comma()

		e.RawStr("\"major\"" + ":")
		e.Str(s.Major)
	}
	{
		e.Comma()

		e.RawStr("\"minor\"" + ":")
		e.Str(s.Minor)
	}
	{
		e.Comma()

		e.RawStr("\"platform\"" + ":")
		e.Str(s.Platform)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo = [9]string{
	0: "buildDate",
	1: "compiler",
	2: "gitCommit",
	3: "gitTreeState",
	4: "gitVersion",
	5: "goVersion",
	6: "major",
	7: "minor",
	8: "platform",
}

// Decode decodes IoK8sApimachineryPkgVersionInfo from json.
func (s *IoK8sApimachineryPkgVersionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgVersionInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "buildDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BuildDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildDate\"")
			}
		case "compiler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Compiler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compiler\"")
			}
		case "gitCommit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitCommit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitCommit\"")
			}
		case "gitTreeState":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTreeState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitTreeState\"")
			}
		case "gitVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitVersion\"")
			}
		case "goVersion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GoVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goVersion\"")
			}
		case "major":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Major = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major\"")
			}
		case "minor":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Minor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minor\"")
			}
		case "platform":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Platform = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgVersionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIService = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIService from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIService to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIService")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sKubeAggregatorPkgApisApiregistrationV1APIService, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Group.Set {
			e.Comma()
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"groupPriorityMinimum\"" + ":")
		e.Int32(s.GroupPriorityMinimum)
	}
	{
		if s.InsecureSkipTLSVerify.Set {
			e.Comma()
		}
		if s.InsecureSkipTLSVerify.Set {
			e.RawStr("\"insecureSkipTLSVerify\"" + ":")
			s.InsecureSkipTLSVerify.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.Comma()
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"versionPriority\"" + ":")
		e.Int32(s.VersionPriority)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec = [7]string{
	0: "caBundle",
	1: "group",
	2: "groupPriorityMinimum",
	3: "insecureSkipTLSVerify",
	4: "service",
	5: "version",
	6: "versionPriority",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "groupPriorityMinimum":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.GroupPriorityMinimum = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupPriorityMinimum\"")
			}
		case "insecureSkipTLSVerify":
			if err := func() error {
				s.InsecureSkipTLSVerify.Reset()
				if err := s.InsecureSkipTLSVerify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecureSkipTLSVerify\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "versionPriority":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.VersionPriority = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionPriority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference = [3]string{
	0: "name",
	1: "namespace",
	2: "port",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference")
	}

	return nil
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBool", d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFloat64", d.Next())
	}
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int32()
		if err != nil {
			return err
		}
		o.Value = int32(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt32", d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt64", d.Next())
	}
}

// Encode encodes IoK8sAPIAdmissionregistrationV1ServiceReference as json.
func (o OptIoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (o *OptIoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAdmissionregistrationV1ServiceReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAdmissionregistrationV1ServiceReference", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetSpec as json.
func (o OptIoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (o *OptIoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetStatus as json.
func (o OptIoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (o *OptIoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetUpdateStrategy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetUpdateStrategy", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentSpec as json.
func (o OptIoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (o *OptIoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentStatus as json.
func (o OptIoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (o *OptIoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentStrategy as json.
func (o OptIoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (o *OptIoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStrategy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentStrategy", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetSpec as json.
func (o OptIoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1ReplicaSetSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetStatus as json.
func (o OptIoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1ReplicaSetStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDaemonSet as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDaemonSet to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateDaemonSet", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDeployment as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDeployment to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateDeployment", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy as json.
func (o OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetSpec as json.
func (o OptIoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (o *OptIoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetStatus as json.
func (o OptIoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (o *OptIoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetUpdateStrategy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetUpdateStrategy", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleSpec as json.
func (o OptIoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV1ScaleSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleStatus as json.
func (o OptIoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV1ScaleStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1PodsMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HPAScalingRules as json.
func (o OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HPAScalingRules to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HPAScalingRules", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2PodsMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource", d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1CronJobSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1CronJobSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1CronJobStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1CronJobStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1JobSpec as json.
func (o OptIoK8sAPIBatchV1JobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (o *OptIoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1JobSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1JobSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1JobStatus as json.
func (o OptIoK8sAPIBatchV1JobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (o *OptIoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1JobStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1JobStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1UncountedTerminatedPods as json.
func (o OptIoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (o *OptIoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1UncountedTerminatedPods to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1UncountedTerminatedPods", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1beta1CronJobSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIBatchV1beta1CronJobStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra", d.Next())
	}
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestStatus as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICertificatesV1CertificateSigningRequestStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoordinationV1LeaseSpec as json.
func (o OptIoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (o *OptIoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoordinationV1LeaseSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoordinationV1LeaseSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource as json.
func (o OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (o *OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Affinity as json.
func (o OptIoK8sAPICoreV1Affinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (o *OptIoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Affinity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1Affinity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureDiskVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1AzureDiskVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureFilePersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureFilePersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1AzureFilePersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureFileVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureFileVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1AzureFileVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CSIPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CSIVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Capabilities as json.
func (o OptIoK8sAPICoreV1Capabilities) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (o *OptIoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Capabilities to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1Capabilities", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CephFSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CephFSPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CephFSPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CephFSVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CephFSVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CephFSVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CinderPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CinderPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CinderPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CinderVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CinderVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1CinderVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ClientIPConfig as json.
func (o OptIoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (o *OptIoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ClientIPConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ClientIPConfig", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapBinaryData as json.
func (o OptIoK8sAPICoreV1ConfigMapBinaryData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapBinaryData from json.
func (o *OptIoK8sAPICoreV1ConfigMapBinaryData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapBinaryData to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ConfigMapBinaryData)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapBinaryData", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapData as json.
func (o OptIoK8sAPICoreV1ConfigMapData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapData from json.
func (o *OptIoK8sAPICoreV1ConfigMapData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapData to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ConfigMapData)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapData", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapEnvSource as json.
func (o OptIoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapEnvSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapEnvSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapKeySelector as json.
func (o OptIoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (o *OptIoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapKeySelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapKeySelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapNodeConfigSource as json.
func (o OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapNodeConfigSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapNodeConfigSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapProjection as json.
func (o OptIoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (o *OptIoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapProjection to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapProjection", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapVolumeSource as json.
func (o OptIoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerState as json.
func (o OptIoK8sAPICoreV1ContainerState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (o *OptIoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerState to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ContainerState", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateRunning as json.
func (o OptIoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (o *OptIoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateRunning to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateRunning", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateTerminated as json.
func (o OptIoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (o *OptIoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateTerminated to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateTerminated", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateWaiting as json.
func (o OptIoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (o *OptIoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateWaiting to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateWaiting", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DaemonEndpoint as json.
func (o OptIoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (o *OptIoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DaemonEndpoint to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1DaemonEndpoint", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DownwardAPIProjection as json.
func (o OptIoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (o *OptIoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIProjection to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1DownwardAPIProjection", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DownwardAPIVolumeSource as json.
func (o OptIoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (o *OptIoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1DownwardAPIVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EmptyDirVolumeSource as json.
func (o OptIoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (o *OptIoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EmptyDirVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1EmptyDirVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EnvVarSource as json.
func (o OptIoK8sAPICoreV1EnvVarSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (o *OptIoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EnvVarSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1EnvVarSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EphemeralVolumeSource as json.
func (o OptIoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (o *OptIoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EphemeralVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1EphemeralVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EventSeries as json.
func (o OptIoK8sAPICoreV1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (o *OptIoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EventSeries to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1EventSeries", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EventSource as json.
func (o OptIoK8sAPICoreV1EventSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (o *OptIoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EventSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1EventSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ExecAction as json.
func (o OptIoK8sAPICoreV1ExecAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (o *OptIoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ExecAction to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ExecAction", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FCVolumeSource as json.
func (o OptIoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (o *OptIoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FCVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FCVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FlexPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FlexVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexVolumeSourceOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSourceOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FlexVolumeSourceOptions", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlockerVolumeSource as json.
func (o OptIoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlockerVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1FlockerVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GitRepoVolumeSource as json.
func (o OptIoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (o *OptIoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GitRepoVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1GitRepoVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GlusterfsVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GlusterfsVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1GlusterfsVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1HTTPGetAction as json.
func (o OptIoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (o *OptIoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1HTTPGetAction to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1HTTPGetAction", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Handler as json.
func (o OptIoK8sAPICoreV1Handler) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (o *OptIoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Handler to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1Handler", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1HostPathVolumeSource as json.
func (o OptIoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (o *OptIoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1HostPathVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1HostPathVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ISCSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ISCSIPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ISCSIPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ISCSIVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ISCSIVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ISCSIVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Lifecycle as json.
func (o OptIoK8sAPICoreV1Lifecycle) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (o *OptIoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Lifecycle to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1Lifecycle", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefault as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefault) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefault from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefault) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefault to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1LimitRangeItemDefault)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemDefault", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefaultRequest as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefaultRequest from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefaultRequest to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemDefaultRequest", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMax as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMax) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMax from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMax) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMax to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1LimitRangeItemMax)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMax", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMin as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMin) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMin from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMin to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1LimitRangeItemMin)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMin", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeSpec as json.
func (o OptIoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (o *OptIoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LoadBalancerStatus as json.
func (o OptIoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (o *OptIoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LoadBalancerStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LoadBalancerStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LocalObjectReference as json.
func (o OptIoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (o *OptIoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LocalObjectReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LocalObjectReference", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LocalVolumeSource as json.
func (o OptIoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (o *OptIoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LocalVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1LocalVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NFSVolumeSource as json.
func (o OptIoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NFSVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NFSVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NamespaceSpec as json.
func (o OptIoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (o *OptIoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NamespaceSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NamespaceSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NamespaceStatus as json.
func (o OptIoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (o *OptIoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NamespaceStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NamespaceStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeAffinity as json.
func (o OptIoK8sAPICoreV1NodeAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (o *OptIoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeAffinity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeAffinity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeConfigSource as json.
func (o OptIoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (o *OptIoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeConfigSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeConfigSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeConfigStatus as json.
func (o OptIoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (o *OptIoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeConfigStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeConfigStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeDaemonEndpoints as json.
func (o OptIoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (o *OptIoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeDaemonEndpoints to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeDaemonEndpoints", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSelector as json.
func (o OptIoK8sAPICoreV1NodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (o *OptIoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSpec as json.
func (o OptIoK8sAPICoreV1NodeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (o *OptIoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatus as json.
func (o OptIoK8sAPICoreV1NodeStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (o *OptIoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatusAllocatable as json.
func (o OptIoK8sAPICoreV1NodeStatusAllocatable) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusAllocatable from json.
func (o *OptIoK8sAPICoreV1NodeStatusAllocatable) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatusAllocatable to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1NodeStatusAllocatable)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeStatusAllocatable", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatusCapacity as json.
func (o OptIoK8sAPICoreV1NodeStatusCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusCapacity from json.
func (o *OptIoK8sAPICoreV1NodeStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatusCapacity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1NodeStatusCapacity)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeStatusCapacity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSystemInfo as json.
func (o OptIoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (o *OptIoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSystemInfo to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1NodeSystemInfo", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ObjectFieldSelector as json.
func (o OptIoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (o *OptIoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ObjectFieldSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ObjectFieldSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ObjectReference as json.
func (o OptIoK8sAPICoreV1ObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (o *OptIoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ObjectReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ObjectReference", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimTemplate as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimTemplate to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimTemplate", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpecCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpecCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpecCapacity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeSpecCapacity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodAffinity as json.
func (o OptIoK8sAPICoreV1PodAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (o *OptIoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodAffinity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodAffinity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodAntiAffinity as json.
func (o OptIoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (o *OptIoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodAntiAffinity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodAntiAffinity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodDNSConfig as json.
func (o OptIoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (o *OptIoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodDNSConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodDNSConfig", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSecurityContext as json.
func (o OptIoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (o *OptIoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSecurityContext to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodSecurityContext", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpec as json.
func (o OptIoK8sAPICoreV1PodSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (o *OptIoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpecNodeSelector as json.
func (o OptIoK8sAPICoreV1PodSpecNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecNodeSelector from json.
func (o *OptIoK8sAPICoreV1PodSpecNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpecNodeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1PodSpecNodeSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodSpecNodeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpecOverhead as json.
func (o OptIoK8sAPICoreV1PodSpecOverhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecOverhead from json.
func (o *OptIoK8sAPICoreV1PodSpecOverhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpecOverhead to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1PodSpecOverhead)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodSpecOverhead", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodStatus as json.
func (o OptIoK8sAPICoreV1PodStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (o *OptIoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodTemplateSpec as json.
func (o OptIoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (o *OptIoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodTemplateSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PodTemplateSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PortworxVolumeSource as json.
func (o OptIoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (o *OptIoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PortworxVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1PortworxVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Probe as json.
func (o OptIoK8sAPICoreV1Probe) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (o *OptIoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Probe to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1Probe", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ProjectedVolumeSource as json.
func (o OptIoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (o *OptIoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ProjectedVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ProjectedVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1QuobyteVolumeSource as json.
func (o OptIoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (o *OptIoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1QuobyteVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1QuobyteVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1RBDPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1RBDPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1RBDPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1RBDVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1RBDVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1RBDVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpec as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpecSelector as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpecSelector from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpecSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerSpecSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerStatus as json.
func (o OptIoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceFieldSelector as json.
func (o OptIoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (o *OptIoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceFieldSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceFieldSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpec as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpecHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpecHard) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpecHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpecHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpecHard to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaSpecHard", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatus as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusHard) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusHard to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatusHard", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusUsed as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusUsed from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusUsed to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatusUsed", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirements as json.
func (o OptIoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (o *OptIoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirements to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirements", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsLimits as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsLimits) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsLimits from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsLimits to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ResourceRequirementsLimits)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirementsLimits", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsRequests as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsRequests) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsRequests from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsRequests to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ResourceRequirementsRequests)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirementsRequests", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SELinuxOptions as json.
func (o OptIoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (o *OptIoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SELinuxOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SELinuxOptions", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScaleIOVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScaleIOVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ScaleIOVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScopeSelector as json.
func (o OptIoK8sAPICoreV1ScopeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (o *OptIoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScopeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ScopeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SeccompProfile as json.
func (o OptIoK8sAPICoreV1SeccompProfile) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (o *OptIoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SeccompProfile to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SeccompProfile", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretData as json.
func (o OptIoK8sAPICoreV1SecretData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretData from json.
func (o *OptIoK8sAPICoreV1SecretData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretData to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1SecretData)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretData", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretEnvSource as json.
func (o OptIoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (o *OptIoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretEnvSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretEnvSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretKeySelector as json.
func (o OptIoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (o *OptIoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretKeySelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretKeySelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretProjection as json.
func (o OptIoK8sAPICoreV1SecretProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (o *OptIoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretProjection to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretProjection", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretReference as json.
func (o OptIoK8sAPICoreV1SecretReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (o *OptIoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretReference", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretStringData as json.
func (o OptIoK8sAPICoreV1SecretStringData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretStringData from json.
func (o *OptIoK8sAPICoreV1SecretStringData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretStringData to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1SecretStringData)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretStringData", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretVolumeSource as json.
func (o OptIoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (o *OptIoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecretVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecurityContext as json.
func (o OptIoK8sAPICoreV1SecurityContext) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (o *OptIoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecurityContext to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SecurityContext", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceAccountTokenProjection as json.
func (o OptIoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (o *OptIoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceAccountTokenProjection to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ServiceAccountTokenProjection", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceSpec as json.
func (o OptIoK8sAPICoreV1ServiceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (o *OptIoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ServiceSpec", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceSpecSelector as json.
func (o OptIoK8sAPICoreV1ServiceSpecSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpecSelector from json.
func (o *OptIoK8sAPICoreV1ServiceSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceSpecSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPICoreV1ServiceSpecSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ServiceSpecSelector", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceStatus as json.
func (o OptIoK8sAPICoreV1ServiceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (o *OptIoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1ServiceStatus", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SessionAffinityConfig as json.
func (o OptIoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (o *OptIoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SessionAffinityConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1SessionAffinityConfig", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1StorageOSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1StorageOSPersistentVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1StorageOSPersistentVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1StorageOSVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1StorageOSVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1StorageOSVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1TCPSocketAction as json.
func (o OptIoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (o *OptIoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1TCPSocketAction to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1TCPSocketAction", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1TypedLocalObjectReference as json.
func (o OptIoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (o *OptIoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1TypedLocalObjectReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1TypedLocalObjectReference", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1VolumeNodeAffinity as json.
func (o OptIoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (o *OptIoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1VolumeNodeAffinity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1VolumeNodeAffinity", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource", d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1WindowsSecurityContextOptions as json.
func (o OptIoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (o *OptIoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1WindowsSecurityContextOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPICoreV1WindowsSecurityContextOptions", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointConditions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointConditions", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology as json.
func (o OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointHints to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointHints", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointConditions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointConditions", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointHints to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointHints", d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointTopology as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointTopology from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointTopology to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointTopology", d.Next())
	}
}

// Encode encodes IoK8sAPIEventsV1EventSeries as json.
func (o OptIoK8sAPIEventsV1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (o *OptIoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIEventsV1EventSeries to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIEventsV1EventSeries", d.Next())
	}
}

// Encode encodes IoK8sAPIEventsV1beta1EventSeries as json.
func (o OptIoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (o *OptIoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIEventsV1beta1EventSeries to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIEventsV1beta1EventSeries", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1GroupSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1GroupSubject", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitResponse to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1LimitResponse", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1UserSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1UserSubject", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2GroupSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2GroupSubject", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitResponse to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2LimitResponse", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject", d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2UserSubject to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2UserSubject", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1HTTPIngressRuleValue as json.
func (o OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (o *OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1HTTPIngressRuleValue to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1HTTPIngressRuleValue", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IPBlock as json.
func (o OptIoK8sAPINetworkingV1IPBlock) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (o *OptIoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IPBlock to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IPBlock", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressBackend as json.
func (o OptIoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressBackend to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressBackend", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressClassParametersReference as json.
func (o OptIoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (o *OptIoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassParametersReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressClassParametersReference", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressClassSpec as json.
func (o OptIoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressClassSpec", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressServiceBackend as json.
func (o OptIoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressServiceBackend to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressServiceBackend", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressSpec as json.
func (o OptIoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressSpec", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressStatus as json.
func (o OptIoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (o *OptIoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1IngressStatus", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1NetworkPolicySpec as json.
func (o OptIoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (o *OptIoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1NetworkPolicySpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1NetworkPolicySpec", d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1ServiceBackendPort as json.
func (o OptIoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (o *OptIoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1ServiceBackendPort to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINetworkingV1ServiceBackendPort", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1Overhead as json.
func (o OptIoK8sAPINodeV1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (o *OptIoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1Overhead to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1Overhead", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1OverheadPodFixed to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1OverheadPodFixed)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1OverheadPodFixed", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1Scheduling as json.
func (o OptIoK8sAPINodeV1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (o *OptIoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1Scheduling to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1Scheduling", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1SchedulingNodeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1SchedulingNodeSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1SchedulingNodeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1Overhead as json.
func (o OptIoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (o *OptIoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1Overhead to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1alpha1Overhead", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1alpha1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1alpha1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1OverheadPodFixed to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1alpha1OverheadPodFixed", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1Scheduling as json.
func (o OptIoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (o *OptIoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1Scheduling to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1alpha1Scheduling", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1SchedulingNodeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1alpha1SchedulingNodeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1Overhead as json.
func (o OptIoK8sAPINodeV1beta1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (o *OptIoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1Overhead to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1beta1Overhead", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1beta1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1beta1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1OverheadPodFixed to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1beta1OverheadPodFixed)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1beta1OverheadPodFixed", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1Scheduling as json.
func (o OptIoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (o *OptIoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1Scheduling to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1beta1Scheduling", d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1SchedulingNodeSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPINodeV1beta1SchedulingNodeSelector", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions", d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions", d.Next())
	}
}

// Encode encodes IoK8sAPIRbacV1AggregationRule as json.
func (o OptIoK8sAPIRbacV1AggregationRule) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (o *OptIoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIRbacV1AggregationRule to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIRbacV1AggregationRule", d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1StorageClassParameters as json.
func (o OptIoK8sAPIStorageV1StorageClassParameters) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1StorageClassParameters from json.
func (o *OptIoK8sAPIStorageV1StorageClassParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1StorageClassParameters to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIStorageV1StorageClassParameters)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIStorageV1StorageClassParameters", d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatus as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIStorageV1VolumeAttachmentStatus", d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata", d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeError as json.
func (o OptIoK8sAPIStorageV1VolumeError) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (o *OptIoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeError to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIStorageV1VolumeError", d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeNodeResources as json.
func (o OptIoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (o *OptIoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeNodeResources to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sAPIStorageV1VolumeNodeResources", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig", d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (o OptIoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (o *OptIoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgAPIResourceQuantity to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgAPIResourceQuantity", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery as json.
func (o OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelector as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelector to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1LabelSelector", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ListMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ListMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ListMeta", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (o OptIoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1MicroTime to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1MicroTime", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMeta", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (o OptIoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1Time to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1Time", d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (o OptIoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (o *OptIoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgUtilIntstrIntOrString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sApimachineryPkgUtilIntstrIntOrString", d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec", d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus", d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference", d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptString", d.Next())
	}
}

// Encode encodes ReadCoreV1NamespacedPodLogOKApplicationJSON as json.
func (s ReadCoreV1NamespacedPodLogOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes ReadCoreV1NamespacedPodLogOKApplicationJSON from json.
func (s *ReadCoreV1NamespacedPodLogOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadCoreV1NamespacedPodLogOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadCoreV1NamespacedPodLogOKApplicationJSON(unwrapped)
	return nil
}
