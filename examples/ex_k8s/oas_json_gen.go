// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s GetAPIVersionsUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAPIVersionsUnauthorized = [0]string{}

// Decode decodes GetAPIVersionsUnauthorized from json.
func (s *GetAPIVersionsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAPIVersionsUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAdmissionregistrationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAdmissionregistrationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetAdmissionregistrationAPIGroupUnauthorized from json.
func (s *GetAdmissionregistrationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAdmissionregistrationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAdmissionregistrationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAdmissionregistrationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAdmissionregistrationV1APIResourcesUnauthorized from json.
func (s *GetAdmissionregistrationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAdmissionregistrationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetApiextensionsAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetApiextensionsAPIGroupUnauthorized = [0]string{}

// Decode decodes GetApiextensionsAPIGroupUnauthorized from json.
func (s *GetApiextensionsAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetApiextensionsAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetApiextensionsV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetApiextensionsV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetApiextensionsV1APIResourcesUnauthorized from json.
func (s *GetApiextensionsV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetApiextensionsV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetApiregistrationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetApiregistrationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetApiregistrationAPIGroupUnauthorized from json.
func (s *GetApiregistrationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetApiregistrationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetApiregistrationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetApiregistrationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetApiregistrationV1APIResourcesUnauthorized from json.
func (s *GetApiregistrationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetApiregistrationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAppsAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAppsAPIGroupUnauthorized = [0]string{}

// Decode decodes GetAppsAPIGroupUnauthorized from json.
func (s *GetAppsAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAppsAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAppsV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAppsV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAppsV1APIResourcesUnauthorized from json.
func (s *GetAppsV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAppsV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAuthenticationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAuthenticationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetAuthenticationAPIGroupUnauthorized from json.
func (s *GetAuthenticationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAuthenticationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAuthenticationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAuthenticationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAuthenticationV1APIResourcesUnauthorized from json.
func (s *GetAuthenticationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAuthenticationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAuthorizationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAuthorizationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetAuthorizationAPIGroupUnauthorized from json.
func (s *GetAuthorizationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAuthorizationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAuthorizationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAuthorizationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAuthorizationV1APIResourcesUnauthorized from json.
func (s *GetAuthorizationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAuthorizationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAutoscalingAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAutoscalingAPIGroupUnauthorized = [0]string{}

// Decode decodes GetAutoscalingAPIGroupUnauthorized from json.
func (s *GetAutoscalingAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAutoscalingAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAutoscalingV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAutoscalingV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAutoscalingV1APIResourcesUnauthorized from json.
func (s *GetAutoscalingV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAutoscalingV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAutoscalingV2beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAutoscalingV2beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAutoscalingV2beta1APIResourcesUnauthorized from json.
func (s *GetAutoscalingV2beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAutoscalingV2beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetAutoscalingV2beta2APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetAutoscalingV2beta2APIResourcesUnauthorized = [0]string{}

// Decode decodes GetAutoscalingV2beta2APIResourcesUnauthorized from json.
func (s *GetAutoscalingV2beta2APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetAutoscalingV2beta2APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetBatchAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetBatchAPIGroupUnauthorized = [0]string{}

// Decode decodes GetBatchAPIGroupUnauthorized from json.
func (s *GetBatchAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetBatchAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetBatchV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetBatchV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetBatchV1APIResourcesUnauthorized from json.
func (s *GetBatchV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetBatchV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetBatchV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetBatchV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetBatchV1beta1APIResourcesUnauthorized from json.
func (s *GetBatchV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetBatchV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCertificatesAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCertificatesAPIGroupUnauthorized = [0]string{}

// Decode decodes GetCertificatesAPIGroupUnauthorized from json.
func (s *GetCertificatesAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCertificatesAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCertificatesV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCertificatesV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetCertificatesV1APIResourcesUnauthorized from json.
func (s *GetCertificatesV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCertificatesV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCodeVersionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCodeVersionUnauthorized = [0]string{}

// Decode decodes GetCodeVersionUnauthorized from json.
func (s *GetCodeVersionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCodeVersionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCoordinationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCoordinationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetCoordinationAPIGroupUnauthorized from json.
func (s *GetCoordinationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCoordinationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCoordinationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCoordinationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetCoordinationV1APIResourcesUnauthorized from json.
func (s *GetCoordinationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCoordinationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCoreAPIVersionsUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCoreAPIVersionsUnauthorized = [0]string{}

// Decode decodes GetCoreAPIVersionsUnauthorized from json.
func (s *GetCoreAPIVersionsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCoreAPIVersionsUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetCoreV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetCoreV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetCoreV1APIResourcesUnauthorized from json.
func (s *GetCoreV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetCoreV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetDiscoveryAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetDiscoveryAPIGroupUnauthorized = [0]string{}

// Decode decodes GetDiscoveryAPIGroupUnauthorized from json.
func (s *GetDiscoveryAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetDiscoveryAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetDiscoveryV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetDiscoveryV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetDiscoveryV1APIResourcesUnauthorized from json.
func (s *GetDiscoveryV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetDiscoveryV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetDiscoveryV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetDiscoveryV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetDiscoveryV1beta1APIResourcesUnauthorized from json.
func (s *GetDiscoveryV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetDiscoveryV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetEventsAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetEventsAPIGroupUnauthorized = [0]string{}

// Decode decodes GetEventsAPIGroupUnauthorized from json.
func (s *GetEventsAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetEventsAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetEventsV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetEventsV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetEventsV1APIResourcesUnauthorized from json.
func (s *GetEventsV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetEventsV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetEventsV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetEventsV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetEventsV1beta1APIResourcesUnauthorized from json.
func (s *GetEventsV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetEventsV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetFlowcontrolApiserverAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetFlowcontrolApiserverAPIGroupUnauthorized = [0]string{}

// Decode decodes GetFlowcontrolApiserverAPIGroupUnauthorized from json.
func (s *GetFlowcontrolApiserverAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetFlowcontrolApiserverAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetFlowcontrolApiserverV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetFlowcontrolApiserverV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetFlowcontrolApiserverV1beta1APIResourcesUnauthorized from json.
func (s *GetFlowcontrolApiserverV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetFlowcontrolApiserverV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetFlowcontrolApiserverV1beta2APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetFlowcontrolApiserverV1beta2APIResourcesUnauthorized = [0]string{}

// Decode decodes GetFlowcontrolApiserverV1beta2APIResourcesUnauthorized from json.
func (s *GetFlowcontrolApiserverV1beta2APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetFlowcontrolApiserverV1beta2APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetInternalApiserverAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetInternalApiserverAPIGroupUnauthorized = [0]string{}

// Decode decodes GetInternalApiserverAPIGroupUnauthorized from json.
func (s *GetInternalApiserverAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetInternalApiserverAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetInternalApiserverV1alpha1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetInternalApiserverV1alpha1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetInternalApiserverV1alpha1APIResourcesUnauthorized from json.
func (s *GetInternalApiserverV1alpha1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetInternalApiserverV1alpha1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNetworkingAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNetworkingAPIGroupUnauthorized = [0]string{}

// Decode decodes GetNetworkingAPIGroupUnauthorized from json.
func (s *GetNetworkingAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNetworkingAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNetworkingV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNetworkingV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetNetworkingV1APIResourcesUnauthorized from json.
func (s *GetNetworkingV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNetworkingV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNodeAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNodeAPIGroupUnauthorized = [0]string{}

// Decode decodes GetNodeAPIGroupUnauthorized from json.
func (s *GetNodeAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNodeAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNodeV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNodeV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetNodeV1APIResourcesUnauthorized from json.
func (s *GetNodeV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNodeV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNodeV1alpha1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNodeV1alpha1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetNodeV1alpha1APIResourcesUnauthorized from json.
func (s *GetNodeV1alpha1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNodeV1alpha1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetNodeV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetNodeV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetNodeV1beta1APIResourcesUnauthorized from json.
func (s *GetNodeV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetNodeV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetPolicyAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetPolicyAPIGroupUnauthorized = [0]string{}

// Decode decodes GetPolicyAPIGroupUnauthorized from json.
func (s *GetPolicyAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetPolicyAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetPolicyV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetPolicyV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetPolicyV1APIResourcesUnauthorized from json.
func (s *GetPolicyV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetPolicyV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetPolicyV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetPolicyV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetPolicyV1beta1APIResourcesUnauthorized from json.
func (s *GetPolicyV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetPolicyV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetRbacAuthorizationAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetRbacAuthorizationAPIGroupUnauthorized = [0]string{}

// Decode decodes GetRbacAuthorizationAPIGroupUnauthorized from json.
func (s *GetRbacAuthorizationAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetRbacAuthorizationAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetRbacAuthorizationV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetRbacAuthorizationV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetRbacAuthorizationV1APIResourcesUnauthorized from json.
func (s *GetRbacAuthorizationV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetRbacAuthorizationV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetSchedulingAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetSchedulingAPIGroupUnauthorized = [0]string{}

// Decode decodes GetSchedulingAPIGroupUnauthorized from json.
func (s *GetSchedulingAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetSchedulingAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetSchedulingV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetSchedulingV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetSchedulingV1APIResourcesUnauthorized from json.
func (s *GetSchedulingV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetSchedulingV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode encodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON as json.
func (s GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON from json.
func (s *GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GetServiceAccountIssuerOpenIDConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetServiceAccountIssuerOpenIDConfigurationUnauthorized = [0]string{}

// Decode decodes GetServiceAccountIssuerOpenIDConfigurationUnauthorized from json.
func (s *GetServiceAccountIssuerOpenIDConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetServiceAccountIssuerOpenIDConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetStorageAPIGroupUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetStorageAPIGroupUnauthorized = [0]string{}

// Decode decodes GetStorageAPIGroupUnauthorized from json.
func (s *GetStorageAPIGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStorageAPIGroupUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetStorageV1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetStorageV1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetStorageV1APIResourcesUnauthorized from json.
func (s *GetStorageV1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStorageV1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetStorageV1alpha1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetStorageV1alpha1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetStorageV1alpha1APIResourcesUnauthorized from json.
func (s *GetStorageV1alpha1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStorageV1alpha1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetStorageV1beta1APIResourcesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfGetStorageV1beta1APIResourcesUnauthorized = [0]string{}

// Decode decodes GetStorageV1beta1APIResourcesUnauthorized from json.
func (s *GetStorageV1beta1APIResourcesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStorageV1beta1APIResourcesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admissionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.AdmissionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AdmissionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.AdmissionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"clientConfig\"" + ":")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.Comma()
		}
		if s.FailurePolicy.Set {
			e.RawStr("\"failurePolicy\"" + ":")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.Comma()
		}
		if s.MatchPolicy.Set {
			e.RawStr("\"matchPolicy\"" + ":")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.Comma()
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.Comma()
		}
		if s.ObjectSelector.Set {
			e.RawStr("\"objectSelector\"" + ":")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.ReinvocationPolicy.Set {
			e.Comma()
		}
		if s.ReinvocationPolicy.Set {
			e.RawStr("\"reinvocationPolicy\"" + ":")
			s.ReinvocationPolicy.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"sideEffects\"" + ":")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.Comma()
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook = [11]string{
	0:  "admissionReviewVersions",
	1:  "clientConfig",
	2:  "failurePolicy",
	3:  "matchPolicy",
	4:  "name",
	5:  "namespaceSelector",
	6:  "objectSelector",
	7:  "reinvocationPolicy",
	8:  "rules",
	9:  "sideEffects",
	10: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhook to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			s.AdmissionReviewVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := s.ClientConfig.Decode(d); err != nil {
				return err
			}
		case "failurePolicy":
			s.FailurePolicy.Reset()
			if err := s.FailurePolicy.Decode(d); err != nil {
				return err
			}
		case "matchPolicy":
			s.MatchPolicy.Reset()
			if err := s.MatchPolicy.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespaceSelector":
			s.NamespaceSelector.Reset()
			if err := s.NamespaceSelector.Decode(d); err != nil {
				return err
			}
		case "objectSelector":
			s.ObjectSelector.Reset()
			if err := s.ObjectSelector.Decode(d); err != nil {
				return err
			}
		case "reinvocationPolicy":
			s.ReinvocationPolicy.Reset()
			if err := s.ReinvocationPolicy.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 1
			v, err := d.Str()
			s.SideEffects = string(v)
			if err != nil {
				return err
			}
		case "timeoutSeconds":
			s.TimeoutSeconds.Reset()
			if err := s.TimeoutSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Webhooks != nil {
			e.RawStr("\"webhooks\"" + ":")
			e.ArrStart()
			if len(s.Webhooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Webhooks[0]
					elem.Encode(e)
				}
				for _, elem := range s.Webhooks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "webhooks":
			s.Webhooks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1MutatingWebhook
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Webhooks = append(s.Webhooks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1RuleWithOperations) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroups != nil {
			e.RawStr("\"apiGroups\"" + ":")
			e.ArrStart()
			if len(s.ApiGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiGroups[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiGroups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersions != nil {
			e.RawStr("\"apiVersions\"" + ":")
			e.ArrStart()
			if len(s.ApiVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Operations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operations != nil {
			e.RawStr("\"operations\"" + ":")
			e.ArrStart()
			if len(s.Operations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Operations[0]
					e.Str(elem)
				}
				for _, elem := range s.Operations[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources != nil {
			e.RawStr("\"resources\"" + ":")
			e.ArrStart()
			if len(s.Resources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Resources[0]
					e.Str(elem)
				}
				for _, elem := range s.Resources[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Scope.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1RuleWithOperations = [5]string{
	0: "apiGroups",
	1: "apiVersions",
	2: "operations",
	3: "resources",
	4: "scope",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1RuleWithOperations from json.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1RuleWithOperations to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			s.ApiGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ApiGroups = append(s.ApiGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apiVersions":
			s.ApiVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ApiVersions = append(s.ApiVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		case "scope":
			s.Scope.Reset()
			if err := s.Scope.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1ServiceReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Namespace = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admissionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.AdmissionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AdmissionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.AdmissionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"clientConfig\"" + ":")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.Comma()
		}
		if s.FailurePolicy.Set {
			e.RawStr("\"failurePolicy\"" + ":")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.Comma()
		}
		if s.MatchPolicy.Set {
			e.RawStr("\"matchPolicy\"" + ":")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.Comma()
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.Comma()
		}
		if s.ObjectSelector.Set {
			e.RawStr("\"objectSelector\"" + ":")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"sideEffects\"" + ":")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.Comma()
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook = [10]string{
	0: "admissionReviewVersions",
	1: "clientConfig",
	2: "failurePolicy",
	3: "matchPolicy",
	4: "name",
	5: "namespaceSelector",
	6: "objectSelector",
	7: "rules",
	8: "sideEffects",
	9: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhook to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			s.AdmissionReviewVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := s.ClientConfig.Decode(d); err != nil {
				return err
			}
		case "failurePolicy":
			s.FailurePolicy.Reset()
			if err := s.FailurePolicy.Decode(d); err != nil {
				return err
			}
		case "matchPolicy":
			s.MatchPolicy.Reset()
			if err := s.MatchPolicy.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespaceSelector":
			s.NamespaceSelector.Reset()
			if err := s.NamespaceSelector.Decode(d); err != nil {
				return err
			}
		case "objectSelector":
			s.ObjectSelector.Reset()
			if err := s.ObjectSelector.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.SideEffects = string(v)
			if err != nil {
				return err
			}
		case "timeoutSeconds":
			s.TimeoutSeconds.Reset()
			if err := s.TimeoutSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Webhooks != nil {
			e.RawStr("\"webhooks\"" + ":")
			e.ArrStart()
			if len(s.Webhooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Webhooks[0]
					elem.Encode(e)
				}
				for _, elem := range s.Webhooks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "webhooks":
			s.Webhooks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhook
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Webhooks = append(s.Webhooks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1WebhookClientConfig from json.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAdmissionregistrationV1WebhookClientConfig to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			v, err := d.Base64()
			s.CaBundle = []byte(v)
			if err != nil {
				return err
			}
		case "service":
			s.Service.Reset()
			if err := s.Service.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiServerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiServerID.Set {
			e.RawStr("\"apiServerID\"" + ":")
			s.ApiServerID.Encode(e)
		}
	}
	{
		if s.DecodableVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DecodableVersions != nil {
			e.RawStr("\"decodableVersions\"" + ":")
			e.ArrStart()
			if len(s.DecodableVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.DecodableVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.DecodableVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EncodingVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncodingVersion.Set {
			e.RawStr("\"encodingVersion\"" + ":")
			s.EncodingVersion.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1ServerStorageVersion = [3]string{
	0: "apiServerID",
	1: "decodableVersions",
	2: "encodingVersion",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiServerID":
			s.ApiServerID.Reset()
			if err := s.ApiServerID.Decode(d); err != nil {
				return err
			}
		case "decodableVersions":
			s.DecodableVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.DecodableVersions = append(s.DecodableVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "encodingVersion":
			s.EncodingVersion.Reset()
			if err := s.EncodingVersion.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersion to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionList from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIApiserverinternalV1alpha1StorageVersion
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionSpec = [0]string{}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommonEncodingVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommonEncodingVersion.Set {
			e.RawStr("\"commonEncodingVersion\"" + ":")
			s.CommonEncodingVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StorageVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageVersions != nil {
			e.RawStr("\"storageVersions\"" + ":")
			e.ArrStart()
			if len(s.StorageVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StorageVersions[0]
					elem.Encode(e)
				}
				for _, elem := range s.StorageVersions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionStatus = [3]string{
	0: "commonEncodingVersion",
	1: "conditions",
	2: "storageVersions",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commonEncodingVersion":
			s.CommonEncodingVersion.Reset()
			if err := s.CommonEncodingVersion.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "storageVersions":
			s.StorageVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.StorageVersions = append(s.StorageVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ControllerRevision) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data != nil {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"revision\"" + ":")
		e.Int64(s.Revision)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision = [5]string{
	0: "apiVersion",
	1: "data",
	2: "kind",
	3: "metadata",
	4: "revision",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevision from json.
func (s *IoK8sAPIAppsV1ControllerRevision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ControllerRevision to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data = nil
			var elem IoK8sApimachineryPkgRuntimeRawExtension
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Data = &elem
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "revision":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int64()
			s.Revision = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ControllerRevisionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevisionList from json.
func (s *IoK8sAPIAppsV1ControllerRevisionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ControllerRevisionList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1ControllerRevision
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1DaemonSet from json.
func (s *IoK8sAPIAppsV1DaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSet to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetCondition from json.
func (s *IoK8sAPIAppsV1DaemonSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSetCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetList from json.
func (s *IoK8sAPIAppsV1DaemonSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1DaemonSet
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.Comma()
		}
		if s.UpdateStrategy.Set {
			e.RawStr("\"updateStrategy\"" + ":")
			s.UpdateStrategy.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec = [5]string{
	0: "minReadySeconds",
	1: "revisionHistoryLimit",
	2: "selector",
	3: "template",
	4: "updateStrategy",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (s *IoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSetSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			s.MinReadySeconds.Reset()
			if err := s.MinReadySeconds.Decode(d); err != nil {
				return err
			}
		case "revisionHistoryLimit":
			s.RevisionHistoryLimit.Reset()
			if err := s.RevisionHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		case "updateStrategy":
			s.UpdateStrategy.Reset()
			if err := s.UpdateStrategy.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CollisionCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentNumberScheduled\"" + ":")
		e.Int32(s.CurrentNumberScheduled)
	}
	{
		e.Comma()

		e.RawStr("\"desiredNumberScheduled\"" + ":")
		e.Int32(s.DesiredNumberScheduled)
	}
	{
		if s.NumberAvailable.Set {
			e.Comma()
		}
		if s.NumberAvailable.Set {
			e.RawStr("\"numberAvailable\"" + ":")
			s.NumberAvailable.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"numberMisscheduled\"" + ":")
		e.Int32(s.NumberMisscheduled)
	}
	{
		e.Comma()

		e.RawStr("\"numberReady\"" + ":")
		e.Int32(s.NumberReady)
	}
	{
		if s.NumberUnavailable.Set {
			e.Comma()
		}
		if s.NumberUnavailable.Set {
			e.RawStr("\"numberUnavailable\"" + ":")
			s.NumberUnavailable.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.UpdatedNumberScheduled.Set {
			e.Comma()
		}
		if s.UpdatedNumberScheduled.Set {
			e.RawStr("\"updatedNumberScheduled\"" + ":")
			s.UpdatedNumberScheduled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus = [10]string{
	0: "collisionCount",
	1: "conditions",
	2: "currentNumberScheduled",
	3: "desiredNumberScheduled",
	4: "numberAvailable",
	5: "numberMisscheduled",
	6: "numberReady",
	7: "numberUnavailable",
	8: "observedGeneration",
	9: "updatedNumberScheduled",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (s *IoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSetStatus to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collisionCount":
			s.CollisionCount.Reset()
			if err := s.CollisionCount.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1DaemonSetCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentNumberScheduled":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.CurrentNumberScheduled = int32(v)
			if err != nil {
				return err
			}
		case "desiredNumberScheduled":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int32()
			s.DesiredNumberScheduled = int32(v)
			if err != nil {
				return err
			}
		case "numberAvailable":
			s.NumberAvailable.Reset()
			if err := s.NumberAvailable.Decode(d); err != nil {
				return err
			}
		case "numberMisscheduled":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Int32()
			s.NumberMisscheduled = int32(v)
			if err != nil {
				return err
			}
		case "numberReady":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.NumberReady = int32(v)
			if err != nil {
				return err
			}
		case "numberUnavailable":
			s.NumberUnavailable.Reset()
			if err := s.NumberUnavailable.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "updatedNumberScheduled":
			s.UpdatedNumberScheduled.Reset()
			if err := s.UpdatedNumberScheduled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DaemonSetUpdateStrategy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			s.RollingUpdate.Reset()
			if err := s.RollingUpdate.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1Deployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1Deployment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1Deployment from json.
func (s *IoK8sAPIAppsV1Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1Deployment to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastUpdateTime.Set {
			e.RawStr("\"lastUpdateTime\"" + ":")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentCondition from json.
func (s *IoK8sAPIAppsV1DeploymentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DeploymentCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "lastUpdateTime":
			s.LastUpdateTime.Reset()
			if err := s.LastUpdateTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DeploymentList from json.
func (s *IoK8sAPIAppsV1DeploymentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DeploymentList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1Deployment
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Paused.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Paused.Set {
			e.RawStr("\"paused\"" + ":")
			s.Paused.Encode(e)
		}
	}
	{
		if s.ProgressDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProgressDeadlineSeconds.Set {
			e.RawStr("\"progressDeadlineSeconds\"" + ":")
			s.ProgressDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		if s.Strategy.Set {
			e.Comma()
		}
		if s.Strategy.Set {
			e.RawStr("\"strategy\"" + ":")
			s.Strategy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec = [8]string{
	0: "minReadySeconds",
	1: "paused",
	2: "progressDeadlineSeconds",
	3: "replicas",
	4: "revisionHistoryLimit",
	5: "selector",
	6: "strategy",
	7: "template",
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (s *IoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DeploymentSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			s.MinReadySeconds.Reset()
			if err := s.MinReadySeconds.Decode(d); err != nil {
				return err
			}
		case "paused":
			s.Paused.Reset()
			if err := s.Paused.Decode(d); err != nil {
				return err
			}
		case "progressDeadlineSeconds":
			s.ProgressDeadlineSeconds.Reset()
			if err := s.ProgressDeadlineSeconds.Decode(d); err != nil {
				return err
			}
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		case "revisionHistoryLimit":
			s.RevisionHistoryLimit.Reset()
			if err := s.RevisionHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "selector":
			requiredBitSet[0] |= 1 << 5
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "strategy":
			s.Strategy.Reset()
			if err := s.Strategy.Decode(d); err != nil {
				return err
			}
		case "template":
			requiredBitSet[0] |= 1 << 7
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.CollisionCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.UnavailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnavailableReplicas.Set {
			e.RawStr("\"unavailableReplicas\"" + ":")
			s.UnavailableReplicas.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedReplicas.Set {
			e.RawStr("\"updatedReplicas\"" + ":")
			s.UpdatedReplicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStatus = [8]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
	6: "unavailableReplicas",
	7: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (s *IoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DeploymentStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			s.AvailableReplicas.Reset()
			if err := s.AvailableReplicas.Decode(d); err != nil {
				return err
			}
		case "collisionCount":
			s.CollisionCount.Reset()
			if err := s.CollisionCount.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1DeploymentCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "readyReplicas":
			s.ReadyReplicas.Reset()
			if err := s.ReadyReplicas.Decode(d); err != nil {
				return err
			}
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		case "unavailableReplicas":
			s.UnavailableReplicas.Reset()
			if err := s.UnavailableReplicas.Decode(d); err != nil {
				return err
			}
		case "updatedReplicas":
			s.UpdatedReplicas.Reset()
			if err := s.UpdatedReplicas.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (s *IoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1DeploymentStrategy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			s.RollingUpdate.Reset()
			if err := s.RollingUpdate.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSet from json.
func (s *IoK8sAPIAppsV1ReplicaSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ReplicaSet to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetCondition from json.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ReplicaSetCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetList from json.
func (s *IoK8sAPIAppsV1ReplicaSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ReplicaSetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1ReplicaSet
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		if s.Template.Set {
			e.Comma()
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ReplicaSetSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			s.MinReadySeconds.Reset()
			if err := s.MinReadySeconds.Decode(d); err != nil {
				return err
			}
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "template":
			s.Template.Reset()
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullyLabeledReplicas.Set {
			e.RawStr("\"fullyLabeledReplicas\"" + ":")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1ReplicaSetStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			s.AvailableReplicas.Reset()
			if err := s.AvailableReplicas.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1ReplicaSetCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "fullyLabeledReplicas":
			s.FullyLabeledReplicas.Reset()
			if err := s.FullyLabeledReplicas.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "readyReplicas":
			s.ReadyReplicas.Reset()
			if err := s.ReadyReplicas.Decode(d); err != nil {
				return err
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Int32()
			s.Replicas = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxSurge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxSurge.Set {
			e.RawStr("\"maxSurge\"" + ":")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDaemonSet = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDaemonSet to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			s.MaxSurge.Reset()
			if err := s.MaxSurge.Decode(d); err != nil {
				return err
			}
		case "maxUnavailable":
			s.MaxUnavailable.Reset()
			if err := s.MaxUnavailable.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxSurge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxSurge.Set {
			e.RawStr("\"maxSurge\"" + ":")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDeployment = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDeployment to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			s.MaxSurge.Reset()
			if err := s.MaxSurge.Decode(d); err != nil {
				return err
			}
		case "maxUnavailable":
			s.MaxUnavailable.Reset()
			if err := s.MaxUnavailable.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy = [1]string{
	0: "partition",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "partition":
			s.Partition.Reset()
			if err := s.Partition.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1StatefulSet from json.
func (s *IoK8sAPIAppsV1StatefulSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSet to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetCondition from json.
func (s *IoK8sAPIAppsV1StatefulSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSetCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetList from json.
func (s *IoK8sAPIAppsV1StatefulSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1StatefulSet
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.PodManagementPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodManagementPolicy.Set {
			e.RawStr("\"podManagementPolicy\"" + ":")
			s.PodManagementPolicy.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RevisionHistoryLimit.Set {
			e.RawStr("\"revisionHistoryLimit\"" + ":")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selector\"" + ":")
		s.Selector.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"serviceName\"" + ":")
		e.Str(s.ServiceName)
	}
	{
		e.Comma()

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.Comma()
		}
		if s.UpdateStrategy.Set {
			e.RawStr("\"updateStrategy\"" + ":")
			s.UpdateStrategy.Encode(e)
		}
	}
	{
		if s.VolumeClaimTemplates != nil {
			e.Comma()
		}
		if s.VolumeClaimTemplates != nil {
			e.RawStr("\"volumeClaimTemplates\"" + ":")
			e.ArrStart()
			if len(s.VolumeClaimTemplates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeClaimTemplates[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeClaimTemplates[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec = [9]string{
	0: "minReadySeconds",
	1: "podManagementPolicy",
	2: "replicas",
	3: "revisionHistoryLimit",
	4: "selector",
	5: "serviceName",
	6: "template",
	7: "updateStrategy",
	8: "volumeClaimTemplates",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (s *IoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSetSpec to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			s.MinReadySeconds.Reset()
			if err := s.MinReadySeconds.Decode(d); err != nil {
				return err
			}
		case "podManagementPolicy":
			s.PodManagementPolicy.Reset()
			if err := s.PodManagementPolicy.Decode(d); err != nil {
				return err
			}
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		case "revisionHistoryLimit":
			s.RevisionHistoryLimit.Reset()
			if err := s.RevisionHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "selector":
			requiredBitSet[0] |= 1 << 4
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "serviceName":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.ServiceName = string(v)
			if err != nil {
				return err
			}
		case "template":
			requiredBitSet[0] |= 1 << 6
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		case "updateStrategy":
			s.UpdateStrategy.Reset()
			if err := s.UpdateStrategy.Decode(d); err != nil {
				return err
			}
		case "volumeClaimTemplates":
			s.VolumeClaimTemplates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PersistentVolumeClaim
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumeClaimTemplates = append(s.VolumeClaimTemplates, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"availableReplicas\"" + ":")
		e.Int32(s.AvailableReplicas)
	}
	{
		if s.CollisionCount.Set {
			e.Comma()
		}
		if s.CollisionCount.Set {
			e.RawStr("\"collisionCount\"" + ":")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.Comma()
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.CurrentReplicas.Set {
			e.Comma()
		}
		if s.CurrentReplicas.Set {
			e.RawStr("\"currentReplicas\"" + ":")
			s.CurrentReplicas.Encode(e)
		}
	}
	{
		if s.CurrentRevision.Set {
			e.Comma()
		}
		if s.CurrentRevision.Set {
			e.RawStr("\"currentRevision\"" + ":")
			s.CurrentRevision.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.Comma()
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	{
		if s.UpdateRevision.Set {
			e.Comma()
		}
		if s.UpdateRevision.Set {
			e.RawStr("\"updateRevision\"" + ":")
			s.UpdateRevision.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			e.Comma()
		}
		if s.UpdatedReplicas.Set {
			e.RawStr("\"updatedReplicas\"" + ":")
			s.UpdatedReplicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus = [10]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "currentReplicas",
	4: "currentRevision",
	5: "observedGeneration",
	6: "readyReplicas",
	7: "replicas",
	8: "updateRevision",
	9: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (s *IoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSetStatus to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.AvailableReplicas = int32(v)
			if err != nil {
				return err
			}
		case "collisionCount":
			s.CollisionCount.Reset()
			if err := s.CollisionCount.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAppsV1StatefulSetCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentReplicas":
			s.CurrentReplicas.Reset()
			if err := s.CurrentReplicas.Decode(d); err != nil {
				return err
			}
		case "currentRevision":
			s.CurrentRevision.Reset()
			if err := s.CurrentRevision.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "readyReplicas":
			s.ReadyReplicas.Reset()
			if err := s.ReadyReplicas.Decode(d); err != nil {
				return err
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Int32()
			s.Replicas = int32(v)
			if err != nil {
				return err
			}
		case "updateRevision":
			s.UpdateRevision.Reset()
			if err := s.UpdateRevision.Decode(d); err != nil {
				return err
			}
		case "updatedReplicas":
			s.UpdatedReplicas.Reset()
			if err := s.UpdatedReplicas.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.RollingUpdate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RollingUpdate.Set {
			e.RawStr("\"rollingUpdate\"" + ":")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAppsV1StatefulSetUpdateStrategy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			s.RollingUpdate.Reset()
			if err := s.RollingUpdate.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1CrossVersionObjectReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscaler to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	{
		if s.TargetCPUUtilizationPercentage.Set {
			e.Comma()
		}
		if s.TargetCPUUtilizationPercentage.Set {
			e.RawStr("\"targetCPUUtilizationPercentage\"" + ":")
			s.TargetCPUUtilizationPercentage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "minReplicas",
	2: "scaleTargetRef",
	3: "targetCPUUtilizationPercentage",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.MaxReplicas = int32(v)
			if err != nil {
				return err
			}
		case "minReplicas":
			s.MinReplicas.Reset()
			if err := s.MinReplicas.Decode(d); err != nil {
				return err
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 2
			if err := s.ScaleTargetRef.Decode(d); err != nil {
				return err
			}
		case "targetCPUUtilizationPercentage":
			s.TargetCPUUtilizationPercentage.Reset()
			if err := s.TargetCPUUtilizationPercentage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentCPUUtilizationPercentage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentCPUUtilizationPercentage.Set {
			e.RawStr("\"currentCPUUtilizationPercentage\"" + ":")
			s.CurrentCPUUtilizationPercentage.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus = [5]string{
	0: "currentCPUUtilizationPercentage",
	1: "currentReplicas",
	2: "desiredReplicas",
	3: "lastScaleTime",
	4: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentCPUUtilizationPercentage":
			s.CurrentCPUUtilizationPercentage.Reset()
			if err := s.CurrentCPUUtilizationPercentage.Decode(d); err != nil {
				return err
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.CurrentReplicas = int32(v)
			if err != nil {
				return err
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.DesiredReplicas = int32(v)
			if err != nil {
				return err
			}
		case "lastScaleTime":
			s.LastScaleTime.Reset()
			if err := s.LastScaleTime.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1Scale) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1Scale = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1Scale from json.
func (s *IoK8sAPIAutoscalingV1Scale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1Scale to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleSpec = [1]string{
	0: "replicas",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1ScaleSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus = [2]string{
	0: "replicas",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV1ScaleStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.Replicas = int32(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.Comma()
		}
		if s.TargetAverageUtilization.Set {
			e.RawStr("\"targetAverageUtilization\"" + ":")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource = [4]string{
	0: "container",
	1: "name",
	2: "targetAverageUtilization",
	3: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Container = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "targetAverageUtilization":
			s.TargetAverageUtilization.Reset()
			if err := s.TargetAverageUtilization.Decode(d); err != nil {
				return err
			}
		case "targetAverageValue":
			s.TargetAverageValue.Reset()
			if err := s.TargetAverageValue.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		if s.CurrentAverageUtilization.Set {
			e.Comma()
		}
		if s.CurrentAverageUtilization.Set {
			e.RawStr("\"currentAverageUtilization\"" + ":")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus = [4]string{
	0: "container",
	1: "currentAverageUtilization",
	2: "currentAverageValue",
	3: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Container = string(v)
			if err != nil {
				return err
			}
		case "currentAverageUtilization":
			s.CurrentAverageUtilization.Reset()
			if err := s.CurrentAverageUtilization.Decode(d); err != nil {
				return err
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 2
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CurrentAverageValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.Comma()
		}
		if s.MetricSelector.Set {
			e.RawStr("\"metricSelector\"" + ":")
			s.MetricSelector.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	{
		if s.TargetValue.Set {
			e.Comma()
		}
		if s.TargetValue.Set {
			e.RawStr("\"targetValue\"" + ":")
			s.TargetValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource = [4]string{
	0: "metricName",
	1: "metricSelector",
	2: "targetAverageValue",
	3: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "metricSelector":
			s.MetricSelector.Reset()
			if err := s.MetricSelector.Decode(d); err != nil {
				return err
			}
		case "targetAverageValue":
			s.TargetAverageValue.Reset()
			if err := s.TargetAverageValue.Decode(d); err != nil {
				return err
			}
		case "targetValue":
			s.TargetValue.Reset()
			if err := s.TargetValue.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentAverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentAverageValue.Set {
			e.RawStr("\"currentAverageValue\"" + ":")
			s.CurrentAverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentValue\"" + ":")
		s.CurrentValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.Comma()
		}
		if s.MetricSelector.Set {
			e.RawStr("\"metricSelector\"" + ":")
			s.MetricSelector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus = [4]string{
	0: "currentAverageValue",
	1: "currentValue",
	2: "metricName",
	3: "metricSelector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			s.CurrentAverageValue.Reset()
			if err := s.CurrentAverageValue.Decode(d); err != nil {
				return err
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CurrentValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "metricSelector":
			s.MetricSelector.Reset()
			if err := s.MetricSelector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.Comma()
		}
		if s.Metrics != nil {
			e.RawStr("\"metrics\"" + ":")
			e.ArrStart()
			if len(s.Metrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Metrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.Metrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "metrics",
	2: "minReplicas",
	3: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.MaxReplicas = int32(v)
			if err != nil {
				return err
			}
		case "metrics":
			s.Metrics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta1MetricSpec
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metrics = append(s.Metrics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "minReplicas":
			s.MinReplicas.Reset()
			if err := s.MinReplicas.Decode(d); err != nil {
				return err
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 3
			if err := s.ScaleTargetRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.Comma()
		}
		if s.CurrentMetrics != nil {
			e.RawStr("\"currentMetrics\"" + ":")
			e.ArrStart()
			if len(s.CurrentMetrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentMetrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentMetrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentMetrics":
			s.CurrentMetrics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta1MetricStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CurrentMetrics = append(s.CurrentMetrics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.CurrentReplicas = int32(v)
			if err != nil {
				return err
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int32()
			s.DesiredReplicas = int32(v)
			if err != nil {
				return err
			}
		case "lastScaleTime":
			s.LastScaleTime.Reset()
			if err := s.LastScaleTime.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1MetricSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			s.ContainerResource.Reset()
			if err := s.ContainerResource.Decode(d); err != nil {
				return err
			}
		case "external":
			s.External.Reset()
			if err := s.External.Decode(d); err != nil {
				return err
			}
		case "object":
			s.Object.Reset()
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "pods":
			s.Pods.Reset()
			if err := s.Pods.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1MetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			s.ContainerResource.Reset()
			if err := s.ContainerResource.Decode(d); err != nil {
				return err
			}
		case "external":
			s.External.Reset()
			if err := s.External.Decode(d); err != nil {
				return err
			}
		case "object":
			s.Object.Reset()
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "pods":
			s.Pods.Reset()
			if err := s.Pods.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"targetValue\"" + ":")
		s.TargetValue.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource = [5]string{
	0: "averageValue",
	1: "metricName",
	2: "selector",
	3: "target",
	4: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			s.AverageValue.Reset()
			if err := s.AverageValue.Decode(d); err != nil {
				return err
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 3
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		case "targetValue":
			requiredBitSet[0] |= 1 << 4
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.TargetValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentValue\"" + ":")
		s.CurrentValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus = [5]string{
	0: "averageValue",
	1: "currentValue",
	2: "metricName",
	3: "selector",
	4: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			s.AverageValue.Reset()
			if err := s.AverageValue.Decode(d); err != nil {
				return err
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CurrentValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 4
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetAverageValue\"" + ":")
		s.TargetAverageValue.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource = [3]string{
	0: "metricName",
	1: "selector",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "targetAverageValue":
			requiredBitSet[0] |= 1 << 2
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.TargetAverageValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metricName\"" + ":")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus = [3]string{
	0: "currentAverageValue",
	1: "metricName",
	2: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 0
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CurrentAverageValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.MetricName = string(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.Comma()
		}
		if s.TargetAverageUtilization.Set {
			e.RawStr("\"targetAverageUtilization\"" + ":")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.Comma()
		}
		if s.TargetAverageValue.Set {
			e.RawStr("\"targetAverageValue\"" + ":")
			s.TargetAverageValue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource = [3]string{
	0: "name",
	1: "targetAverageUtilization",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "targetAverageUtilization":
			s.TargetAverageUtilization.Reset()
			if err := s.TargetAverageUtilization.Decode(d); err != nil {
				return err
			}
		case "targetAverageValue":
			s.TargetAverageValue.Reset()
			if err := s.TargetAverageValue.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CurrentAverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CurrentAverageUtilization.Set {
			e.RawStr("\"currentAverageUtilization\"" + ":")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentAverageValue\"" + ":")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus = [3]string{
	0: "currentAverageUtilization",
	1: "currentAverageValue",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageUtilization":
			s.CurrentAverageUtilization.Reset()
			if err := s.CurrentAverageUtilization.Decode(d); err != nil {
				return err
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CurrentAverageValue = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource = [3]string{
	0: "container",
	1: "name",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Container = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"container\"" + ":")
		e.Str(s.Container)
	}
	{
		e.Comma()

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus = [3]string{
	0: "container",
	1: "current",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Container = string(v)
			if err != nil {
				return err
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := s.Current.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := s.Current.Decode(d); err != nil {
				return err
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"periodSeconds\"" + ":")
		e.Int32(s.PeriodSeconds)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Int32(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy = [3]string{
	0: "periodSeconds",
	1: "type",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingPolicy from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingPolicy to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "periodSeconds":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.PeriodSeconds = int32(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.Value = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Policies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Policies != nil {
			e.RawStr("\"policies\"" + ":")
			e.ArrStart()
			if len(s.Policies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Policies[0]
					elem.Encode(e)
				}
				for _, elem := range s.Policies[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SelectPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelectPolicy.Set {
			e.RawStr("\"selectPolicy\"" + ":")
			s.SelectPolicy.Encode(e)
		}
	}
	{
		if s.StabilizationWindowSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StabilizationWindowSeconds.Set {
			e.RawStr("\"stabilizationWindowSeconds\"" + ":")
			s.StabilizationWindowSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingRules = [3]string{
	0: "policies",
	1: "selectPolicy",
	2: "stabilizationWindowSeconds",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingRules to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "policies":
			s.Policies = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Policies = append(s.Policies, elem)
				return nil
			}); err != nil {
				return err
			}
		case "selectPolicy":
			s.SelectPolicy.Reset()
			if err := s.SelectPolicy.Decode(d); err != nil {
				return err
			}
		case "stabilizationWindowSeconds":
			s.StabilizationWindowSeconds.Reset()
			if err := s.StabilizationWindowSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ScaleDown.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleDown.Set {
			e.RawStr("\"scaleDown\"" + ":")
			s.ScaleDown.Encode(e)
		}
	}
	{
		if s.ScaleUp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleUp.Set {
			e.RawStr("\"scaleUp\"" + ":")
			s.ScaleUp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior = [2]string{
	0: "scaleDown",
	1: "scaleUp",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scaleDown":
			s.ScaleDown.Reset()
			if err := s.ScaleDown.Decode(d); err != nil {
				return err
			}
		case "scaleUp":
			s.ScaleUp.Reset()
			if err := s.ScaleUp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Behavior.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Behavior.Set {
			e.RawStr("\"behavior\"" + ":")
			s.Behavior.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxReplicas\"" + ":")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.Comma()
		}
		if s.Metrics != nil {
			e.RawStr("\"metrics\"" + ":")
			e.ArrStart()
			if len(s.Metrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Metrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.Metrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.Comma()
		}
		if s.MinReplicas.Set {
			e.RawStr("\"minReplicas\"" + ":")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scaleTargetRef\"" + ":")
		s.ScaleTargetRef.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec = [5]string{
	0: "behavior",
	1: "maxReplicas",
	2: "metrics",
	3: "minReplicas",
	4: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "behavior":
			s.Behavior.Reset()
			if err := s.Behavior.Decode(d); err != nil {
				return err
			}
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.MaxReplicas = int32(v)
			if err != nil {
				return err
			}
		case "metrics":
			s.Metrics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta2MetricSpec
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metrics = append(s.Metrics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "minReplicas":
			s.MinReplicas.Reset()
			if err := s.MinReplicas.Decode(d); err != nil {
				return err
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 4
			if err := s.ScaleTargetRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.Comma()
		}
		if s.CurrentMetrics != nil {
			e.RawStr("\"currentMetrics\"" + ":")
			e.ArrStart()
			if len(s.CurrentMetrics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentMetrics[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentMetrics[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"currentReplicas\"" + ":")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.Comma()

		e.RawStr("\"desiredReplicas\"" + ":")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.Comma()
		}
		if s.LastScaleTime.Set {
			e.RawStr("\"lastScaleTime\"" + ":")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentMetrics":
			s.CurrentMetrics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIAutoscalingV2beta2MetricStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CurrentMetrics = append(s.CurrentMetrics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.CurrentReplicas = int32(v)
			if err != nil {
				return err
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int32()
			s.DesiredReplicas = int32(v)
			if err != nil {
				return err
			}
		case "lastScaleTime":
			s.LastScaleTime.Reset()
			if err := s.LastScaleTime.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricIdentifier) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Selector.Set {
			e.Comma()
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier = [2]string{
	0: "name",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricIdentifier from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricIdentifier to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			s.ContainerResource.Reset()
			if err := s.ContainerResource.Decode(d); err != nil {
				return err
			}
		case "external":
			s.External.Reset()
			if err := s.External.Decode(d); err != nil {
				return err
			}
		case "object":
			s.Object.Reset()
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "pods":
			s.Pods.Reset()
			if err := s.Pods.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerResource.Set {
			e.RawStr("\"containerResource\"" + ":")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.External.Set {
			e.RawStr("\"external\"" + ":")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Object.Set {
			e.RawStr("\"object\"" + ":")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pods.Set {
			e.RawStr("\"pods\"" + ":")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			s.ContainerResource.Reset()
			if err := s.ContainerResource.Decode(d); err != nil {
				return err
			}
		case "external":
			s.External.Reset()
			if err := s.External.Decode(d); err != nil {
				return err
			}
		case "object":
			s.Object.Reset()
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "pods":
			s.Pods.Reset()
			if err := s.Pods.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricTarget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageUtilization.Set {
			e.RawStr("\"averageUtilization\"" + ":")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget = [4]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "type",
	3: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricTarget from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricTarget to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			s.AverageUtilization.Reset()
			if err := s.AverageUtilization.Decode(d); err != nil {
				return err
			}
		case "averageValue":
			s.AverageValue.Reset()
			if err := s.AverageValue.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2MetricValueStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AverageUtilization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageUtilization.Set {
			e.RawStr("\"averageUtilization\"" + ":")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AverageValue.Set {
			e.RawStr("\"averageValue\"" + ":")
			s.AverageValue.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricValueStatus = [3]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricValueStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricValueStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			s.AverageUtilization.Reset()
			if err := s.AverageUtilization.Decode(d); err != nil {
				return err
			}
		case "averageValue":
			s.AverageValue.Reset()
			if err := s.AverageValue.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"describedObject\"" + ":")
		s.DescribedObject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource = [3]string{
	0: "describedObject",
	1: "metric",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "describedObject":
			requiredBitSet[0] |= 1 << 0
			if err := s.DescribedObject.Decode(d); err != nil {
				return err
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"describedObject\"" + ":")
		s.DescribedObject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus = [3]string{
	0: "current",
	1: "describedObject",
	2: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := s.Current.Decode(d); err != nil {
				return err
			}
		case "describedObject":
			requiredBitSet[0] |= 1 << 1
			if err := s.DescribedObject.Decode(d); err != nil {
				return err
			}
		case "metric":
			requiredBitSet[0] |= 1 << 2
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"metric\"" + ":")
		s.Metric.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := s.Current.Decode(d); err != nil {
				return err
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := s.Metric.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"target\"" + ":")
		s.Target.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource = [2]string{
	0: "name",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current\"" + ":")
		s.Current.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus = [2]string{
	0: "current",
	1: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := s.Current.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1CronJob from json.
func (s *IoK8sAPIBatchV1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1CronJob to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1CronJobList from json.
func (s *IoK8sAPIBatchV1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1CronJobList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIBatchV1CronJob
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConcurrencyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConcurrencyPolicy.Set {
			e.RawStr("\"concurrencyPolicy\"" + ":")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailedJobsHistoryLimit.Set {
			e.RawStr("\"failedJobsHistoryLimit\"" + ":")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jobTemplate\"" + ":")
		s.JobTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"schedule\"" + ":")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.Comma()
		}
		if s.StartingDeadlineSeconds.Set {
			e.RawStr("\"startingDeadlineSeconds\"" + ":")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.Comma()
		}
		if s.SuccessfulJobsHistoryLimit.Set {
			e.RawStr("\"successfulJobsHistoryLimit\"" + ":")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.Comma()
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (s *IoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1CronJobSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			s.ConcurrencyPolicy.Reset()
			if err := s.ConcurrencyPolicy.Decode(d); err != nil {
				return err
			}
		case "failedJobsHistoryLimit":
			s.FailedJobsHistoryLimit.Reset()
			if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := s.JobTemplate.Decode(d); err != nil {
				return err
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Schedule = string(v)
			if err != nil {
				return err
			}
		case "startingDeadlineSeconds":
			s.StartingDeadlineSeconds.Reset()
			if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
				return err
			}
		case "successfulJobsHistoryLimit":
			s.SuccessfulJobsHistoryLimit.Reset()
			if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "suspend":
			s.Suspend.Reset()
			if err := s.Suspend.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active != nil {
			e.RawStr("\"active\"" + ":")
			e.ArrStart()
			if len(s.Active) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Active[0]
					elem.Encode(e)
				}
				for _, elem := range s.Active[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastScheduleTime.Set {
			e.RawStr("\"lastScheduleTime\"" + ":")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastSuccessfulTime.Set {
			e.RawStr("\"lastSuccessfulTime\"" + ":")
			s.LastSuccessfulTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (s *IoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1CronJobStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			s.Active = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ObjectReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Active = append(s.Active, elem)
				return nil
			}); err != nil {
				return err
			}
		case "lastScheduleTime":
			s.LastScheduleTime.Reset()
			if err := s.LastScheduleTime.Decode(d); err != nil {
				return err
			}
		case "lastSuccessfulTime":
			s.LastSuccessfulTime.Reset()
			if err := s.LastSuccessfulTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1Job) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1Job = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1Job from json.
func (s *IoK8sAPIBatchV1Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1Job to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIBatchV1JobCondition from json.
func (s *IoK8sAPIBatchV1JobCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1JobCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			s.LastProbeTime.Reset()
			if err := s.LastProbeTime.Decode(d); err != nil {
				return err
			}
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobCondition) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1JobList from json.
func (s *IoK8sAPIBatchV1JobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1JobList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIBatchV1Job
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ActiveDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveDeadlineSeconds.Set {
			e.RawStr("\"activeDeadlineSeconds\"" + ":")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.BackoffLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BackoffLimit.Set {
			e.RawStr("\"backoffLimit\"" + ":")
			s.BackoffLimit.Encode(e)
		}
	}
	{
		if s.CompletionMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletionMode.Set {
			e.RawStr("\"completionMode\"" + ":")
			s.CompletionMode.Encode(e)
		}
	}
	{
		if s.Completions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Completions.Set {
			e.RawStr("\"completions\"" + ":")
			s.Completions.Encode(e)
		}
	}
	{
		if s.ManualSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ManualSelector.Set {
			e.RawStr("\"manualSelector\"" + ":")
			s.ManualSelector.Encode(e)
		}
	}
	{
		if s.Parallelism.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parallelism.Set {
			e.RawStr("\"parallelism\"" + ":")
			s.Parallelism.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"template\"" + ":")
		s.Template.Encode(e)
	}
	{
		if s.TtlSecondsAfterFinished.Set {
			e.Comma()
		}
		if s.TtlSecondsAfterFinished.Set {
			e.RawStr("\"ttlSecondsAfterFinished\"" + ":")
			s.TtlSecondsAfterFinished.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobSpec = [10]string{
	0: "activeDeadlineSeconds",
	1: "backoffLimit",
	2: "completionMode",
	3: "completions",
	4: "manualSelector",
	5: "parallelism",
	6: "selector",
	7: "suspend",
	8: "template",
	9: "ttlSecondsAfterFinished",
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (s *IoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1JobSpec to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			s.ActiveDeadlineSeconds.Reset()
			if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
				return err
			}
		case "backoffLimit":
			s.BackoffLimit.Reset()
			if err := s.BackoffLimit.Decode(d); err != nil {
				return err
			}
		case "completionMode":
			s.CompletionMode.Reset()
			if err := s.CompletionMode.Decode(d); err != nil {
				return err
			}
		case "completions":
			s.Completions.Reset()
			if err := s.Completions.Decode(d); err != nil {
				return err
			}
		case "manualSelector":
			s.ManualSelector.Reset()
			if err := s.ManualSelector.Decode(d); err != nil {
				return err
			}
		case "parallelism":
			s.Parallelism.Reset()
			if err := s.Parallelism.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "suspend":
			s.Suspend.Reset()
			if err := s.Suspend.Decode(d); err != nil {
				return err
			}
		case "template":
			requiredBitSet[1] |= 1 << 0
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		case "ttlSecondsAfterFinished":
			s.TtlSecondsAfterFinished.Reset()
			if err := s.TtlSecondsAfterFinished.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.CompletedIndexes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletedIndexes.Set {
			e.RawStr("\"completedIndexes\"" + ":")
			s.CompletedIndexes.Encode(e)
		}
	}
	{
		if s.CompletionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompletionTime.Set {
			e.RawStr("\"completionTime\"" + ":")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Failed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Failed.Set {
			e.RawStr("\"failed\"" + ":")
			s.Failed.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartTime.Set {
			e.RawStr("\"startTime\"" + ":")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Succeeded.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Succeeded.Set {
			e.RawStr("\"succeeded\"" + ":")
			s.Succeeded.Encode(e)
		}
	}
	{
		if s.UncountedTerminatedPods.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UncountedTerminatedPods.Set {
			e.RawStr("\"uncountedTerminatedPods\"" + ":")
			s.UncountedTerminatedPods.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobStatus = [8]string{
	0: "active",
	1: "completedIndexes",
	2: "completionTime",
	3: "conditions",
	4: "failed",
	5: "startTime",
	6: "succeeded",
	7: "uncountedTerminatedPods",
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (s *IoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1JobStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "completedIndexes":
			s.CompletedIndexes.Reset()
			if err := s.CompletedIndexes.Decode(d); err != nil {
				return err
			}
		case "completionTime":
			s.CompletionTime.Reset()
			if err := s.CompletionTime.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIBatchV1JobCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "failed":
			s.Failed.Reset()
			if err := s.Failed.Decode(d); err != nil {
				return err
			}
		case "startTime":
			s.StartTime.Reset()
			if err := s.StartTime.Decode(d); err != nil {
				return err
			}
		case "succeeded":
			s.Succeeded.Reset()
			if err := s.Succeeded.Decode(d); err != nil {
				return err
			}
		case "uncountedTerminatedPods":
			s.UncountedTerminatedPods.Reset()
			if err := s.UncountedTerminatedPods.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1JobTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1JobTemplateSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Failed != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Failed != nil {
			e.RawStr("\"failed\"" + ":")
			e.ArrStart()
			if len(s.Failed) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Failed[0]
					e.Str(elem)
				}
				for _, elem := range s.Failed[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Succeeded != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Succeeded != nil {
			e.RawStr("\"succeeded\"" + ":")
			e.ArrStart()
			if len(s.Succeeded) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Succeeded[0]
					e.Str(elem)
				}
				for _, elem := range s.Succeeded[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1UncountedTerminatedPods = [2]string{
	0: "failed",
	1: "succeeded",
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1UncountedTerminatedPods to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failed":
			s.Failed = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Failed = append(s.Failed, elem)
				return nil
			}); err != nil {
				return err
			}
		case "succeeded":
			s.Succeeded = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Succeeded = append(s.Succeeded, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJob from json.
func (s *IoK8sAPIBatchV1beta1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1beta1CronJob to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobList from json.
func (s *IoK8sAPIBatchV1beta1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1beta1CronJobList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIBatchV1beta1CronJob
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConcurrencyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConcurrencyPolicy.Set {
			e.RawStr("\"concurrencyPolicy\"" + ":")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailedJobsHistoryLimit.Set {
			e.RawStr("\"failedJobsHistoryLimit\"" + ":")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jobTemplate\"" + ":")
		s.JobTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"schedule\"" + ":")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.Comma()
		}
		if s.StartingDeadlineSeconds.Set {
			e.RawStr("\"startingDeadlineSeconds\"" + ":")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.Comma()
		}
		if s.SuccessfulJobsHistoryLimit.Set {
			e.RawStr("\"successfulJobsHistoryLimit\"" + ":")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.Comma()
		}
		if s.Suspend.Set {
			e.RawStr("\"suspend\"" + ":")
			s.Suspend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1beta1CronJobSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			s.ConcurrencyPolicy.Reset()
			if err := s.ConcurrencyPolicy.Decode(d); err != nil {
				return err
			}
		case "failedJobsHistoryLimit":
			s.FailedJobsHistoryLimit.Reset()
			if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := s.JobTemplate.Decode(d); err != nil {
				return err
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Schedule = string(v)
			if err != nil {
				return err
			}
		case "startingDeadlineSeconds":
			s.StartingDeadlineSeconds.Reset()
			if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
				return err
			}
		case "successfulJobsHistoryLimit":
			s.SuccessfulJobsHistoryLimit.Reset()
			if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
				return err
			}
		case "suspend":
			s.Suspend.Reset()
			if err := s.Suspend.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active != nil {
			e.RawStr("\"active\"" + ":")
			e.ArrStart()
			if len(s.Active) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Active[0]
					elem.Encode(e)
				}
				for _, elem := range s.Active[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastScheduleTime.Set {
			e.RawStr("\"lastScheduleTime\"" + ":")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastSuccessfulTime.Set {
			e.RawStr("\"lastSuccessfulTime\"" + ":")
			s.LastSuccessfulTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1beta1CronJobStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			s.Active = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ObjectReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Active = append(s.Active, elem)
				return nil
			}); err != nil {
				return err
			}
		case "lastScheduleTime":
			s.LastScheduleTime.Reset()
			if err := s.LastScheduleTime.Decode(d); err != nil {
				return err
			}
		case "lastSuccessfulTime":
			s.LastSuccessfulTime.Reset()
			if err := s.LastSuccessfulTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIBatchV1beta1JobTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1beta1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIBatchV1beta1JobTemplateSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequest from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequest to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastUpdateTime.Set {
			e.RawStr("\"lastUpdateTime\"" + ":")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestCondition from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "lastUpdateTime":
			s.LastUpdateTime.Reset()
			if err := s.LastUpdateTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestList from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICertificatesV1CertificateSigningRequest
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ExpirationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		if s.Extra.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Extra.Set {
			e.RawStr("\"extra\"" + ":")
			s.Extra.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"request\"" + ":")
		e.Base64(s.Request)
	}
	{
		e.Comma()

		e.RawStr("\"signerName\"" + ":")
		e.Str(s.SignerName)
	}
	{
		if s.UID.Set {
			e.Comma()
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	{
		if s.Usages != nil {
			e.Comma()
		}
		if s.Usages != nil {
			e.RawStr("\"usages\"" + ":")
			e.ArrStart()
			if len(s.Usages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Usages[0]
					e.Str(elem)
				}
				for _, elem := range s.Usages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec = [8]string{
	0: "expirationSeconds",
	1: "extra",
	2: "groups",
	3: "request",
	4: "signerName",
	5: "uid",
	6: "usages",
	7: "username",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpec from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expirationSeconds":
			s.ExpirationSeconds.Reset()
			if err := s.ExpirationSeconds.Decode(d); err != nil {
				return err
			}
		case "extra":
			s.Extra.Reset()
			if err := s.Extra.Decode(d); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "request":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Base64()
			s.Request = []byte(v)
			if err != nil {
				return err
			}
		case "signerName":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.SignerName = string(v)
			if err != nil {
				return err
			}
		case "uid":
			s.UID.Reset()
			if err := s.UID.Decode(d); err != nil {
				return err
			}
		case "usages":
			s.Usages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Usages = append(s.Usages, elem)
				return nil
			}); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"certificate\"" + ":")
		e.Base64(s.Certificate)
	}
	{
		if s.Conditions != nil {
			e.Comma()
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestStatus = [2]string{
	0: "certificate",
	1: "conditions",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			v, err := d.Base64()
			s.Certificate = []byte(v)
			if err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICertificatesV1CertificateSigningRequestCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1Lease) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1Lease = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoordinationV1Lease from json.
func (s *IoK8sAPICoordinationV1Lease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoordinationV1Lease to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1LeaseList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoordinationV1LeaseList from json.
func (s *IoK8sAPICoordinationV1LeaseList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoordinationV1LeaseList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoordinationV1Lease
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList) {
					name = jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AcquireTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AcquireTime.Set {
			e.RawStr("\"acquireTime\"" + ":")
			s.AcquireTime.Encode(e)
		}
	}
	{
		if s.HolderIdentity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HolderIdentity.Set {
			e.RawStr("\"holderIdentity\"" + ":")
			s.HolderIdentity.Encode(e)
		}
	}
	{
		if s.LeaseDurationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LeaseDurationSeconds.Set {
			e.RawStr("\"leaseDurationSeconds\"" + ":")
			s.LeaseDurationSeconds.Encode(e)
		}
	}
	{
		if s.LeaseTransitions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LeaseTransitions.Set {
			e.RawStr("\"leaseTransitions\"" + ":")
			s.LeaseTransitions.Encode(e)
		}
	}
	{
		if s.RenewTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RenewTime.Set {
			e.RawStr("\"renewTime\"" + ":")
			s.RenewTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseSpec = [5]string{
	0: "acquireTime",
	1: "holderIdentity",
	2: "leaseDurationSeconds",
	3: "leaseTransitions",
	4: "renewTime",
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (s *IoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoordinationV1LeaseSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acquireTime":
			s.AcquireTime.Reset()
			if err := s.AcquireTime.Decode(d); err != nil {
				return err
			}
		case "holderIdentity":
			s.HolderIdentity.Reset()
			if err := s.HolderIdentity.Decode(d); err != nil {
				return err
			}
		case "leaseDurationSeconds":
			s.LeaseDurationSeconds.Reset()
			if err := s.LeaseDurationSeconds.Decode(d); err != nil {
				return err
			}
		case "leaseTransitions":
			s.LeaseTransitions.Reset()
			if err := s.LeaseTransitions.Decode(d); err != nil {
				return err
			}
		case "renewTime":
			s.RenewTime.Reset()
			if err := s.RenewTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "readOnly",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "partition":
			s.Partition.Reset()
			if err := s.Partition.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.VolumeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Affinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeAffinity.Set {
			e.RawStr("\"nodeAffinity\"" + ":")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PodAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodAffinity.Set {
			e.RawStr("\"podAffinity\"" + ":")
			s.PodAffinity.Encode(e)
		}
	}
	{
		if s.PodAntiAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodAntiAffinity.Set {
			e.RawStr("\"podAntiAffinity\"" + ":")
			s.PodAntiAffinity.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Affinity = [3]string{
	0: "nodeAffinity",
	1: "podAffinity",
	2: "podAntiAffinity",
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (s *IoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Affinity to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeAffinity":
			s.NodeAffinity.Reset()
			if err := s.NodeAffinity.Decode(d); err != nil {
				return err
			}
		case "podAffinity":
			s.PodAffinity.Reset()
			if err := s.PodAffinity.Decode(d); err != nil {
				return err
			}
		case "podAntiAffinity":
			s.PodAntiAffinity.Reset()
			if err := s.PodAntiAffinity.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AttachedVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"devicePath\"" + ":")
		e.Str(s.DevicePath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1AttachedVolume from json.
func (s *IoK8sAPICoreV1AttachedVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1AttachedVolume to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.DevicePath = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CachingMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CachingMode.Set {
			e.RawStr("\"cachingMode\"" + ":")
			s.CachingMode.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diskName\"" + ":")
		e.Str(s.DiskName)
	}
	{
		e.Comma()

		e.RawStr("\"diskURI\"" + ":")
		e.Str(s.DiskURI)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource = [6]string{
	0: "cachingMode",
	1: "diskName",
	2: "diskURI",
	3: "fsType",
	4: "kind",
	5: "readOnly",
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1AzureDiskVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cachingMode":
			s.CachingMode.Reset()
			if err := s.CachingMode.Decode(d); err != nil {
				return err
			}
		case "diskName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.DiskName = string(v)
			if err != nil {
				return err
			}
		case "diskURI":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.DiskURI = string(v)
			if err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"secretName\"" + ":")
		e.Str(s.SecretName)
	}
	{
		if s.SecretNamespace.Set {
			e.Comma()
		}
		if s.SecretNamespace.Set {
			e.RawStr("\"secretNamespace\"" + ":")
			s.SecretNamespace.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"shareName\"" + ":")
		e.Str(s.ShareName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource = [4]string{
	0: "readOnly",
	1: "secretName",
	2: "secretNamespace",
	3: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1AzureFilePersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.SecretName = string(v)
			if err != nil {
				return err
			}
		case "secretNamespace":
			s.SecretNamespace.Reset()
			if err := s.SecretNamespace.Decode(d); err != nil {
				return err
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.ShareName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"secretName\"" + ":")
		e.Str(s.SecretName)
	}
	{
		e.Comma()

		e.RawStr("\"shareName\"" + ":")
		e.Str(s.ShareName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource = [3]string{
	0: "readOnly",
	1: "secretName",
	2: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1AzureFileVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.SecretName = string(v)
			if err != nil {
				return err
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.ShareName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ControllerExpandSecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ControllerExpandSecretRef.Set {
			e.RawStr("\"controllerExpandSecretRef\"" + ":")
			s.ControllerExpandSecretRef.Encode(e)
		}
	}
	{
		if s.ControllerPublishSecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ControllerPublishSecretRef.Set {
			e.RawStr("\"controllerPublishSecretRef\"" + ":")
			s.ControllerPublishSecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.Comma()
		}
		if s.NodePublishSecretRef.Set {
			e.RawStr("\"nodePublishSecretRef\"" + ":")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.NodeStageSecretRef.Set {
			e.Comma()
		}
		if s.NodeStageSecretRef.Set {
			e.RawStr("\"nodeStageSecretRef\"" + ":")
			s.NodeStageSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.Comma()
		}
		if s.VolumeAttributes.Set {
			e.RawStr("\"volumeAttributes\"" + ":")
			s.VolumeAttributes.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"volumeHandle\"" + ":")
		e.Str(s.VolumeHandle)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource = [9]string{
	0: "controllerExpandSecretRef",
	1: "controllerPublishSecretRef",
	2: "driver",
	3: "fsType",
	4: "nodePublishSecretRef",
	5: "nodeStageSecretRef",
	6: "readOnly",
	7: "volumeAttributes",
	8: "volumeHandle",
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CSIPersistentVolumeSource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controllerExpandSecretRef":
			s.ControllerExpandSecretRef.Reset()
			if err := s.ControllerExpandSecretRef.Decode(d); err != nil {
				return err
			}
		case "controllerPublishSecretRef":
			s.ControllerPublishSecretRef.Reset()
			if err := s.ControllerPublishSecretRef.Decode(d); err != nil {
				return err
			}
		case "driver":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Driver = string(v)
			if err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "nodePublishSecretRef":
			s.NodePublishSecretRef.Reset()
			if err := s.NodePublishSecretRef.Decode(d); err != nil {
				return err
			}
		case "nodeStageSecretRef":
			s.NodeStageSecretRef.Reset()
			if err := s.NodeStageSecretRef.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "volumeAttributes":
			s.VolumeAttributes.Reset()
			if err := s.VolumeAttributes.Decode(d); err != nil {
				return err
			}
		case "volumeHandle":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.VolumeHandle = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.Comma()
		}
		if s.NodePublishSecretRef.Set {
			e.RawStr("\"nodePublishSecretRef\"" + ":")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.Comma()
		}
		if s.VolumeAttributes.Set {
			e.RawStr("\"volumeAttributes\"" + ":")
			s.VolumeAttributes.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "nodePublishSecretRef",
	3: "readOnly",
	4: "volumeAttributes",
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (s *IoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CSIVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Driver = string(v)
			if err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "nodePublishSecretRef":
			s.NodePublishSecretRef.Reset()
			if err := s.NodePublishSecretRef.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "volumeAttributes":
			s.VolumeAttributes.Reset()
			if err := s.VolumeAttributes.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Capabilities) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Add != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Add != nil {
			e.RawStr("\"add\"" + ":")
			e.ArrStart()
			if len(s.Add) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Add[0]
					e.Str(elem)
				}
				for _, elem := range s.Add[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Drop != nil {
			e.RawStr("\"drop\"" + ":")
			e.ArrStart()
			if len(s.Drop) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Drop[0]
					e.Str(elem)
				}
				for _, elem := range s.Drop[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Capabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (s *IoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Capabilities to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			s.Add = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Add = append(s.Add, elem)
				return nil
			}); err != nil {
				return err
			}
		case "drop":
			s.Drop = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Drop = append(s.Drop, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.Comma()
		}
		if s.SecretFile.Set {
			e.RawStr("\"secretFile\"" + ":")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CephFSPersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			s.Monitors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Monitors = append(s.Monitors, elem)
				return nil
			}); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretFile":
			s.SecretFile.Reset()
			if err := s.SecretFile.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.Comma()
		}
		if s.SecretFile.Set {
			e.RawStr("\"secretFile\"" + ":")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CephFSVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			s.Monitors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Monitors = append(s.Monitors, elem)
				return nil
			}); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretFile":
			s.SecretFile.Reset()
			if err := s.SecretFile.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CinderPersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.VolumeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (s *IoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1CinderVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.VolumeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TimeoutSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ClientIPConfig = [1]string{
	0: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (s *IoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ClientIPConfig to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeoutSeconds":
			s.TimeoutSeconds.Reset()
			if err := s.TimeoutSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition = [4]string{
	0: "error",
	1: "message",
	2: "status",
	3: "type",
}

// Decode decodes IoK8sAPICoreV1ComponentCondition from json.
func (s *IoK8sAPICoreV1ComponentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ComponentCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			s.Error.Reset()
			if err := s.Error.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatus = [4]string{
	0: "apiVersion",
	1: "conditions",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatus from json.
func (s *IoK8sAPICoreV1ComponentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ComponentStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ComponentCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ComponentStatusList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatusList from json.
func (s *IoK8sAPICoreV1ComponentStatusList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ComponentStatusList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ComponentStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMap) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.BinaryData.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BinaryData.Set {
			e.RawStr("\"binaryData\"" + ":")
			s.BinaryData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Immutable.Set {
			e.RawStr("\"immutable\"" + ":")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMap = [6]string{
	0: "apiVersion",
	1: "binaryData",
	2: "data",
	3: "immutable",
	4: "kind",
	5: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMap from json.
func (s *IoK8sAPICoreV1ConfigMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMap to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "binaryData":
			s.BinaryData.Reset()
			if err := s.BinaryData.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data.Reset()
			if err := s.Data.Decode(d); err != nil {
				return err
			}
		case "immutable":
			s.Immutable.Reset()
			if err := s.Immutable.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapEnvSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.Comma()
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapKeySelector to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMapList from json.
func (s *IoK8sAPICoreV1ConfigMapList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ConfigMap
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kubeletConfigKey\"" + ":")
		e.Str(s.KubeletConfigKey)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.ResourceVersion.Set {
			e.Comma()
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.Comma()
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource = [5]string{
	0: "kubeletConfigKey",
	1: "name",
	2: "namespace",
	3: "resourceVersion",
	4: "uid",
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapNodeConfigSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletConfigKey":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.KubeletConfigKey = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Namespace = string(v)
			if err != nil {
				return err
			}
		case "resourceVersion":
			s.ResourceVersion.Reset()
			if err := s.ResourceVersion.Decode(d); err != nil {
				return err
			}
		case "uid":
			s.UID.Reset()
			if err := s.UID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (s *IoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapProjection to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1KeyToPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "name",
	3: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ConfigMapVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			s.DefaultMode.Reset()
			if err := s.DefaultMode.Decode(d); err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1KeyToPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Container) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Args != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Args != nil {
			e.RawStr("\"args\"" + ":")
			e.ArrStart()
			if len(s.Args) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Args[0]
					e.Str(elem)
				}
				for _, elem := range s.Args[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Env != nil {
			e.RawStr("\"env\"" + ":")
			e.ArrStart()
			if len(s.Env) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Env[0]
					elem.Encode(e)
				}
				for _, elem := range s.Env[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnvFrom != nil {
			e.RawStr("\"envFrom\"" + ":")
			e.ArrStart()
			if len(s.EnvFrom) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EnvFrom[0]
					elem.Encode(e)
				}
				for _, elem := range s.EnvFrom[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Image.Set {
			e.RawStr("\"image\"" + ":")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullPolicy.Set {
			e.RawStr("\"imagePullPolicy\"" + ":")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lifecycle.Set {
			e.RawStr("\"lifecycle\"" + ":")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LivenessProbe.Set {
			e.RawStr("\"livenessProbe\"" + ":")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.Comma()
		}
		if s.ReadinessProbe.Set {
			e.RawStr("\"readinessProbe\"" + ":")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.Comma()
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.Comma()
		}
		if s.StartupProbe.Set {
			e.RawStr("\"startupProbe\"" + ":")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.Comma()
		}
		if s.Stdin.Set {
			e.RawStr("\"stdin\"" + ":")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.Comma()
		}
		if s.StdinOnce.Set {
			e.RawStr("\"stdinOnce\"" + ":")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.Comma()
		}
		if s.TerminationMessagePath.Set {
			e.RawStr("\"terminationMessagePath\"" + ":")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.Comma()
		}
		if s.TerminationMessagePolicy.Set {
			e.RawStr("\"terminationMessagePolicy\"" + ":")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.Comma()
		}
		if s.Tty.Set {
			e.RawStr("\"tty\"" + ":")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.Comma()
		}
		if s.VolumeDevices != nil {
			e.RawStr("\"volumeDevices\"" + ":")
			e.ArrStart()
			if len(s.VolumeDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.Comma()
		}
		if s.VolumeMounts != nil {
			e.RawStr("\"volumeMounts\"" + ":")
			e.ArrStart()
			if len(s.VolumeMounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeMounts[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeMounts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.Comma()
		}
		if s.WorkingDir.Set {
			e.RawStr("\"workingDir\"" + ":")
			s.WorkingDir.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Container = [22]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "terminationMessagePath",
	17: "terminationMessagePolicy",
	18: "tty",
	19: "volumeDevices",
	20: "volumeMounts",
	21: "workingDir",
}

// Decode decodes IoK8sAPICoreV1Container from json.
func (s *IoK8sAPICoreV1Container) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Container to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			s.Args = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Args = append(s.Args, elem)
				return nil
			}); err != nil {
				return err
			}
		case "command":
			s.Command = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Command = append(s.Command, elem)
				return nil
			}); err != nil {
				return err
			}
		case "env":
			s.Env = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EnvVar
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Env = append(s.Env, elem)
				return nil
			}); err != nil {
				return err
			}
		case "envFrom":
			s.EnvFrom = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EnvFromSource
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EnvFrom = append(s.EnvFrom, elem)
				return nil
			}); err != nil {
				return err
			}
		case "image":
			s.Image.Reset()
			if err := s.Image.Decode(d); err != nil {
				return err
			}
		case "imagePullPolicy":
			s.ImagePullPolicy.Reset()
			if err := s.ImagePullPolicy.Decode(d); err != nil {
				return err
			}
		case "lifecycle":
			s.Lifecycle.Reset()
			if err := s.Lifecycle.Decode(d); err != nil {
				return err
			}
		case "livenessProbe":
			s.LivenessProbe.Reset()
			if err := s.LivenessProbe.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		case "readinessProbe":
			s.ReadinessProbe.Reset()
			if err := s.ReadinessProbe.Decode(d); err != nil {
				return err
			}
		case "resources":
			s.Resources.Reset()
			if err := s.Resources.Decode(d); err != nil {
				return err
			}
		case "securityContext":
			s.SecurityContext.Reset()
			if err := s.SecurityContext.Decode(d); err != nil {
				return err
			}
		case "startupProbe":
			s.StartupProbe.Reset()
			if err := s.StartupProbe.Decode(d); err != nil {
				return err
			}
		case "stdin":
			s.Stdin.Reset()
			if err := s.Stdin.Decode(d); err != nil {
				return err
			}
		case "stdinOnce":
			s.StdinOnce.Reset()
			if err := s.StdinOnce.Decode(d); err != nil {
				return err
			}
		case "terminationMessagePath":
			s.TerminationMessagePath.Reset()
			if err := s.TerminationMessagePath.Decode(d); err != nil {
				return err
			}
		case "terminationMessagePolicy":
			s.TerminationMessagePolicy.Reset()
			if err := s.TerminationMessagePolicy.Decode(d); err != nil {
				return err
			}
		case "tty":
			s.Tty.Reset()
			if err := s.Tty.Decode(d); err != nil {
				return err
			}
		case "volumeDevices":
			s.VolumeDevices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1VolumeDevice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumeDevices = append(s.VolumeDevices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "volumeMounts":
			s.VolumeMounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1VolumeMount
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumeMounts = append(s.VolumeMounts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "workingDir":
			s.WorkingDir.Reset()
			if err := s.WorkingDir.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Container) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Container[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerImage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Names != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Names != nil {
			e.RawStr("\"names\"" + ":")
			e.ArrStart()
			if len(s.Names) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Names[0]
					e.Str(elem)
				}
				for _, elem := range s.Names[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SizeBytes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SizeBytes.Set {
			e.RawStr("\"sizeBytes\"" + ":")
			s.SizeBytes.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerImage = [2]string{
	0: "names",
	1: "sizeBytes",
}

// Decode decodes IoK8sAPICoreV1ContainerImage from json.
func (s *IoK8sAPICoreV1ContainerImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerImage to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			s.Names = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Names = append(s.Names, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sizeBytes":
			s.SizeBytes.Reset()
			if err := s.SizeBytes.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"containerPort\"" + ":")
		e.Int32(s.ContainerPort)
	}
	{
		if s.HostIP.Set {
			e.Comma()
		}
		if s.HostIP.Set {
			e.RawStr("\"hostIP\"" + ":")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.HostPort.Set {
			e.Comma()
		}
		if s.HostPort.Set {
			e.RawStr("\"hostPort\"" + ":")
			s.HostPort.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerPort = [5]string{
	0: "containerPort",
	1: "hostIP",
	2: "hostPort",
	3: "name",
	4: "protocol",
}

// Decode decodes IoK8sAPICoreV1ContainerPort from json.
func (s *IoK8sAPICoreV1ContainerPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerPort to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerPort":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.ContainerPort = int32(v)
			if err != nil {
				return err
			}
		case "hostIP":
			s.HostIP.Reset()
			if err := s.HostIP.Decode(d); err != nil {
				return err
			}
		case "hostPort":
			s.HostPort.Reset()
			if err := s.HostPort.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerState) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Running.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Running.Set {
			e.RawStr("\"running\"" + ":")
			s.Running.Encode(e)
		}
	}
	{
		if s.Terminated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminated.Set {
			e.RawStr("\"terminated\"" + ":")
			s.Terminated.Encode(e)
		}
	}
	{
		if s.Waiting.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Waiting.Set {
			e.RawStr("\"waiting\"" + ":")
			s.Waiting.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerState = [3]string{
	0: "running",
	1: "terminated",
	2: "waiting",
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (s *IoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerState to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "running":
			s.Running.Reset()
			if err := s.Running.Decode(d); err != nil {
				return err
			}
		case "terminated":
			s.Terminated.Reset()
			if err := s.Terminated.Decode(d); err != nil {
				return err
			}
		case "waiting":
			s.Waiting.Reset()
			if err := s.Waiting.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.StartedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartedAt.Set {
			e.RawStr("\"startedAt\"" + ":")
			s.StartedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateRunning = [1]string{
	0: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (s *IoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerStateRunning to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startedAt":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerID.Set {
			e.RawStr("\"containerID\"" + ":")
			s.ContainerID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"exitCode\"" + ":")
		e.Int32(s.ExitCode)
	}
	{
		if s.FinishedAt.Set {
			e.Comma()
		}
		if s.FinishedAt.Set {
			e.RawStr("\"finishedAt\"" + ":")
			s.FinishedAt.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signal.Set {
			e.Comma()
		}
		if s.Signal.Set {
			e.RawStr("\"signal\"" + ":")
			s.Signal.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"startedAt\"" + ":")
			s.StartedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated = [7]string{
	0: "containerID",
	1: "exitCode",
	2: "finishedAt",
	3: "message",
	4: "reason",
	5: "signal",
	6: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (s *IoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerStateTerminated to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			s.ContainerID.Reset()
			if err := s.ContainerID.Decode(d); err != nil {
				return err
			}
		case "exitCode":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.ExitCode = int32(v)
			if err != nil {
				return err
			}
		case "finishedAt":
			s.FinishedAt.Reset()
			if err := s.FinishedAt.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "signal":
			s.Signal.Reset()
			if err := s.Signal.Decode(d); err != nil {
				return err
			}
		case "startedAt":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateWaiting = [2]string{
	0: "message",
	1: "reason",
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (s *IoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerStateWaiting to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ContainerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerID.Set {
			e.RawStr("\"containerID\"" + ":")
			s.ContainerID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		e.Comma()

		e.RawStr("\"imageID\"" + ":")
		e.Str(s.ImageID)
	}
	{
		if s.LastState.Set {
			e.Comma()
		}
		if s.LastState.Set {
			e.RawStr("\"lastState\"" + ":")
			s.LastState.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"ready\"" + ":")
		e.Bool(s.Ready)
	}
	{
		e.Comma()

		e.RawStr("\"restartCount\"" + ":")
		e.Int32(s.RestartCount)
	}
	{
		if s.Started.Set {
			e.Comma()
		}
		if s.Started.Set {
			e.RawStr("\"started\"" + ":")
			s.Started.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.Comma()
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus = [9]string{
	0: "containerID",
	1: "image",
	2: "imageID",
	3: "lastState",
	4: "name",
	5: "ready",
	6: "restartCount",
	7: "started",
	8: "state",
}

// Decode decodes IoK8sAPICoreV1ContainerStatus from json.
func (s *IoK8sAPICoreV1ContainerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ContainerStatus to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			s.ContainerID.Reset()
			if err := s.ContainerID.Decode(d); err != nil {
				return err
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Image = string(v)
			if err != nil {
				return err
			}
		case "imageID":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.ImageID = string(v)
			if err != nil {
				return err
			}
		case "lastState":
			s.LastState.Reset()
			if err := s.LastState.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "ready":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.Ready = bool(v)
			if err != nil {
				return err
			}
		case "restartCount":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.RestartCount = int32(v)
			if err != nil {
				return err
			}
		case "started":
			s.Started.Reset()
			if err := s.Started.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"Port\"" + ":")
		e.Int32(s.Port)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint = [1]string{
	0: "Port",
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (s *IoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1DaemonEndpoint to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Port":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.Port = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIProjection = [1]string{
	0: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (s *IoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1DownwardAPIProjection to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1DownwardAPIVolumeFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIVolumeFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldRef.Set {
			e.RawStr("\"fieldRef\"" + ":")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ResourceFieldRef.Set {
			e.Comma()
		}
		if s.ResourceFieldRef.Set {
			e.RawStr("\"resourceFieldRef\"" + ":")
			s.ResourceFieldRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile = [4]string{
	0: "fieldRef",
	1: "mode",
	2: "path",
	3: "resourceFieldRef",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeFile from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldRef":
			s.FieldRef.Reset()
			if err := s.FieldRef.Decode(d); err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "resourceFieldRef":
			s.ResourceFieldRef.Reset()
			if err := s.ResourceFieldRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeSource = [2]string{
	0: "defaultMode",
	1: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			s.DefaultMode.Reset()
			if err := s.DefaultMode.Decode(d); err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1DownwardAPIVolumeFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Medium.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Medium.Set {
			e.RawStr("\"medium\"" + ":")
			s.Medium.Encode(e)
		}
	}
	{
		if s.SizeLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SizeLimit.Set {
			e.RawStr("\"sizeLimit\"" + ":")
			s.SizeLimit.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EmptyDirVolumeSource = [2]string{
	0: "medium",
	1: "sizeLimit",
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EmptyDirVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "medium":
			s.Medium.Reset()
			if err := s.Medium.Decode(d); err != nil {
				return err
			}
		case "sizeLimit":
			s.SizeLimit.Reset()
			if err := s.SizeLimit.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointAddress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostname.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ip\"" + ":")
		e.Str(s.IP)
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress = [4]string{
	0: "hostname",
	1: "ip",
	2: "nodeName",
	3: "targetRef",
}

// Decode decodes IoK8sAPICoreV1EndpointAddress from json.
func (s *IoK8sAPICoreV1EndpointAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EndpointAddress to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			s.Hostname.Reset()
			if err := s.Hostname.Decode(d); err != nil {
				return err
			}
		case "ip":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.IP = string(v)
			if err != nil {
				return err
			}
		case "nodeName":
			s.NodeName.Reset()
			if err := s.NodeName.Decode(d); err != nil {
				return err
			}
		case "targetRef":
			s.TargetRef.Reset()
			if err := s.TargetRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPICoreV1EndpointPort from json.
func (s *IoK8sAPICoreV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EndpointPort to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			s.AppProtocol.Reset()
			if err := s.AppProtocol.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.Port = int32(v)
			if err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointSubset) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Addresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Addresses != nil {
			e.RawStr("\"addresses\"" + ":")
			e.ArrStart()
			if len(s.Addresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Addresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.Addresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NotReadyAddresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotReadyAddresses != nil {
			e.RawStr("\"notReadyAddresses\"" + ":")
			e.ArrStart()
			if len(s.NotReadyAddresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NotReadyAddresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.NotReadyAddresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointSubset = [3]string{
	0: "addresses",
	1: "notReadyAddresses",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1EndpointSubset from json.
func (s *IoK8sAPICoreV1EndpointSubset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EndpointSubset to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			s.Addresses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EndpointAddress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Addresses = append(s.Addresses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "notReadyAddresses":
			s.NotReadyAddresses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EndpointAddress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NotReadyAddresses = append(s.NotReadyAddresses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EndpointPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Endpoints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Subsets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subsets != nil {
			e.RawStr("\"subsets\"" + ":")
			e.ArrStart()
			if len(s.Subsets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subsets[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subsets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Endpoints = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "subsets",
}

// Decode decodes IoK8sAPICoreV1Endpoints from json.
func (s *IoK8sAPICoreV1Endpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Endpoints to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "subsets":
			s.Subsets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EndpointSubset
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subsets = append(s.Subsets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EndpointsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointsList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EndpointsList from json.
func (s *IoK8sAPICoreV1EndpointsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EndpointsList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Endpoints
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointsList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvFromSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMapRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMapRef.Set {
			e.RawStr("\"configMapRef\"" + ":")
			s.ConfigMapRef.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Prefix.Set {
			e.RawStr("\"prefix\"" + ":")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvFromSource = [3]string{
	0: "configMapRef",
	1: "prefix",
	2: "secretRef",
}

// Decode decodes IoK8sAPICoreV1EnvFromSource from json.
func (s *IoK8sAPICoreV1EnvFromSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EnvFromSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapRef":
			s.ConfigMapRef.Reset()
			if err := s.ConfigMapRef.Decode(d); err != nil {
				return err
			}
		case "prefix":
			s.Prefix.Reset()
			if err := s.Prefix.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvVar) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValueFrom.Set {
			e.Comma()
		}
		if s.ValueFrom.Set {
			e.RawStr("\"valueFrom\"" + ":")
			s.ValueFrom.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVar = [3]string{
	0: "name",
	1: "value",
	2: "valueFrom",
}

// Decode decodes IoK8sAPICoreV1EnvVar from json.
func (s *IoK8sAPICoreV1EnvVar) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EnvVar to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "valueFrom":
			s.ValueFrom.Reset()
			if err := s.ValueFrom.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EnvVar) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EnvVar[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EnvVarSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMapKeyRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMapKeyRef.Set {
			e.RawStr("\"configMapKeyRef\"" + ":")
			s.ConfigMapKeyRef.Encode(e)
		}
	}
	{
		if s.FieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldRef.Set {
			e.RawStr("\"fieldRef\"" + ":")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.ResourceFieldRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceFieldRef.Set {
			e.RawStr("\"resourceFieldRef\"" + ":")
			s.ResourceFieldRef.Encode(e)
		}
	}
	{
		if s.SecretKeyRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretKeyRef.Set {
			e.RawStr("\"secretKeyRef\"" + ":")
			s.SecretKeyRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVarSource = [4]string{
	0: "configMapKeyRef",
	1: "fieldRef",
	2: "resourceFieldRef",
	3: "secretKeyRef",
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (s *IoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EnvVarSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapKeyRef":
			s.ConfigMapKeyRef.Reset()
			if err := s.ConfigMapKeyRef.Decode(d); err != nil {
				return err
			}
		case "fieldRef":
			s.FieldRef.Reset()
			if err := s.FieldRef.Decode(d); err != nil {
				return err
			}
		case "resourceFieldRef":
			s.ResourceFieldRef.Reset()
			if err := s.ResourceFieldRef.Decode(d); err != nil {
				return err
			}
		case "secretKeyRef":
			s.SecretKeyRef.Reset()
			if err := s.SecretKeyRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EphemeralContainer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Args != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Args != nil {
			e.RawStr("\"args\"" + ":")
			e.ArrStart()
			if len(s.Args) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Args[0]
					e.Str(elem)
				}
				for _, elem := range s.Args[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Env != nil {
			e.RawStr("\"env\"" + ":")
			e.ArrStart()
			if len(s.Env) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Env[0]
					elem.Encode(e)
				}
				for _, elem := range s.Env[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnvFrom != nil {
			e.RawStr("\"envFrom\"" + ":")
			e.ArrStart()
			if len(s.EnvFrom) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EnvFrom[0]
					elem.Encode(e)
				}
				for _, elem := range s.EnvFrom[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Image.Set {
			e.RawStr("\"image\"" + ":")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullPolicy.Set {
			e.RawStr("\"imagePullPolicy\"" + ":")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lifecycle.Set {
			e.RawStr("\"lifecycle\"" + ":")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LivenessProbe.Set {
			e.RawStr("\"livenessProbe\"" + ":")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.Comma()
		}
		if s.ReadinessProbe.Set {
			e.RawStr("\"readinessProbe\"" + ":")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.Comma()
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.Comma()
		}
		if s.StartupProbe.Set {
			e.RawStr("\"startupProbe\"" + ":")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.Comma()
		}
		if s.Stdin.Set {
			e.RawStr("\"stdin\"" + ":")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.Comma()
		}
		if s.StdinOnce.Set {
			e.RawStr("\"stdinOnce\"" + ":")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TargetContainerName.Set {
			e.Comma()
		}
		if s.TargetContainerName.Set {
			e.RawStr("\"targetContainerName\"" + ":")
			s.TargetContainerName.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.Comma()
		}
		if s.TerminationMessagePath.Set {
			e.RawStr("\"terminationMessagePath\"" + ":")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.Comma()
		}
		if s.TerminationMessagePolicy.Set {
			e.RawStr("\"terminationMessagePolicy\"" + ":")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.Comma()
		}
		if s.Tty.Set {
			e.RawStr("\"tty\"" + ":")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.Comma()
		}
		if s.VolumeDevices != nil {
			e.RawStr("\"volumeDevices\"" + ":")
			e.ArrStart()
			if len(s.VolumeDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.Comma()
		}
		if s.VolumeMounts != nil {
			e.RawStr("\"volumeMounts\"" + ":")
			e.ArrStart()
			if len(s.VolumeMounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeMounts[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumeMounts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.Comma()
		}
		if s.WorkingDir.Set {
			e.RawStr("\"workingDir\"" + ":")
			s.WorkingDir.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer = [23]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "targetContainerName",
	17: "terminationMessagePath",
	18: "terminationMessagePolicy",
	19: "tty",
	20: "volumeDevices",
	21: "volumeMounts",
	22: "workingDir",
}

// Decode decodes IoK8sAPICoreV1EphemeralContainer from json.
func (s *IoK8sAPICoreV1EphemeralContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EphemeralContainer to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			s.Args = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Args = append(s.Args, elem)
				return nil
			}); err != nil {
				return err
			}
		case "command":
			s.Command = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Command = append(s.Command, elem)
				return nil
			}); err != nil {
				return err
			}
		case "env":
			s.Env = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EnvVar
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Env = append(s.Env, elem)
				return nil
			}); err != nil {
				return err
			}
		case "envFrom":
			s.EnvFrom = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EnvFromSource
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EnvFrom = append(s.EnvFrom, elem)
				return nil
			}); err != nil {
				return err
			}
		case "image":
			s.Image.Reset()
			if err := s.Image.Decode(d); err != nil {
				return err
			}
		case "imagePullPolicy":
			s.ImagePullPolicy.Reset()
			if err := s.ImagePullPolicy.Decode(d); err != nil {
				return err
			}
		case "lifecycle":
			s.Lifecycle.Reset()
			if err := s.Lifecycle.Decode(d); err != nil {
				return err
			}
		case "livenessProbe":
			s.LivenessProbe.Reset()
			if err := s.LivenessProbe.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		case "readinessProbe":
			s.ReadinessProbe.Reset()
			if err := s.ReadinessProbe.Decode(d); err != nil {
				return err
			}
		case "resources":
			s.Resources.Reset()
			if err := s.Resources.Decode(d); err != nil {
				return err
			}
		case "securityContext":
			s.SecurityContext.Reset()
			if err := s.SecurityContext.Decode(d); err != nil {
				return err
			}
		case "startupProbe":
			s.StartupProbe.Reset()
			if err := s.StartupProbe.Decode(d); err != nil {
				return err
			}
		case "stdin":
			s.Stdin.Reset()
			if err := s.Stdin.Decode(d); err != nil {
				return err
			}
		case "stdinOnce":
			s.StdinOnce.Reset()
			if err := s.StdinOnce.Decode(d); err != nil {
				return err
			}
		case "targetContainerName":
			s.TargetContainerName.Reset()
			if err := s.TargetContainerName.Decode(d); err != nil {
				return err
			}
		case "terminationMessagePath":
			s.TerminationMessagePath.Reset()
			if err := s.TerminationMessagePath.Decode(d); err != nil {
				return err
			}
		case "terminationMessagePolicy":
			s.TerminationMessagePolicy.Reset()
			if err := s.TerminationMessagePolicy.Decode(d); err != nil {
				return err
			}
		case "tty":
			s.Tty.Reset()
			if err := s.Tty.Decode(d); err != nil {
				return err
			}
		case "volumeDevices":
			s.VolumeDevices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1VolumeDevice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumeDevices = append(s.VolumeDevices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "volumeMounts":
			s.VolumeMounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1VolumeMount
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumeMounts = append(s.VolumeMounts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "workingDir":
			s.WorkingDir.Reset()
			if err := s.WorkingDir.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.VolumeClaimTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeClaimTemplate.Set {
			e.RawStr("\"volumeClaimTemplate\"" + ":")
			s.VolumeClaimTemplate.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralVolumeSource = [1]string{
	0: "volumeClaimTemplate",
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EphemeralVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "volumeClaimTemplate":
			s.VolumeClaimTemplate.Reset()
			if err := s.VolumeClaimTemplate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	{
		if s.EventTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventTime.Set {
			e.RawStr("\"eventTime\"" + ":")
			s.EventTime.Encode(e)
		}
	}
	{
		if s.FirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FirstTimestamp.Set {
			e.RawStr("\"firstTimestamp\"" + ":")
			s.FirstTimestamp.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"involvedObject\"" + ":")
		s.InvolvedObject.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.LastTimestamp.Set {
			e.Comma()
		}
		if s.LastTimestamp.Set {
			e.RawStr("\"lastTimestamp\"" + ":")
			s.LastTimestamp.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"metadata\"" + ":")
		s.Metadata.Encode(e)
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingComponent.Set {
			e.Comma()
		}
		if s.ReportingComponent.Set {
			e.RawStr("\"reportingComponent\"" + ":")
			s.ReportingComponent.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "count",
	3:  "eventTime",
	4:  "firstTimestamp",
	5:  "involvedObject",
	6:  "kind",
	7:  "lastTimestamp",
	8:  "message",
	9:  "metadata",
	10: "reason",
	11: "related",
	12: "reportingComponent",
	13: "reportingInstance",
	14: "series",
	15: "source",
	16: "type",
}

// Decode decodes IoK8sAPICoreV1Event from json.
func (s *IoK8sAPICoreV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Event to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "count":
			s.Count.Reset()
			if err := s.Count.Decode(d); err != nil {
				return err
			}
		case "eventTime":
			s.EventTime.Reset()
			if err := s.EventTime.Decode(d); err != nil {
				return err
			}
		case "firstTimestamp":
			s.FirstTimestamp.Reset()
			if err := s.FirstTimestamp.Decode(d); err != nil {
				return err
			}
		case "involvedObject":
			requiredBitSet[0] |= 1 << 5
			if err := s.InvolvedObject.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "lastTimestamp":
			s.LastTimestamp.Reset()
			if err := s.LastTimestamp.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 1
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "related":
			s.Related.Reset()
			if err := s.Related.Decode(d); err != nil {
				return err
			}
		case "reportingComponent":
			s.ReportingComponent.Reset()
			if err := s.ReportingComponent.Decode(d); err != nil {
				return err
			}
		case "reportingInstance":
			s.ReportingInstance.Reset()
			if err := s.ReportingInstance.Decode(d); err != nil {
				return err
			}
		case "series":
			s.Series.Reset()
			if err := s.Series.Decode(d); err != nil {
				return err
			}
		case "source":
			s.Source.Reset()
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100000,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Event) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EventList from json.
func (s *IoK8sAPICoreV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EventList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Event
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EventList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	{
		if s.LastObservedTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastObservedTime.Set {
			e.RawStr("\"lastObservedTime\"" + ":")
			s.LastObservedTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (s *IoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EventSeries to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			s.Count.Reset()
			if err := s.Count.Decode(d); err != nil {
				return err
			}
		case "lastObservedTime":
			s.LastObservedTime.Reset()
			if err := s.LastObservedTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1EventSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Component.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Component.Set {
			e.RawStr("\"component\"" + ":")
			s.Component.Encode(e)
		}
	}
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSource = [2]string{
	0: "component",
	1: "host",
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (s *IoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1EventSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			s.Component.Reset()
			if err := s.Component.Decode(d); err != nil {
				return err
			}
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ExecAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Command != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Command != nil {
			e.RawStr("\"command\"" + ":")
			e.ArrStart()
			if len(s.Command) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Command[0]
					e.Str(elem)
				}
				for _, elem := range s.Command[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ExecAction = [1]string{
	0: "command",
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (s *IoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ExecAction to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			s.Command = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Command = append(s.Command, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Lun.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Lun.Set {
			e.RawStr("\"lun\"" + ":")
			s.Lun.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.TargetWWNs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetWWNs != nil {
			e.RawStr("\"targetWWNs\"" + ":")
			e.ArrStart()
			if len(s.TargetWWNs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TargetWWNs[0]
					e.Str(elem)
				}
				for _, elem := range s.TargetWWNs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Wwids != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Wwids != nil {
			e.RawStr("\"wwids\"" + ":")
			e.ArrStart()
			if len(s.Wwids) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Wwids[0]
					e.Str(elem)
				}
				for _, elem := range s.Wwids[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FCVolumeSource = [5]string{
	0: "fsType",
	1: "lun",
	2: "readOnly",
	3: "targetWWNs",
	4: "wwids",
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (s *IoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1FCVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "lun":
			s.Lun.Reset()
			if err := s.Lun.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "targetWWNs":
			s.TargetWWNs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.TargetWWNs = append(s.TargetWWNs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "wwids":
			s.Wwids = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Wwids = append(s.Wwids, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.Comma()
		}
		if s.Options.Set {
			e.RawStr("\"options\"" + ":")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1FlexPersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Driver = string(v)
			if err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "options":
			s.Options.Reset()
			if err := s.Options.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.Comma()
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.Comma()
		}
		if s.Options.Set {
			e.RawStr("\"options\"" + ":")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (s *IoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1FlexVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Driver = string(v)
			if err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "options":
			s.Options.Reset()
			if err := s.Options.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DatasetName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DatasetName.Set {
			e.RawStr("\"datasetName\"" + ":")
			s.DatasetName.Encode(e)
		}
	}
	{
		if s.DatasetUUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DatasetUUID.Set {
			e.RawStr("\"datasetUUID\"" + ":")
			s.DatasetUUID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1FlockerVolumeSource = [2]string{
	0: "datasetName",
	1: "datasetUUID",
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (s *IoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1FlockerVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datasetName":
			s.DatasetName.Reset()
			if err := s.DatasetName.Decode(d); err != nil {
				return err
			}
		case "datasetUUID":
			s.DatasetUUID.Reset()
			if err := s.DatasetUUID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Partition.Set {
			e.RawStr("\"partition\"" + ":")
			s.Partition.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pdName\"" + ":")
		e.Str(s.PdName)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "pdName",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "partition":
			s.Partition.Reset()
			if err := s.Partition.Decode(d); err != nil {
				return err
			}
		case "pdName":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.PdName = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Directory.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Directory.Set {
			e.RawStr("\"directory\"" + ":")
			s.Directory.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repository\"" + ":")
		e.Str(s.Repository)
	}
	{
		if s.Revision.Set {
			e.Comma()
		}
		if s.Revision.Set {
			e.RawStr("\"revision\"" + ":")
			s.Revision.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource = [3]string{
	0: "directory",
	1: "repository",
	2: "revision",
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1GitRepoVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "directory":
			s.Directory.Reset()
			if err := s.Directory.Decode(d); err != nil {
				return err
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Repository = string(v)
			if err != nil {
				return err
			}
		case "revision":
			s.Revision.Reset()
			if err := s.Revision.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"endpoints\"" + ":")
		e.Str(s.Endpoints)
	}
	{
		if s.EndpointsNamespace.Set {
			e.Comma()
		}
		if s.EndpointsNamespace.Set {
			e.RawStr("\"endpointsNamespace\"" + ":")
			s.EndpointsNamespace.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource = [4]string{
	0: "endpoints",
	1: "endpointsNamespace",
	2: "path",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Endpoints = string(v)
			if err != nil {
				return err
			}
		case "endpointsNamespace":
			s.EndpointsNamespace.Reset()
			if err := s.EndpointsNamespace.Decode(d); err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"endpoints\"" + ":")
		e.Str(s.Endpoints)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource = [3]string{
	0: "endpoints",
	1: "path",
	2: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1GlusterfsVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Endpoints = string(v)
			if err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.HttpHeaders != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpHeaders != nil {
			e.RawStr("\"httpHeaders\"" + ":")
			e.ArrStart()
			if len(s.HttpHeaders) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HttpHeaders[0]
					elem.Encode(e)
				}
				for _, elem := range s.HttpHeaders[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		s.Port.Encode(e)
	}
	{
		if s.Scheme.Set {
			e.Comma()
		}
		if s.Scheme.Set {
			e.RawStr("\"scheme\"" + ":")
			s.Scheme.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction = [5]string{
	0: "host",
	1: "httpHeaders",
	2: "path",
	3: "port",
	4: "scheme",
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (s *IoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1HTTPGetAction to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "httpHeaders":
			s.HttpHeaders = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1HTTPHeader
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.HttpHeaders = append(s.HttpHeaders, elem)
				return nil
			}); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Port = IoK8sApimachineryPkgUtilIntstrIntOrString(unwrapped)
			}
		case "scheme":
			s.Scheme.Reset()
			if err := s.Scheme.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HTTPHeader) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1HTTPHeader from json.
func (s *IoK8sAPICoreV1HTTPHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1HTTPHeader to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Handler) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Exec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exec.Set {
			e.RawStr("\"exec\"" + ":")
			s.Exec.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpGet.Set {
			e.RawStr("\"httpGet\"" + ":")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TcpSocket.Set {
			e.RawStr("\"tcpSocket\"" + ":")
			s.TcpSocket.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Handler = [3]string{
	0: "exec",
	1: "httpGet",
	2: "tcpSocket",
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (s *IoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Handler to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			s.Exec.Reset()
			if err := s.Exec.Decode(d); err != nil {
				return err
			}
		case "httpGet":
			s.HttpGet.Reset()
			if err := s.HttpGet.Decode(d); err != nil {
				return err
			}
		case "tcpSocket":
			s.TcpSocket.Reset()
			if err := s.TcpSocket.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HostAlias) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostnames != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostnames != nil {
			e.RawStr("\"hostnames\"" + ":")
			e.ArrStart()
			if len(s.Hostnames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hostnames[0]
					e.Str(elem)
				}
				for _, elem := range s.Hostnames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HostAlias = [2]string{
	0: "hostnames",
	1: "ip",
}

// Decode decodes IoK8sAPICoreV1HostAlias from json.
func (s *IoK8sAPICoreV1HostAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1HostAlias to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostnames":
			s.Hostnames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Hostnames = append(s.Hostnames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ip":
			s.IP.Reset()
			if err := s.IP.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource = [2]string{
	0: "path",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (s *IoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1HostPathVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChapAuthDiscovery.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthDiscovery.Set {
			e.RawStr("\"chapAuthDiscovery\"" + ":")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthSession.Set {
			e.RawStr("\"chapAuthSession\"" + ":")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitiatorName.Set {
			e.RawStr("\"initiatorName\"" + ":")
			s.InitiatorName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"iqn\"" + ":")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.Comma()
		}
		if s.IscsiInterface.Set {
			e.RawStr("\"iscsiInterface\"" + ":")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lun\"" + ":")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.Comma()
		}
		if s.Portals != nil {
			e.RawStr("\"portals\"" + ":")
			e.ArrStart()
			if len(s.Portals) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Portals[0]
					e.Str(elem)
				}
				for _, elem := range s.Portals[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetPortal\"" + ":")
		e.Str(s.TargetPortal)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ISCSIPersistentVolumeSource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			s.ChapAuthDiscovery.Reset()
			if err := s.ChapAuthDiscovery.Decode(d); err != nil {
				return err
			}
		case "chapAuthSession":
			s.ChapAuthSession.Reset()
			if err := s.ChapAuthSession.Decode(d); err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "initiatorName":
			s.InitiatorName.Reset()
			if err := s.InitiatorName.Decode(d); err != nil {
				return err
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Iqn = string(v)
			if err != nil {
				return err
			}
		case "iscsiInterface":
			s.IscsiInterface.Reset()
			if err := s.IscsiInterface.Decode(d); err != nil {
				return err
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.Lun = int32(v)
			if err != nil {
				return err
			}
		case "portals":
			s.Portals = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Portals = append(s.Portals, elem)
				return nil
			}); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			v, err := d.Str()
			s.TargetPortal = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChapAuthDiscovery.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthDiscovery.Set {
			e.RawStr("\"chapAuthDiscovery\"" + ":")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChapAuthSession.Set {
			e.RawStr("\"chapAuthSession\"" + ":")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitiatorName.Set {
			e.RawStr("\"initiatorName\"" + ":")
			s.InitiatorName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"iqn\"" + ":")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.Comma()
		}
		if s.IscsiInterface.Set {
			e.RawStr("\"iscsiInterface\"" + ":")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lun\"" + ":")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.Comma()
		}
		if s.Portals != nil {
			e.RawStr("\"portals\"" + ":")
			e.ArrStart()
			if len(s.Portals) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Portals[0]
					e.Str(elem)
				}
				for _, elem := range s.Portals[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"targetPortal\"" + ":")
		e.Str(s.TargetPortal)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ISCSIVolumeSource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			s.ChapAuthDiscovery.Reset()
			if err := s.ChapAuthDiscovery.Decode(d); err != nil {
				return err
			}
		case "chapAuthSession":
			s.ChapAuthSession.Reset()
			if err := s.ChapAuthSession.Decode(d); err != nil {
				return err
			}
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "initiatorName":
			s.InitiatorName.Reset()
			if err := s.InitiatorName.Decode(d); err != nil {
				return err
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Iqn = string(v)
			if err != nil {
				return err
			}
		case "iscsiInterface":
			s.IscsiInterface.Reset()
			if err := s.IscsiInterface.Decode(d); err != nil {
				return err
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.Lun = int32(v)
			if err != nil {
				return err
			}
		case "portals":
			s.Portals = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Portals = append(s.Portals, elem)
				return nil
			}); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			v, err := d.Str()
			s.TargetPortal = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1KeyToPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Mode.Set {
			e.Comma()
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1KeyToPath = [3]string{
	0: "key",
	1: "mode",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1KeyToPath from json.
func (s *IoK8sAPICoreV1KeyToPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1KeyToPath to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1KeyToPath) {
					name = jsonFieldsNameOfIoK8sAPICoreV1KeyToPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Lifecycle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PostStart.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PostStart.Set {
			e.RawStr("\"postStart\"" + ":")
			s.PostStart.Encode(e)
		}
	}
	{
		if s.PreStop.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreStop.Set {
			e.RawStr("\"preStop\"" + ":")
			s.PreStop.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Lifecycle = [2]string{
	0: "postStart",
	1: "preStop",
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (s *IoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Lifecycle to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "postStart":
			s.PostStart.Reset()
			if err := s.PostStart.Decode(d); err != nil {
				return err
			}
		case "preStop":
			s.PreStop.Reset()
			if err := s.PreStop.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRange = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoreV1LimitRange from json.
func (s *IoK8sAPICoreV1LimitRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LimitRange to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.DefaultRequest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultRequest.Set {
			e.RawStr("\"defaultRequest\"" + ":")
			s.DefaultRequest.Encode(e)
		}
	}
	{
		if s.Max.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Max.Set {
			e.RawStr("\"max\"" + ":")
			s.Max.Encode(e)
		}
	}
	{
		if s.MaxLimitRequestRatio.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxLimitRequestRatio.Set {
			e.RawStr("\"maxLimitRequestRatio\"" + ":")
			s.MaxLimitRequestRatio.Encode(e)
		}
	}
	{
		if s.Min.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Min.Set {
			e.RawStr("\"min\"" + ":")
			s.Min.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem = [6]string{
	0: "default",
	1: "defaultRequest",
	2: "max",
	3: "maxLimitRequestRatio",
	4: "min",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1LimitRangeItem from json.
func (s *IoK8sAPICoreV1LimitRangeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LimitRangeItem to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		case "defaultRequest":
			s.DefaultRequest.Reset()
			if err := s.DefaultRequest.Decode(d); err != nil {
				return err
			}
		case "max":
			s.Max.Reset()
			if err := s.Max.Decode(d); err != nil {
				return err
			}
		case "maxLimitRequestRatio":
			s.MaxLimitRequestRatio.Reset()
			if err := s.MaxLimitRequestRatio.Decode(d); err != nil {
				return err
			}
		case "min":
			s.Min.Reset()
			if err := s.Min.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1LimitRangeList from json.
func (s *IoK8sAPICoreV1LimitRangeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LimitRangeList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1LimitRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limits\"" + ":")
		e.ArrStart()
		if len(s.Limits) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Limits[0]
				elem.Encode(e)
			}
			for _, elem := range s.Limits[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec = [1]string{
	0: "limits",
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (s *IoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LimitRangeSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			requiredBitSet[0] |= 1 << 0
			s.Limits = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1LimitRangeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Limits = append(s.Limits, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LoadBalancerIngress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hostname.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerIngress = [3]string{
	0: "hostname",
	1: "ip",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerIngress from json.
func (s *IoK8sAPICoreV1LoadBalancerIngress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LoadBalancerIngress to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			s.Hostname.Reset()
			if err := s.Hostname.Decode(d); err != nil {
				return err
			}
		case "ip":
			s.IP.Reset()
			if err := s.IP.Decode(d); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PortStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ingress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ingress != nil {
			e.RawStr("\"ingress\"" + ":")
			e.ArrStart()
			if len(s.Ingress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ingress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ingress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerStatus = [1]string{
	0: "ingress",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (s *IoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LoadBalancerStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ingress":
			s.Ingress = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1LoadBalancerIngress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ingress = append(s.Ingress, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalObjectReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (s *IoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LocalObjectReference to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource = [2]string{
	0: "fsType",
	1: "path",
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (s *IoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1LocalVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"server\"" + ":")
		e.Str(s.Server)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource = [3]string{
	0: "path",
	1: "readOnly",
	2: "server",
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (s *IoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NFSVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "server":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Server = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Namespace) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Namespace = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Namespace from json.
func (s *IoK8sAPICoreV1Namespace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Namespace to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1NamespaceCondition from json.
func (s *IoK8sAPICoreV1NamespaceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NamespaceCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NamespaceList from json.
func (s *IoK8sAPICoreV1NamespaceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NamespaceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Namespace
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Finalizers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Finalizers != nil {
			e.RawStr("\"finalizers\"" + ":")
			e.ArrStart()
			if len(s.Finalizers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Finalizers[0]
					e.Str(elem)
				}
				for _, elem := range s.Finalizers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceSpec = [1]string{
	0: "finalizers",
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (s *IoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NamespaceSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "finalizers":
			s.Finalizers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Finalizers = append(s.Finalizers, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceStatus = [2]string{
	0: "conditions",
	1: "phase",
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (s *IoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NamespaceStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NamespaceCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "phase":
			s.Phase.Reset()
			if err := s.Phase.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Node) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Node = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Node from json.
func (s *IoK8sAPICoreV1Node) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Node to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeAddress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAddress = [2]string{
	0: "address",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1NodeAddress from json.
func (s *IoK8sAPICoreV1NodeAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeAddress to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			s.RequiredDuringSchedulingIgnoredDuringExecution.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (s *IoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeAffinity to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			s.PreferredDuringSchedulingIgnoredDuringExecution = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PreferredSchedulingTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
				return nil
			}); err != nil {
				return err
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			s.RequiredDuringSchedulingIgnoredDuringExecution.Reset()
			if err := s.RequiredDuringSchedulingIgnoredDuringExecution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastHeartbeatTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastHeartbeatTime.Set {
			e.RawStr("\"lastHeartbeatTime\"" + ":")
			s.LastHeartbeatTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeCondition = [6]string{
	0: "lastHeartbeatTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1NodeCondition from json.
func (s *IoK8sAPICoreV1NodeCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastHeartbeatTime":
			s.LastHeartbeatTime.Reset()
			if err := s.LastHeartbeatTime.Decode(d); err != nil {
				return err
			}
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigSource = [1]string{
	0: "configMap",
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (s *IoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeConfigSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			s.ConfigMap.Reset()
			if err := s.ConfigMap.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Assigned.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assigned.Set {
			e.RawStr("\"assigned\"" + ":")
			s.Assigned.Encode(e)
		}
	}
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if s.LastKnownGood.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastKnownGood.Set {
			e.RawStr("\"lastKnownGood\"" + ":")
			s.LastKnownGood.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigStatus = [4]string{
	0: "active",
	1: "assigned",
	2: "error",
	3: "lastKnownGood",
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (s *IoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeConfigStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "assigned":
			s.Assigned.Reset()
			if err := s.Assigned.Decode(d); err != nil {
				return err
			}
		case "error":
			s.Error.Reset()
			if err := s.Error.Decode(d); err != nil {
				return err
			}
		case "lastKnownGood":
			s.LastKnownGood.Reset()
			if err := s.LastKnownGood.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.KubeletEndpoint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KubeletEndpoint.Set {
			e.RawStr("\"kubeletEndpoint\"" + ":")
			s.KubeletEndpoint.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeDaemonEndpoints = [1]string{
	0: "kubeletEndpoint",
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeDaemonEndpoints to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletEndpoint":
			s.KubeletEndpoint.Reset()
			if err := s.KubeletEndpoint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NodeList from json.
func (s *IoK8sAPICoreV1NodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Node
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nodeSelectorTerms\"" + ":")
		e.ArrStart()
		if len(s.NodeSelectorTerms) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NodeSelectorTerms[0]
				elem.Encode(e)
			}
			for _, elem := range s.NodeSelectorTerms[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelector = [1]string{
	0: "nodeSelectorTerms",
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (s *IoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeSelector to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelectorTerms":
			requiredBitSet[0] |= 1 << 0
			s.NodeSelectorTerms = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NodeSelectorTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NodeSelectorTerms = append(s.NodeSelectorTerms, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorRequirement from json.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeSelectorRequirement to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Operator = string(v)
			if err != nil {
				return err
			}
		case "values":
			s.Values = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Values = append(s.Values, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSelectorTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchFields != nil {
			e.RawStr("\"matchFields\"" + ":")
			e.ArrStart()
			if len(s.MatchFields) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchFields[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchFields[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorTerm = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorTerm from json.
func (s *IoK8sAPICoreV1NodeSelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeSelectorTerm to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			s.MatchExpressions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NodeSelectorRequirement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MatchExpressions = append(s.MatchExpressions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "matchFields":
			s.MatchFields = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NodeSelectorRequirement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MatchFields = append(s.MatchFields, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigSource.Set {
			e.RawStr("\"configSource\"" + ":")
			s.ConfigSource.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalID.Set {
			e.RawStr("\"externalID\"" + ":")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.PodCIDR.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodCIDR.Set {
			e.RawStr("\"podCIDR\"" + ":")
			s.PodCIDR.Encode(e)
		}
	}
	{
		if s.PodCIDRs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodCIDRs != nil {
			e.RawStr("\"podCIDRs\"" + ":")
			e.ArrStart()
			if len(s.PodCIDRs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PodCIDRs[0]
					e.Str(elem)
				}
				for _, elem := range s.PodCIDRs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProviderID.Set {
			e.RawStr("\"providerID\"" + ":")
			s.ProviderID.Encode(e)
		}
	}
	{
		if s.Taints != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Taints != nil {
			e.RawStr("\"taints\"" + ":")
			e.ArrStart()
			if len(s.Taints) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Taints[0]
					elem.Encode(e)
				}
				for _, elem := range s.Taints[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Unschedulable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Unschedulable.Set {
			e.RawStr("\"unschedulable\"" + ":")
			s.Unschedulable.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSpec = [7]string{
	0: "configSource",
	1: "externalID",
	2: "podCIDR",
	3: "podCIDRs",
	4: "providerID",
	5: "taints",
	6: "unschedulable",
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (s *IoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configSource":
			s.ConfigSource.Reset()
			if err := s.ConfigSource.Decode(d); err != nil {
				return err
			}
		case "externalID":
			s.ExternalID.Reset()
			if err := s.ExternalID.Decode(d); err != nil {
				return err
			}
		case "podCIDR":
			s.PodCIDR.Reset()
			if err := s.PodCIDR.Decode(d); err != nil {
				return err
			}
		case "podCIDRs":
			s.PodCIDRs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.PodCIDRs = append(s.PodCIDRs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "providerID":
			s.ProviderID.Reset()
			if err := s.ProviderID.Decode(d); err != nil {
				return err
			}
		case "taints":
			s.Taints = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Taint
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Taints = append(s.Taints, elem)
				return nil
			}); err != nil {
				return err
			}
		case "unschedulable":
			s.Unschedulable.Reset()
			if err := s.Unschedulable.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Addresses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Addresses != nil {
			e.RawStr("\"addresses\"" + ":")
			e.ArrStart()
			if len(s.Addresses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Addresses[0]
					elem.Encode(e)
				}
				for _, elem := range s.Addresses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Allocatable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Allocatable.Set {
			e.RawStr("\"allocatable\"" + ":")
			s.Allocatable.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.DaemonEndpoints.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DaemonEndpoints.Set {
			e.RawStr("\"daemonEndpoints\"" + ":")
			s.DaemonEndpoints.Encode(e)
		}
	}
	{
		if s.Images != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Images != nil {
			e.RawStr("\"images\"" + ":")
			e.ArrStart()
			if len(s.Images) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Images[0]
					elem.Encode(e)
				}
				for _, elem := range s.Images[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeInfo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeInfo.Set {
			e.RawStr("\"nodeInfo\"" + ":")
			s.NodeInfo.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.VolumesAttached != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumesAttached != nil {
			e.RawStr("\"volumesAttached\"" + ":")
			e.ArrStart()
			if len(s.VolumesAttached) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumesAttached[0]
					elem.Encode(e)
				}
				for _, elem := range s.VolumesAttached[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumesInUse != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumesInUse != nil {
			e.RawStr("\"volumesInUse\"" + ":")
			e.ArrStart()
			if len(s.VolumesInUse) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumesInUse[0]
					e.Str(elem)
				}
				for _, elem := range s.VolumesInUse[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeStatus = [11]string{
	0:  "addresses",
	1:  "allocatable",
	2:  "capacity",
	3:  "conditions",
	4:  "config",
	5:  "daemonEndpoints",
	6:  "images",
	7:  "nodeInfo",
	8:  "phase",
	9:  "volumesAttached",
	10: "volumesInUse",
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (s *IoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			s.Addresses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NodeAddress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Addresses = append(s.Addresses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allocatable":
			s.Allocatable.Reset()
			if err := s.Allocatable.Decode(d); err != nil {
				return err
			}
		case "capacity":
			s.Capacity.Reset()
			if err := s.Capacity.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1NodeCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "daemonEndpoints":
			s.DaemonEndpoints.Reset()
			if err := s.DaemonEndpoints.Decode(d); err != nil {
				return err
			}
		case "images":
			s.Images = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerImage
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Images = append(s.Images, elem)
				return nil
			}); err != nil {
				return err
			}
		case "nodeInfo":
			s.NodeInfo.Reset()
			if err := s.NodeInfo.Decode(d); err != nil {
				return err
			}
		case "phase":
			s.Phase.Reset()
			if err := s.Phase.Decode(d); err != nil {
				return err
			}
		case "volumesAttached":
			s.VolumesAttached = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1AttachedVolume
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VolumesAttached = append(s.VolumesAttached, elem)
				return nil
			}); err != nil {
				return err
			}
		case "volumesInUse":
			s.VolumesInUse = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.VolumesInUse = append(s.VolumesInUse, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"architecture\"" + ":")
		e.Str(s.Architecture)
	}
	{
		e.Comma()

		e.RawStr("\"bootID\"" + ":")
		e.Str(s.BootID)
	}
	{
		e.Comma()

		e.RawStr("\"containerRuntimeVersion\"" + ":")
		e.Str(s.ContainerRuntimeVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kernelVersion\"" + ":")
		e.Str(s.KernelVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kubeProxyVersion\"" + ":")
		e.Str(s.KubeProxyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"kubeletVersion\"" + ":")
		e.Str(s.KubeletVersion)
	}
	{
		e.Comma()

		e.RawStr("\"machineID\"" + ":")
		e.Str(s.MachineID)
	}
	{
		e.Comma()

		e.RawStr("\"operatingSystem\"" + ":")
		e.Str(s.OperatingSystem)
	}
	{
		e.Comma()

		e.RawStr("\"osImage\"" + ":")
		e.Str(s.OsImage)
	}
	{
		e.Comma()

		e.RawStr("\"systemUUID\"" + ":")
		e.Str(s.SystemUUID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo = [10]string{
	0: "architecture",
	1: "bootID",
	2: "containerRuntimeVersion",
	3: "kernelVersion",
	4: "kubeProxyVersion",
	5: "kubeletVersion",
	6: "machineID",
	7: "operatingSystem",
	8: "osImage",
	9: "systemUUID",
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (s *IoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1NodeSystemInfo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Architecture = string(v)
			if err != nil {
				return err
			}
		case "bootID":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.BootID = string(v)
			if err != nil {
				return err
			}
		case "containerRuntimeVersion":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.ContainerRuntimeVersion = string(v)
			if err != nil {
				return err
			}
		case "kernelVersion":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.KernelVersion = string(v)
			if err != nil {
				return err
			}
		case "kubeProxyVersion":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.KubeProxyVersion = string(v)
			if err != nil {
				return err
			}
		case "kubeletVersion":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.KubeletVersion = string(v)
			if err != nil {
				return err
			}
		case "machineID":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.MachineID = string(v)
			if err != nil {
				return err
			}
		case "operatingSystem":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Str()
			s.OperatingSystem = string(v)
			if err != nil {
				return err
			}
		case "osImage":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.OsImage = string(v)
			if err != nil {
				return err
			}
		case "systemUUID":
			requiredBitSet[1] |= 1 << 1
			v, err := d.Str()
			s.SystemUUID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"fieldPath\"" + ":")
		e.Str(s.FieldPath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector = [2]string{
	0: "apiVersion",
	1: "fieldPath",
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (s *IoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ObjectFieldSelector to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "fieldPath":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FieldPath = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldPath.Set {
			e.RawStr("\"fieldPath\"" + ":")
			s.FieldPath.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectReference = [7]string{
	0: "apiVersion",
	1: "fieldPath",
	2: "kind",
	3: "name",
	4: "namespace",
	5: "resourceVersion",
	6: "uid",
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (s *IoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ObjectReference to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "fieldPath":
			s.FieldPath.Reset()
			if err := s.FieldPath.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		case "resourceVersion":
			s.ResourceVersion.Reset()
			if err := s.ResourceVersion.Decode(d); err != nil {
				return err
			}
		case "uid":
			s.UID.Reset()
			if err := s.UID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolume = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolume from json.
func (s *IoK8sAPICoreV1PersistentVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolume to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaim) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaim = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaim from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaim to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimCondition from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			s.LastProbeTime.Reset()
			if err := s.LastProbeTime.Decode(d); err != nil {
				return err
			}
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimList from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PersistentVolumeClaim
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DataSource.Set {
			e.RawStr("\"dataSource\"" + ":")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.DataSourceRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DataSourceRef.Set {
			e.RawStr("\"dataSourceRef\"" + ":")
			s.DataSourceRef.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources.Set {
			e.RawStr("\"resources\"" + ":")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageClassName.Set {
			e.RawStr("\"storageClassName\"" + ":")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeMode.Set {
			e.RawStr("\"volumeMode\"" + ":")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimSpec = [8]string{
	0: "accessModes",
	1: "dataSource",
	2: "dataSourceRef",
	3: "resources",
	4: "selector",
	5: "storageClassName",
	6: "volumeMode",
	7: "volumeName",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			s.AccessModes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AccessModes = append(s.AccessModes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "dataSource":
			s.DataSource.Reset()
			if err := s.DataSource.Decode(d); err != nil {
				return err
			}
		case "dataSourceRef":
			s.DataSourceRef.Reset()
			if err := s.DataSourceRef.Decode(d); err != nil {
				return err
			}
		case "resources":
			s.Resources.Reset()
			if err := s.Resources.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "storageClassName":
			s.StorageClassName.Reset()
			if err := s.StorageClassName.Decode(d); err != nil {
				return err
			}
		case "volumeMode":
			s.VolumeMode.Reset()
			if err := s.VolumeMode.Decode(d); err != nil {
				return err
			}
		case "volumeName":
			s.VolumeName.Reset()
			if err := s.VolumeName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimStatus = [4]string{
	0: "accessModes",
	1: "capacity",
	2: "conditions",
	3: "phase",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			s.AccessModes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AccessModes = append(s.AccessModes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "capacity":
			s.Capacity.Reset()
			if err := s.Capacity.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PersistentVolumeClaimCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "phase":
			s.Phase.Reset()
			if err := s.Phase.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimTemplate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 1
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"claimName\"" + ":")
		e.Str(s.ClaimName)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource = [2]string{
	0: "claimName",
	1: "readOnly",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claimName":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ClaimName = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeList from json.
func (s *IoK8sAPICoreV1PersistentVolumeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PersistentVolume
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AccessModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AccessModes != nil {
			e.RawStr("\"accessModes\"" + ":")
			e.ArrStart()
			if len(s.AccessModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AccessModes[0]
					e.Str(elem)
				}
				for _, elem := range s.AccessModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AwsElasticBlockStore.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AwsElasticBlockStore.Set {
			e.RawStr("\"awsElasticBlockStore\"" + ":")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureDisk.Set {
			e.RawStr("\"azureDisk\"" + ":")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureFile.Set {
			e.RawStr("\"azureFile\"" + ":")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cephfs.Set {
			e.RawStr("\"cephfs\"" + ":")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cinder.Set {
			e.RawStr("\"cinder\"" + ":")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ClaimRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClaimRef.Set {
			e.RawStr("\"claimRef\"" + ":")
			s.ClaimRef.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Csi.Set {
			e.RawStr("\"csi\"" + ":")
			s.Csi.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fc.Set {
			e.RawStr("\"fc\"" + ":")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FlexVolume.Set {
			e.RawStr("\"flexVolume\"" + ":")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Flocker.Set {
			e.RawStr("\"flocker\"" + ":")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GcePersistentDisk.Set {
			e.RawStr("\"gcePersistentDisk\"" + ":")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Glusterfs.Set {
			e.RawStr("\"glusterfs\"" + ":")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostPath.Set {
			e.RawStr("\"hostPath\"" + ":")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Iscsi.Set {
			e.RawStr("\"iscsi\"" + ":")
			s.Iscsi.Encode(e)
		}
	}
	{
		if s.Local.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Local.Set {
			e.RawStr("\"local\"" + ":")
			s.Local.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MountOptions != nil {
			e.RawStr("\"mountOptions\"" + ":")
			e.ArrStart()
			if len(s.MountOptions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MountOptions[0]
					e.Str(elem)
				}
				for _, elem := range s.MountOptions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Nfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nfs.Set {
			e.RawStr("\"nfs\"" + ":")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.NodeAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeAffinity.Set {
			e.RawStr("\"nodeAffinity\"" + ":")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PersistentVolumeReclaimPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PersistentVolumeReclaimPolicy.Set {
			e.RawStr("\"persistentVolumeReclaimPolicy\"" + ":")
			s.PersistentVolumeReclaimPolicy.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PhotonPersistentDisk.Set {
			e.RawStr("\"photonPersistentDisk\"" + ":")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PortworxVolume.Set {
			e.RawStr("\"portworxVolume\"" + ":")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Quobyte.Set {
			e.RawStr("\"quobyte\"" + ":")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rbd.Set {
			e.RawStr("\"rbd\"" + ":")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScaleIO.Set {
			e.RawStr("\"scaleIO\"" + ":")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageClassName.Set {
			e.RawStr("\"storageClassName\"" + ":")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Storageos.Set {
			e.RawStr("\"storageos\"" + ":")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeMode.Set {
			e.RawStr("\"volumeMode\"" + ":")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VsphereVolume.Set {
			e.RawStr("\"vsphereVolume\"" + ":")
			s.VsphereVolume.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeSpec = [30]string{
	0:  "accessModes",
	1:  "awsElasticBlockStore",
	2:  "azureDisk",
	3:  "azureFile",
	4:  "capacity",
	5:  "cephfs",
	6:  "cinder",
	7:  "claimRef",
	8:  "csi",
	9:  "fc",
	10: "flexVolume",
	11: "flocker",
	12: "gcePersistentDisk",
	13: "glusterfs",
	14: "hostPath",
	15: "iscsi",
	16: "local",
	17: "mountOptions",
	18: "nfs",
	19: "nodeAffinity",
	20: "persistentVolumeReclaimPolicy",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "quobyte",
	24: "rbd",
	25: "scaleIO",
	26: "storageClassName",
	27: "storageos",
	28: "volumeMode",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			s.AccessModes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AccessModes = append(s.AccessModes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "awsElasticBlockStore":
			s.AwsElasticBlockStore.Reset()
			if err := s.AwsElasticBlockStore.Decode(d); err != nil {
				return err
			}
		case "azureDisk":
			s.AzureDisk.Reset()
			if err := s.AzureDisk.Decode(d); err != nil {
				return err
			}
		case "azureFile":
			s.AzureFile.Reset()
			if err := s.AzureFile.Decode(d); err != nil {
				return err
			}
		case "capacity":
			s.Capacity.Reset()
			if err := s.Capacity.Decode(d); err != nil {
				return err
			}
		case "cephfs":
			s.Cephfs.Reset()
			if err := s.Cephfs.Decode(d); err != nil {
				return err
			}
		case "cinder":
			s.Cinder.Reset()
			if err := s.Cinder.Decode(d); err != nil {
				return err
			}
		case "claimRef":
			s.ClaimRef.Reset()
			if err := s.ClaimRef.Decode(d); err != nil {
				return err
			}
		case "csi":
			s.Csi.Reset()
			if err := s.Csi.Decode(d); err != nil {
				return err
			}
		case "fc":
			s.Fc.Reset()
			if err := s.Fc.Decode(d); err != nil {
				return err
			}
		case "flexVolume":
			s.FlexVolume.Reset()
			if err := s.FlexVolume.Decode(d); err != nil {
				return err
			}
		case "flocker":
			s.Flocker.Reset()
			if err := s.Flocker.Decode(d); err != nil {
				return err
			}
		case "gcePersistentDisk":
			s.GcePersistentDisk.Reset()
			if err := s.GcePersistentDisk.Decode(d); err != nil {
				return err
			}
		case "glusterfs":
			s.Glusterfs.Reset()
			if err := s.Glusterfs.Decode(d); err != nil {
				return err
			}
		case "hostPath":
			s.HostPath.Reset()
			if err := s.HostPath.Decode(d); err != nil {
				return err
			}
		case "iscsi":
			s.Iscsi.Reset()
			if err := s.Iscsi.Decode(d); err != nil {
				return err
			}
		case "local":
			s.Local.Reset()
			if err := s.Local.Decode(d); err != nil {
				return err
			}
		case "mountOptions":
			s.MountOptions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.MountOptions = append(s.MountOptions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "nfs":
			s.Nfs.Reset()
			if err := s.Nfs.Decode(d); err != nil {
				return err
			}
		case "nodeAffinity":
			s.NodeAffinity.Reset()
			if err := s.NodeAffinity.Decode(d); err != nil {
				return err
			}
		case "persistentVolumeReclaimPolicy":
			s.PersistentVolumeReclaimPolicy.Reset()
			if err := s.PersistentVolumeReclaimPolicy.Decode(d); err != nil {
				return err
			}
		case "photonPersistentDisk":
			s.PhotonPersistentDisk.Reset()
			if err := s.PhotonPersistentDisk.Decode(d); err != nil {
				return err
			}
		case "portworxVolume":
			s.PortworxVolume.Reset()
			if err := s.PortworxVolume.Decode(d); err != nil {
				return err
			}
		case "quobyte":
			s.Quobyte.Reset()
			if err := s.Quobyte.Decode(d); err != nil {
				return err
			}
		case "rbd":
			s.Rbd.Reset()
			if err := s.Rbd.Decode(d); err != nil {
				return err
			}
		case "scaleIO":
			s.ScaleIO.Reset()
			if err := s.ScaleIO.Decode(d); err != nil {
				return err
			}
		case "storageClassName":
			s.StorageClassName.Reset()
			if err := s.StorageClassName.Decode(d); err != nil {
				return err
			}
		case "storageos":
			s.Storageos.Reset()
			if err := s.Storageos.Decode(d); err != nil {
				return err
			}
		case "volumeMode":
			s.VolumeMode.Reset()
			if err := s.VolumeMode.Decode(d); err != nil {
				return err
			}
		case "vsphereVolume":
			s.VsphereVolume.Reset()
			if err := s.VsphereVolume.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeStatus = [3]string{
	0: "message",
	1: "phase",
	2: "reason",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PersistentVolumeStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "phase":
			s.Phase.Reset()
			if err := s.Phase.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pdID\"" + ":")
		e.Str(s.PdID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource = [2]string{
	0: "fsType",
	1: "pdID",
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "pdID":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.PdID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Pod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Pod = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Pod from json.
func (s *IoK8sAPICoreV1Pod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Pod to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.RequiredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (s *IoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodAffinity to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			s.PreferredDuringSchedulingIgnoredDuringExecution = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1WeightedPodAffinityTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
				return nil
			}); err != nil {
				return err
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			s.RequiredDuringSchedulingIgnoredDuringExecution = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodAffinityTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAffinityTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelector.Set {
			e.RawStr("\"labelSelector\"" + ":")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"topologyKey\"" + ":")
		e.Str(s.TopologyKey)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes IoK8sAPICoreV1PodAffinityTerm from json.
func (s *IoK8sAPICoreV1PodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodAffinityTerm to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			s.LabelSelector.Reset()
			if err := s.LabelSelector.Decode(d); err != nil {
				return err
			}
		case "namespaceSelector":
			s.NamespaceSelector.Reset()
			if err := s.NamespaceSelector.Decode(d); err != nil {
				return err
			}
		case "namespaces":
			s.Namespaces = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Namespaces = append(s.Namespaces, elem)
				return nil
			}); err != nil {
				return err
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.TopologyKey = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"preferredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.PreferredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PreferredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.RawStr("\"requiredDuringSchedulingIgnoredDuringExecution\"" + ":")
			e.ArrStart()
			if len(s.RequiredDuringSchedulingIgnoredDuringExecution) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDuringSchedulingIgnoredDuringExecution[0]
					elem.Encode(e)
				}
				for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAntiAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (s *IoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodAntiAffinity to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			s.PreferredDuringSchedulingIgnoredDuringExecution = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1WeightedPodAffinityTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
				return nil
			}); err != nil {
				return err
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			s.RequiredDuringSchedulingIgnoredDuringExecution = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodAffinityTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastProbeTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastProbeTime.Set {
			e.RawStr("\"lastProbeTime\"" + ":")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PodCondition from json.
func (s *IoK8sAPICoreV1PodCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			s.LastProbeTime.Reset()
			if err := s.LastProbeTime.Decode(d); err != nil {
				return err
			}
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Nameservers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers != nil {
			e.RawStr("\"nameservers\"" + ":")
			e.ArrStart()
			if len(s.Nameservers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Nameservers[0]
					e.Str(elem)
				}
				for _, elem := range s.Nameservers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Options != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Options != nil {
			e.RawStr("\"options\"" + ":")
			e.ArrStart()
			if len(s.Options) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Options[0]
					elem.Encode(e)
				}
				for _, elem := range s.Options[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Searches != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Searches != nil {
			e.RawStr("\"searches\"" + ":")
			e.ArrStart()
			if len(s.Searches) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Searches[0]
					e.Str(elem)
				}
				for _, elem := range s.Searches[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfig = [3]string{
	0: "nameservers",
	1: "options",
	2: "searches",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (s *IoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodDNSConfig to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nameservers":
			s.Nameservers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Nameservers = append(s.Nameservers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "options":
			s.Options = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodDNSConfigOption
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Options = append(s.Options, elem)
				return nil
			}); err != nil {
				return err
			}
		case "searches":
			s.Searches = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Searches = append(s.Searches, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodDNSConfigOption) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfigOption = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfigOption from json.
func (s *IoK8sAPICoreV1PodDNSConfigOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodDNSConfigOption to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodIP) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IP.Set {
			e.RawStr("\"ip\"" + ":")
			s.IP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodIP = [1]string{
	0: "ip",
}

// Decode decodes IoK8sAPICoreV1PodIP from json.
func (s *IoK8sAPICoreV1PodIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodIP to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			s.IP.Reset()
			if err := s.IP.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodList from json.
func (s *IoK8sAPICoreV1PodList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Pod
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodReadinessGate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conditionType\"" + ":")
		e.Str(s.ConditionType)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate = [1]string{
	0: "conditionType",
}

// Decode decodes IoK8sAPICoreV1PodReadinessGate from json.
func (s *IoK8sAPICoreV1PodReadinessGate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodReadinessGate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditionType":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ConditionType = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroup.Set {
			e.RawStr("\"fsGroup\"" + ":")
			s.FsGroup.Encode(e)
		}
	}
	{
		if s.FsGroupChangePolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroupChangePolicy.Set {
			e.RawStr("\"fsGroupChangePolicy\"" + ":")
			s.FsGroupChangePolicy.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsNonRoot.Set {
			e.RawStr("\"runAsNonRoot\"" + ":")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUser.Set {
			e.RawStr("\"runAsUser\"" + ":")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeccompProfile.Set {
			e.RawStr("\"seccompProfile\"" + ":")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.SupplementalGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SupplementalGroups != nil {
			e.RawStr("\"supplementalGroups\"" + ":")
			e.ArrStart()
			if len(s.SupplementalGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SupplementalGroups[0]
					e.Int64(elem)
				}
				for _, elem := range s.SupplementalGroups[1:] {
					e.Comma()
					e.Int64(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sysctls != nil {
			e.RawStr("\"sysctls\"" + ":")
			e.ArrStart()
			if len(s.Sysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Sysctls[0]
					elem.Encode(e)
				}
				for _, elem := range s.Sysctls[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.WindowsOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WindowsOptions.Set {
			e.RawStr("\"windowsOptions\"" + ":")
			s.WindowsOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSecurityContext = [10]string{
	0: "fsGroup",
	1: "fsGroupChangePolicy",
	2: "runAsGroup",
	3: "runAsNonRoot",
	4: "runAsUser",
	5: "seLinuxOptions",
	6: "seccompProfile",
	7: "supplementalGroups",
	8: "sysctls",
	9: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (s *IoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodSecurityContext to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsGroup":
			s.FsGroup.Reset()
			if err := s.FsGroup.Decode(d); err != nil {
				return err
			}
		case "fsGroupChangePolicy":
			s.FsGroupChangePolicy.Reset()
			if err := s.FsGroupChangePolicy.Decode(d); err != nil {
				return err
			}
		case "runAsGroup":
			s.RunAsGroup.Reset()
			if err := s.RunAsGroup.Decode(d); err != nil {
				return err
			}
		case "runAsNonRoot":
			s.RunAsNonRoot.Reset()
			if err := s.RunAsNonRoot.Decode(d); err != nil {
				return err
			}
		case "runAsUser":
			s.RunAsUser.Reset()
			if err := s.RunAsUser.Decode(d); err != nil {
				return err
			}
		case "seLinuxOptions":
			s.SeLinuxOptions.Reset()
			if err := s.SeLinuxOptions.Decode(d); err != nil {
				return err
			}
		case "seccompProfile":
			s.SeccompProfile.Reset()
			if err := s.SeccompProfile.Decode(d); err != nil {
				return err
			}
		case "supplementalGroups":
			s.SupplementalGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				s.SupplementalGroups = append(s.SupplementalGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sysctls":
			s.Sysctls = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Sysctl
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Sysctls = append(s.Sysctls, elem)
				return nil
			}); err != nil {
				return err
			}
		case "windowsOptions":
			s.WindowsOptions.Reset()
			if err := s.WindowsOptions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ActiveDeadlineSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveDeadlineSeconds.Set {
			e.RawStr("\"activeDeadlineSeconds\"" + ":")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Affinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Affinity.Set {
			e.RawStr("\"affinity\"" + ":")
			s.Affinity.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutomountServiceAccountToken.Set {
			e.RawStr("\"automountServiceAccountToken\"" + ":")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"containers\"" + ":")
		e.ArrStart()
		if len(s.Containers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Containers[0]
				elem.Encode(e)
			}
			for _, elem := range s.Containers[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.DnsConfig.Set {
			e.Comma()
		}
		if s.DnsConfig.Set {
			e.RawStr("\"dnsConfig\"" + ":")
			s.DnsConfig.Encode(e)
		}
	}
	{
		if s.DnsPolicy.Set {
			e.Comma()
		}
		if s.DnsPolicy.Set {
			e.RawStr("\"dnsPolicy\"" + ":")
			s.DnsPolicy.Encode(e)
		}
	}
	{
		if s.EnableServiceLinks.Set {
			e.Comma()
		}
		if s.EnableServiceLinks.Set {
			e.RawStr("\"enableServiceLinks\"" + ":")
			s.EnableServiceLinks.Encode(e)
		}
	}
	{
		if s.EphemeralContainers != nil {
			e.Comma()
		}
		if s.EphemeralContainers != nil {
			e.RawStr("\"ephemeralContainers\"" + ":")
			e.ArrStart()
			if len(s.EphemeralContainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EphemeralContainers[0]
					elem.Encode(e)
				}
				for _, elem := range s.EphemeralContainers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostAliases != nil {
			e.Comma()
		}
		if s.HostAliases != nil {
			e.RawStr("\"hostAliases\"" + ":")
			e.ArrStart()
			if len(s.HostAliases) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HostAliases[0]
					elem.Encode(e)
				}
				for _, elem := range s.HostAliases[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIPC.Set {
			e.Comma()
		}
		if s.HostIPC.Set {
			e.RawStr("\"hostIPC\"" + ":")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.Comma()
		}
		if s.HostNetwork.Set {
			e.RawStr("\"hostNetwork\"" + ":")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.Comma()
		}
		if s.HostPID.Set {
			e.RawStr("\"hostPID\"" + ":")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			e.Comma()
		}
		if s.ImagePullSecrets != nil {
			e.RawStr("\"imagePullSecrets\"" + ":")
			e.ArrStart()
			if len(s.ImagePullSecrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ImagePullSecrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.ImagePullSecrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.InitContainers != nil {
			e.Comma()
		}
		if s.InitContainers != nil {
			e.RawStr("\"initContainers\"" + ":")
			e.ArrStart()
			if len(s.InitContainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.InitContainers[0]
					elem.Encode(e)
				}
				for _, elem := range s.InitContainers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.NodeSelector.Set {
			e.Comma()
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			e.Comma()
		}
		if s.PreemptionPolicy.Set {
			e.RawStr("\"preemptionPolicy\"" + ":")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.Comma()
		}
		if s.Priority.Set {
			e.RawStr("\"priority\"" + ":")
			s.Priority.Encode(e)
		}
	}
	{
		if s.PriorityClassName.Set {
			e.Comma()
		}
		if s.PriorityClassName.Set {
			e.RawStr("\"priorityClassName\"" + ":")
			s.PriorityClassName.Encode(e)
		}
	}
	{
		if s.ReadinessGates != nil {
			e.Comma()
		}
		if s.ReadinessGates != nil {
			e.RawStr("\"readinessGates\"" + ":")
			e.ArrStart()
			if len(s.ReadinessGates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ReadinessGates[0]
					elem.Encode(e)
				}
				for _, elem := range s.ReadinessGates[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RestartPolicy.Set {
			e.Comma()
		}
		if s.RestartPolicy.Set {
			e.RawStr("\"restartPolicy\"" + ":")
			s.RestartPolicy.Encode(e)
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.Comma()
		}
		if s.RuntimeClassName.Set {
			e.RawStr("\"runtimeClassName\"" + ":")
			s.RuntimeClassName.Encode(e)
		}
	}
	{
		if s.SchedulerName.Set {
			e.Comma()
		}
		if s.SchedulerName.Set {
			e.RawStr("\"schedulerName\"" + ":")
			s.SchedulerName.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.Comma()
		}
		if s.SecurityContext.Set {
			e.RawStr("\"securityContext\"" + ":")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.ServiceAccountName.Set {
			e.Comma()
		}
		if s.ServiceAccountName.Set {
			e.RawStr("\"serviceAccountName\"" + ":")
			s.ServiceAccountName.Encode(e)
		}
	}
	{
		if s.SetHostnameAsFQDN.Set {
			e.Comma()
		}
		if s.SetHostnameAsFQDN.Set {
			e.RawStr("\"setHostnameAsFQDN\"" + ":")
			s.SetHostnameAsFQDN.Encode(e)
		}
	}
	{
		if s.ShareProcessNamespace.Set {
			e.Comma()
		}
		if s.ShareProcessNamespace.Set {
			e.RawStr("\"shareProcessNamespace\"" + ":")
			s.ShareProcessNamespace.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			e.Comma()
		}
		if s.Subdomain.Set {
			e.RawStr("\"subdomain\"" + ":")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			e.Comma()
		}
		if s.TerminationGracePeriodSeconds.Set {
			e.RawStr("\"terminationGracePeriodSeconds\"" + ":")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.Comma()
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TopologySpreadConstraints != nil {
			e.Comma()
		}
		if s.TopologySpreadConstraints != nil {
			e.RawStr("\"topologySpreadConstraints\"" + ":")
			e.ArrStart()
			if len(s.TopologySpreadConstraints) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TopologySpreadConstraints[0]
					elem.Encode(e)
				}
				for _, elem := range s.TopologySpreadConstraints[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Volumes != nil {
			e.Comma()
		}
		if s.Volumes != nil {
			e.RawStr("\"volumes\"" + ":")
			e.ArrStart()
			if len(s.Volumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Volumes[0]
					elem.Encode(e)
				}
				for _, elem := range s.Volumes[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSpec = [35]string{
	0:  "activeDeadlineSeconds",
	1:  "affinity",
	2:  "automountServiceAccountToken",
	3:  "containers",
	4:  "dnsConfig",
	5:  "dnsPolicy",
	6:  "enableServiceLinks",
	7:  "ephemeralContainers",
	8:  "hostAliases",
	9:  "hostIPC",
	10: "hostNetwork",
	11: "hostPID",
	12: "hostname",
	13: "imagePullSecrets",
	14: "initContainers",
	15: "nodeName",
	16: "nodeSelector",
	17: "overhead",
	18: "preemptionPolicy",
	19: "priority",
	20: "priorityClassName",
	21: "readinessGates",
	22: "restartPolicy",
	23: "runtimeClassName",
	24: "schedulerName",
	25: "securityContext",
	26: "serviceAccount",
	27: "serviceAccountName",
	28: "setHostnameAsFQDN",
	29: "shareProcessNamespace",
	30: "subdomain",
	31: "terminationGracePeriodSeconds",
	32: "tolerations",
	33: "topologySpreadConstraints",
	34: "volumes",
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (s *IoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodSpec to nil`)
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			s.ActiveDeadlineSeconds.Reset()
			if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
				return err
			}
		case "affinity":
			s.Affinity.Reset()
			if err := s.Affinity.Decode(d); err != nil {
				return err
			}
		case "automountServiceAccountToken":
			s.AutomountServiceAccountToken.Reset()
			if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
				return err
			}
		case "containers":
			requiredBitSet[0] |= 1 << 3
			s.Containers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Container
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Containers = append(s.Containers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "dnsConfig":
			s.DnsConfig.Reset()
			if err := s.DnsConfig.Decode(d); err != nil {
				return err
			}
		case "dnsPolicy":
			s.DnsPolicy.Reset()
			if err := s.DnsPolicy.Decode(d); err != nil {
				return err
			}
		case "enableServiceLinks":
			s.EnableServiceLinks.Reset()
			if err := s.EnableServiceLinks.Decode(d); err != nil {
				return err
			}
		case "ephemeralContainers":
			s.EphemeralContainers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1EphemeralContainer
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EphemeralContainers = append(s.EphemeralContainers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "hostAliases":
			s.HostAliases = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1HostAlias
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.HostAliases = append(s.HostAliases, elem)
				return nil
			}); err != nil {
				return err
			}
		case "hostIPC":
			s.HostIPC.Reset()
			if err := s.HostIPC.Decode(d); err != nil {
				return err
			}
		case "hostNetwork":
			s.HostNetwork.Reset()
			if err := s.HostNetwork.Decode(d); err != nil {
				return err
			}
		case "hostPID":
			s.HostPID.Reset()
			if err := s.HostPID.Decode(d); err != nil {
				return err
			}
		case "hostname":
			s.Hostname.Reset()
			if err := s.Hostname.Decode(d); err != nil {
				return err
			}
		case "imagePullSecrets":
			s.ImagePullSecrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1LocalObjectReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
				return nil
			}); err != nil {
				return err
			}
		case "initContainers":
			s.InitContainers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Container
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.InitContainers = append(s.InitContainers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "nodeName":
			s.NodeName.Reset()
			if err := s.NodeName.Decode(d); err != nil {
				return err
			}
		case "nodeSelector":
			s.NodeSelector.Reset()
			if err := s.NodeSelector.Decode(d); err != nil {
				return err
			}
		case "overhead":
			s.Overhead.Reset()
			if err := s.Overhead.Decode(d); err != nil {
				return err
			}
		case "preemptionPolicy":
			s.PreemptionPolicy.Reset()
			if err := s.PreemptionPolicy.Decode(d); err != nil {
				return err
			}
		case "priority":
			s.Priority.Reset()
			if err := s.Priority.Decode(d); err != nil {
				return err
			}
		case "priorityClassName":
			s.PriorityClassName.Reset()
			if err := s.PriorityClassName.Decode(d); err != nil {
				return err
			}
		case "readinessGates":
			s.ReadinessGates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodReadinessGate
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ReadinessGates = append(s.ReadinessGates, elem)
				return nil
			}); err != nil {
				return err
			}
		case "restartPolicy":
			s.RestartPolicy.Reset()
			if err := s.RestartPolicy.Decode(d); err != nil {
				return err
			}
		case "runtimeClassName":
			s.RuntimeClassName.Reset()
			if err := s.RuntimeClassName.Decode(d); err != nil {
				return err
			}
		case "schedulerName":
			s.SchedulerName.Reset()
			if err := s.SchedulerName.Decode(d); err != nil {
				return err
			}
		case "securityContext":
			s.SecurityContext.Reset()
			if err := s.SecurityContext.Decode(d); err != nil {
				return err
			}
		case "serviceAccount":
			s.ServiceAccount.Reset()
			if err := s.ServiceAccount.Decode(d); err != nil {
				return err
			}
		case "serviceAccountName":
			s.ServiceAccountName.Reset()
			if err := s.ServiceAccountName.Decode(d); err != nil {
				return err
			}
		case "setHostnameAsFQDN":
			s.SetHostnameAsFQDN.Reset()
			if err := s.SetHostnameAsFQDN.Decode(d); err != nil {
				return err
			}
		case "shareProcessNamespace":
			s.ShareProcessNamespace.Reset()
			if err := s.ShareProcessNamespace.Decode(d); err != nil {
				return err
			}
		case "subdomain":
			s.Subdomain.Reset()
			if err := s.Subdomain.Decode(d); err != nil {
				return err
			}
		case "terminationGracePeriodSeconds":
			s.TerminationGracePeriodSeconds.Reset()
			if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
				return err
			}
		case "tolerations":
			s.Tolerations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Toleration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tolerations = append(s.Tolerations, elem)
				return nil
			}); err != nil {
				return err
			}
		case "topologySpreadConstraints":
			s.TopologySpreadConstraints = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1TopologySpreadConstraint
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TopologySpreadConstraints = append(s.TopologySpreadConstraints, elem)
				return nil
			}); err != nil {
				return err
			}
		case "volumes":
			s.Volumes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Volume
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Volumes = append(s.Volumes, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerStatuses != nil {
			e.RawStr("\"containerStatuses\"" + ":")
			e.ArrStart()
			if len(s.ContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.ContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EphemeralContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EphemeralContainerStatuses != nil {
			e.RawStr("\"ephemeralContainerStatuses\"" + ":")
			e.ArrStart()
			if len(s.EphemeralContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EphemeralContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.EphemeralContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostIP.Set {
			e.RawStr("\"hostIP\"" + ":")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.InitContainerStatuses != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitContainerStatuses != nil {
			e.RawStr("\"initContainerStatuses\"" + ":")
			e.ArrStart()
			if len(s.InitContainerStatuses) >= 1 {
				// Encode first element without comma.
				{
					elem := s.InitContainerStatuses[0]
					elem.Encode(e)
				}
				for _, elem := range s.InitContainerStatuses[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.NominatedNodeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NominatedNodeName.Set {
			e.RawStr("\"nominatedNodeName\"" + ":")
			s.NominatedNodeName.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Phase.Set {
			e.RawStr("\"phase\"" + ":")
			s.Phase.Encode(e)
		}
	}
	{
		if s.PodIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodIP.Set {
			e.RawStr("\"podIP\"" + ":")
			s.PodIP.Encode(e)
		}
	}
	{
		if s.PodIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodIPs != nil {
			e.RawStr("\"podIPs\"" + ":")
			e.ArrStart()
			if len(s.PodIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PodIPs[0]
					elem.Encode(e)
				}
				for _, elem := range s.PodIPs[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.QosClass.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QosClass.Set {
			e.RawStr("\"qosClass\"" + ":")
			s.QosClass.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartTime.Set {
			e.RawStr("\"startTime\"" + ":")
			s.StartTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodStatus = [13]string{
	0:  "conditions",
	1:  "containerStatuses",
	2:  "ephemeralContainerStatuses",
	3:  "hostIP",
	4:  "initContainerStatuses",
	5:  "message",
	6:  "nominatedNodeName",
	7:  "phase",
	8:  "podIP",
	9:  "podIPs",
	10: "qosClass",
	11: "reason",
	12: "startTime",
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (s *IoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "containerStatuses":
			s.ContainerStatuses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ContainerStatuses = append(s.ContainerStatuses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ephemeralContainerStatuses":
			s.EphemeralContainerStatuses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EphemeralContainerStatuses = append(s.EphemeralContainerStatuses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "hostIP":
			s.HostIP.Reset()
			if err := s.HostIP.Decode(d); err != nil {
				return err
			}
		case "initContainerStatuses":
			s.InitContainerStatuses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ContainerStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.InitContainerStatuses = append(s.InitContainerStatuses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "nominatedNodeName":
			s.NominatedNodeName.Reset()
			if err := s.NominatedNodeName.Decode(d); err != nil {
				return err
			}
		case "phase":
			s.Phase.Reset()
			if err := s.Phase.Decode(d); err != nil {
				return err
			}
		case "podIP":
			s.PodIP.Reset()
			if err := s.PodIP.Decode(d); err != nil {
				return err
			}
		case "podIPs":
			s.PodIPs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodIP
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PodIPs = append(s.PodIPs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "qosClass":
			s.QosClass.Reset()
			if err := s.QosClass.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "startTime":
			s.StartTime.Reset()
			if err := s.StartTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Template.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplate = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1PodTemplate from json.
func (s *IoK8sAPICoreV1PodTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodTemplate to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "template":
			s.Template.Reset()
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplateList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodTemplateList from json.
func (s *IoK8sAPICoreV1PodTemplateList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodTemplateList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1PodTemplate
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (s *IoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PodTemplateSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PortStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Error.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Error.Set {
			e.RawStr("\"error\"" + ":")
			s.Error.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		e.Comma()

		e.RawStr("\"protocol\"" + ":")
		e.Str(s.Protocol)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PortStatus = [3]string{
	0: "error",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPICoreV1PortStatus from json.
func (s *IoK8sAPICoreV1PortStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PortStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			s.Error.Reset()
			if err := s.Error.Decode(d); err != nil {
				return err
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.Port = int32(v)
			if err != nil {
				return err
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Protocol = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumeID\"" + ":")
		e.Str(s.VolumeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource = [3]string{
	0: "fsType",
	1: "readOnly",
	2: "volumeID",
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (s *IoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PortworxVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.VolumeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PreferredSchedulingTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"preference\"" + ":")
		s.Preference.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"weight\"" + ":")
		e.Int32(s.Weight)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm = [2]string{
	0: "preference",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1PreferredSchedulingTerm from json.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1PreferredSchedulingTerm to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preference":
			requiredBitSet[0] |= 1 << 0
			if err := s.Preference.Decode(d); err != nil {
				return err
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.Weight = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Probe) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Exec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exec.Set {
			e.RawStr("\"exec\"" + ":")
			s.Exec.Encode(e)
		}
	}
	{
		if s.FailureThreshold.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FailureThreshold.Set {
			e.RawStr("\"failureThreshold\"" + ":")
			s.FailureThreshold.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HttpGet.Set {
			e.RawStr("\"httpGet\"" + ":")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.InitialDelaySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitialDelaySeconds.Set {
			e.RawStr("\"initialDelaySeconds\"" + ":")
			s.InitialDelaySeconds.Encode(e)
		}
	}
	{
		if s.PeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PeriodSeconds.Set {
			e.RawStr("\"periodSeconds\"" + ":")
			s.PeriodSeconds.Encode(e)
		}
	}
	{
		if s.SuccessThreshold.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SuccessThreshold.Set {
			e.RawStr("\"successThreshold\"" + ":")
			s.SuccessThreshold.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TcpSocket.Set {
			e.RawStr("\"tcpSocket\"" + ":")
			s.TcpSocket.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TerminationGracePeriodSeconds.Set {
			e.RawStr("\"terminationGracePeriodSeconds\"" + ":")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.TimeoutSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TimeoutSeconds.Set {
			e.RawStr("\"timeoutSeconds\"" + ":")
			s.TimeoutSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Probe = [9]string{
	0: "exec",
	1: "failureThreshold",
	2: "httpGet",
	3: "initialDelaySeconds",
	4: "periodSeconds",
	5: "successThreshold",
	6: "tcpSocket",
	7: "terminationGracePeriodSeconds",
	8: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (s *IoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Probe to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			s.Exec.Reset()
			if err := s.Exec.Decode(d); err != nil {
				return err
			}
		case "failureThreshold":
			s.FailureThreshold.Reset()
			if err := s.FailureThreshold.Decode(d); err != nil {
				return err
			}
		case "httpGet":
			s.HttpGet.Reset()
			if err := s.HttpGet.Decode(d); err != nil {
				return err
			}
		case "initialDelaySeconds":
			s.InitialDelaySeconds.Reset()
			if err := s.InitialDelaySeconds.Decode(d); err != nil {
				return err
			}
		case "periodSeconds":
			s.PeriodSeconds.Reset()
			if err := s.PeriodSeconds.Decode(d); err != nil {
				return err
			}
		case "successThreshold":
			s.SuccessThreshold.Reset()
			if err := s.SuccessThreshold.Decode(d); err != nil {
				return err
			}
		case "tcpSocket":
			s.TcpSocket.Reset()
			if err := s.TcpSocket.Decode(d); err != nil {
				return err
			}
		case "terminationGracePeriodSeconds":
			s.TerminationGracePeriodSeconds.Reset()
			if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
				return err
			}
		case "timeoutSeconds":
			s.TimeoutSeconds.Reset()
			if err := s.TimeoutSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Sources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sources != nil {
			e.RawStr("\"sources\"" + ":")
			e.ArrStart()
			if len(s.Sources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Sources[0]
					elem.Encode(e)
				}
				for _, elem := range s.Sources[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ProjectedVolumeSource = [2]string{
	0: "defaultMode",
	1: "sources",
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ProjectedVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			s.DefaultMode.Reset()
			if err := s.DefaultMode.Decode(d); err != nil {
				return err
			}
		case "sources":
			s.Sources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1VolumeProjection
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Sources = append(s.Sources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"registry\"" + ":")
		e.Str(s.Registry)
	}
	{
		if s.Tenant.Set {
			e.Comma()
		}
		if s.Tenant.Set {
			e.RawStr("\"tenant\"" + ":")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"volume\"" + ":")
		e.Str(s.Volume)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource = [6]string{
	0: "group",
	1: "readOnly",
	2: "registry",
	3: "tenant",
	4: "user",
	5: "volume",
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1QuobyteVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			s.Group.Reset()
			if err := s.Group.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "registry":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Registry = string(v)
			if err != nil {
				return err
			}
		case "tenant":
			s.Tenant.Reset()
			if err := s.Tenant.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "volume":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Volume = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.Comma()
		}
		if s.Keyring.Set {
			e.RawStr("\"keyring\"" + ":")
			s.Keyring.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.Comma()
		}
		if s.Pool.Set {
			e.RawStr("\"pool\"" + ":")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1RBDPersistentVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Image = string(v)
			if err != nil {
				return err
			}
		case "keyring":
			s.Keyring.Reset()
			if err := s.Keyring.Decode(d); err != nil {
				return err
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			s.Monitors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Monitors = append(s.Monitors, elem)
				return nil
			}); err != nil {
				return err
			}
		case "pool":
			s.Pool.Reset()
			if err := s.Pool.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"image\"" + ":")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.Comma()
		}
		if s.Keyring.Set {
			e.RawStr("\"keyring\"" + ":")
			s.Keyring.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"monitors\"" + ":")
		e.ArrStart()
		if len(s.Monitors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Monitors[0]
				e.Str(elem)
			}
			for _, elem := range s.Monitors[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.Comma()
		}
		if s.Pool.Set {
			e.RawStr("\"pool\"" + ":")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.Comma()
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (s *IoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1RBDVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Image = string(v)
			if err != nil {
				return err
			}
		case "keyring":
			s.Keyring.Reset()
			if err := s.Keyring.Decode(d); err != nil {
				return err
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			s.Monitors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Monitors = append(s.Monitors, elem)
				return nil
			}); err != nil {
				return err
			}
		case "pool":
			s.Pool.Reset()
			if err := s.Pool.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationController) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationController = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ReplicationController from json.
func (s *IoK8sAPICoreV1ReplicationController) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ReplicationController to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerCondition from json.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ReplicationControllerCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerList from json.
func (s *IoK8sAPICoreV1ReplicationControllerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ReplicationControllerList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ReplicationController
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MinReadySeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinReadySeconds.Set {
			e.RawStr("\"minReadySeconds\"" + ":")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Replicas.Set {
			e.RawStr("\"replicas\"" + ":")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Template.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Template.Set {
			e.RawStr("\"template\"" + ":")
			s.Template.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ReplicationControllerSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			s.MinReadySeconds.Reset()
			if err := s.MinReadySeconds.Decode(d); err != nil {
				return err
			}
		case "replicas":
			s.Replicas.Reset()
			if err := s.Replicas.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "template":
			s.Template.Reset()
			if err := s.Template.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AvailableReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvailableReplicas.Set {
			e.RawStr("\"availableReplicas\"" + ":")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullyLabeledReplicas.Set {
			e.RawStr("\"fullyLabeledReplicas\"" + ":")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadyReplicas.Set {
			e.RawStr("\"readyReplicas\"" + ":")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"replicas\"" + ":")
		e.Int32(s.Replicas)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ReplicationControllerStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			s.AvailableReplicas.Reset()
			if err := s.AvailableReplicas.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ReplicationControllerCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "fullyLabeledReplicas":
			s.FullyLabeledReplicas.Reset()
			if err := s.FullyLabeledReplicas.Decode(d); err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "readyReplicas":
			s.ReadyReplicas.Reset()
			if err := s.ReadyReplicas.Decode(d); err != nil {
				return err
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Int32()
			s.Replicas = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ContainerName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContainerName.Set {
			e.RawStr("\"containerName\"" + ":")
			s.ContainerName.Encode(e)
		}
	}
	{
		if s.Divisor.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Divisor.Set {
			e.RawStr("\"divisor\"" + ":")
			s.Divisor.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"resource\"" + ":")
		e.Str(s.Resource)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector = [3]string{
	0: "containerName",
	1: "divisor",
	2: "resource",
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (s *IoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceFieldSelector to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerName":
			s.ContainerName.Reset()
			if err := s.ContainerName.Decode(d); err != nil {
				return err
			}
		case "divisor":
			s.Divisor.Reset()
			if err := s.Divisor.Decode(d); err != nil {
				return err
			}
		case "resource":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Resource = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuota) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuota = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ResourceQuota from json.
func (s *IoK8sAPICoreV1ResourceQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceQuota to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaList from json.
func (s *IoK8sAPICoreV1ResourceQuotaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceQuotaList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ResourceQuota
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hard.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hard.Set {
			e.RawStr("\"hard\"" + ":")
			s.Hard.Encode(e)
		}
	}
	{
		if s.ScopeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScopeSelector.Set {
			e.RawStr("\"scopeSelector\"" + ":")
			s.ScopeSelector.Encode(e)
		}
	}
	{
		if s.Scopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes != nil {
			e.RawStr("\"scopes\"" + ":")
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaSpec = [3]string{
	0: "hard",
	1: "scopeSelector",
	2: "scopes",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceQuotaSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			s.Hard.Reset()
			if err := s.Hard.Decode(d); err != nil {
				return err
			}
		case "scopeSelector":
			s.ScopeSelector.Reset()
			if err := s.ScopeSelector.Decode(d); err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hard.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hard.Set {
			e.RawStr("\"hard\"" + ":")
			s.Hard.Encode(e)
		}
	}
	{
		if s.Used.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Used.Set {
			e.RawStr("\"used\"" + ":")
			s.Used.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaStatus = [2]string{
	0: "hard",
	1: "used",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			s.Hard.Reset()
			if err := s.Hard.Decode(d); err != nil {
				return err
			}
		case "used":
			s.Used.Reset()
			if err := s.Used.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limits.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limits.Set {
			e.RawStr("\"limits\"" + ":")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Requests.Set {
			e.RawStr("\"requests\"" + ":")
			s.Requests.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceRequirements = [2]string{
	0: "limits",
	1: "requests",
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (s *IoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ResourceRequirements to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			s.Limits.Reset()
			if err := s.Limits.Decode(d); err != nil {
				return err
			}
		case "requests":
			s.Requests.Reset()
			if err := s.Requests.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Level.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Level.Set {
			e.RawStr("\"level\"" + ":")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SELinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (s *IoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SELinuxOptions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			s.Level.Reset()
			if err := s.Level.Decode(d); err != nil {
				return err
			}
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"gateway\"" + ":")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.Comma()
		}
		if s.ProtectionDomain.Set {
			e.RawStr("\"protectionDomain\"" + ":")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"secretRef\"" + ":")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.Comma()
		}
		if s.SslEnabled.Set {
			e.RawStr("\"sslEnabled\"" + ":")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.Comma()
		}
		if s.StorageMode.Set {
			e.RawStr("\"storageMode\"" + ":")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.Comma()
		}
		if s.StoragePool.Set {
			e.RawStr("\"storagePool\"" + ":")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"system\"" + ":")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.Comma()
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Gateway = string(v)
			if err != nil {
				return err
			}
		case "protectionDomain":
			s.ProtectionDomain.Reset()
			if err := s.ProtectionDomain.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "sslEnabled":
			s.SslEnabled.Reset()
			if err := s.SslEnabled.Decode(d); err != nil {
				return err
			}
		case "storageMode":
			s.StorageMode.Reset()
			if err := s.StorageMode.Decode(d); err != nil {
				return err
			}
		case "storagePool":
			s.StoragePool.Reset()
			if err := s.StoragePool.Decode(d); err != nil {
				return err
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.System = string(v)
			if err != nil {
				return err
			}
		case "volumeName":
			s.VolumeName.Reset()
			if err := s.VolumeName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"gateway\"" + ":")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.Comma()
		}
		if s.ProtectionDomain.Set {
			e.RawStr("\"protectionDomain\"" + ":")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"secretRef\"" + ":")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.Comma()
		}
		if s.SslEnabled.Set {
			e.RawStr("\"sslEnabled\"" + ":")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.Comma()
		}
		if s.StorageMode.Set {
			e.RawStr("\"storageMode\"" + ":")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.Comma()
		}
		if s.StoragePool.Set {
			e.RawStr("\"storagePool\"" + ":")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"system\"" + ":")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.Comma()
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ScaleIOVolumeSource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Gateway = string(v)
			if err != nil {
				return err
			}
		case "protectionDomain":
			s.ProtectionDomain.Reset()
			if err := s.ProtectionDomain.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "sslEnabled":
			s.SslEnabled.Reset()
			if err := s.SslEnabled.Decode(d); err != nil {
				return err
			}
		case "storageMode":
			s.StorageMode.Reset()
			if err := s.StorageMode.Decode(d); err != nil {
				return err
			}
		case "storagePool":
			s.StoragePool.Reset()
			if err := s.StoragePool.Decode(d); err != nil {
				return err
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.System = string(v)
			if err != nil {
				return err
			}
		case "volumeName":
			s.VolumeName.Reset()
			if err := s.VolumeName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScopeSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopeSelector = [1]string{
	0: "matchExpressions",
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (s *IoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ScopeSelector to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			s.MatchExpressions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ScopedResourceSelectorRequirement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MatchExpressions = append(s.MatchExpressions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ScopedResourceSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		e.Comma()

		e.RawStr("\"scopeName\"" + ":")
		e.Str(s.ScopeName)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement = [3]string{
	0: "operator",
	1: "scopeName",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1ScopedResourceSelectorRequirement from json.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ScopedResourceSelectorRequirement to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operator":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Operator = string(v)
			if err != nil {
				return err
			}
		case "scopeName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ScopeName = string(v)
			if err != nil {
				return err
			}
		case "values":
			s.Values = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Values = append(s.Values, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SeccompProfile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LocalhostProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocalhostProfile.Set {
			e.RawStr("\"localhostProfile\"" + ":")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (s *IoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SeccompProfile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			s.LocalhostProfile.Reset()
			if err := s.LocalhostProfile.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Secret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Immutable.Set {
			e.RawStr("\"immutable\"" + ":")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.StringData.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StringData.Set {
			e.RawStr("\"stringData\"" + ":")
			s.StringData.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Secret = [7]string{
	0: "apiVersion",
	1: "data",
	2: "immutable",
	3: "kind",
	4: "metadata",
	5: "stringData",
	6: "type",
}

// Decode decodes IoK8sAPICoreV1Secret from json.
func (s *IoK8sAPICoreV1Secret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Secret to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data.Reset()
			if err := s.Data.Decode(d); err != nil {
				return err
			}
		case "immutable":
			s.Immutable.Reset()
			if err := s.Immutable.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "stringData":
			s.StringData.Reset()
			if err := s.StringData.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (s *IoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretEnvSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.Comma()
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (s *IoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretKeySelector to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1SecretList from json.
func (s *IoK8sAPICoreV1SecretList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Secret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (s *IoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretProjection to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1KeyToPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretReference = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (s *IoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretReference to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultMode.Set {
			e.RawStr("\"defaultMode\"" + ":")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			e.ArrStart()
			if len(s.Items) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Items[0]
					elem.Encode(e)
				}
				for _, elem := range s.Items[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Optional.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Optional.Set {
			e.RawStr("\"optional\"" + ":")
			s.Optional.Encode(e)
		}
	}
	{
		if s.SecretName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretName.Set {
			e.RawStr("\"secretName\"" + ":")
			s.SecretName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "optional",
	3: "secretName",
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (s *IoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecretVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			s.DefaultMode.Reset()
			if err := s.DefaultMode.Decode(d); err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1KeyToPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "optional":
			s.Optional.Reset()
			if err := s.Optional.Decode(d); err != nil {
				return err
			}
		case "secretName":
			s.SecretName.Reset()
			if err := s.SecretName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecurityContext) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowPrivilegeEscalation.Set {
			e.RawStr("\"allowPrivilegeEscalation\"" + ":")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capabilities.Set {
			e.RawStr("\"capabilities\"" + ":")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privileged.Set {
			e.RawStr("\"privileged\"" + ":")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProcMount.Set {
			e.RawStr("\"procMount\"" + ":")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnlyRootFilesystem.Set {
			e.RawStr("\"readOnlyRootFilesystem\"" + ":")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsNonRoot.Set {
			e.RawStr("\"runAsNonRoot\"" + ":")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUser.Set {
			e.RawStr("\"runAsUser\"" + ":")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SeccompProfile.Set {
			e.RawStr("\"seccompProfile\"" + ":")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WindowsOptions.Set {
			e.RawStr("\"windowsOptions\"" + ":")
			s.WindowsOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (s *IoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SecurityContext to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			s.AllowPrivilegeEscalation.Reset()
			if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
				return err
			}
		case "capabilities":
			s.Capabilities.Reset()
			if err := s.Capabilities.Decode(d); err != nil {
				return err
			}
		case "privileged":
			s.Privileged.Reset()
			if err := s.Privileged.Decode(d); err != nil {
				return err
			}
		case "procMount":
			s.ProcMount.Reset()
			if err := s.ProcMount.Decode(d); err != nil {
				return err
			}
		case "readOnlyRootFilesystem":
			s.ReadOnlyRootFilesystem.Reset()
			if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
				return err
			}
		case "runAsGroup":
			s.RunAsGroup.Reset()
			if err := s.RunAsGroup.Decode(d); err != nil {
				return err
			}
		case "runAsNonRoot":
			s.RunAsNonRoot.Reset()
			if err := s.RunAsNonRoot.Decode(d); err != nil {
				return err
			}
		case "runAsUser":
			s.RunAsUser.Reset()
			if err := s.RunAsUser.Decode(d); err != nil {
				return err
			}
		case "seLinuxOptions":
			s.SeLinuxOptions.Reset()
			if err := s.SeLinuxOptions.Decode(d); err != nil {
				return err
			}
		case "seccompProfile":
			s.SeccompProfile.Reset()
			if err := s.SeccompProfile.Decode(d); err != nil {
				return err
			}
		case "windowsOptions":
			s.WindowsOptions.Reset()
			if err := s.WindowsOptions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Service) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Service = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Service from json.
func (s *IoK8sAPICoreV1Service) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Service to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutomountServiceAccountToken.Set {
			e.RawStr("\"automountServiceAccountToken\"" + ":")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ImagePullSecrets != nil {
			e.RawStr("\"imagePullSecrets\"" + ":")
			e.ArrStart()
			if len(s.ImagePullSecrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ImagePullSecrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.ImagePullSecrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Secrets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secrets != nil {
			e.RawStr("\"secrets\"" + ":")
			e.ArrStart()
			if len(s.Secrets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Secrets[0]
					elem.Encode(e)
				}
				for _, elem := range s.Secrets[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccount = [6]string{
	0: "apiVersion",
	1: "automountServiceAccountToken",
	2: "imagePullSecrets",
	3: "kind",
	4: "metadata",
	5: "secrets",
}

// Decode decodes IoK8sAPICoreV1ServiceAccount from json.
func (s *IoK8sAPICoreV1ServiceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceAccount to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "automountServiceAccountToken":
			s.AutomountServiceAccountToken.Reset()
			if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
				return err
			}
		case "imagePullSecrets":
			s.ImagePullSecrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1LocalObjectReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ObjectReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccountList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountList from json.
func (s *IoK8sAPICoreV1ServiceAccountList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceAccountList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ServiceAccount
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Audience.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Audience.Set {
			e.RawStr("\"audience\"" + ":")
			s.Audience.Encode(e)
		}
	}
	{
		if s.ExpirationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection = [3]string{
	0: "audience",
	1: "expirationSeconds",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceAccountTokenProjection to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			s.Audience.Reset()
			if err := s.Audience.Decode(d); err != nil {
				return err
			}
		case "expirationSeconds":
			s.ExpirationSeconds.Reset()
			if err := s.ExpirationSeconds.Decode(d); err != nil {
				return err
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceList from json.
func (s *IoK8sAPICoreV1ServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Service
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServicePort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodePort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodePort.Set {
			e.RawStr("\"nodePort\"" + ":")
			s.NodePort.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.Comma()
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.TargetPort.Set {
			e.Comma()
		}
		if s.TargetPort.Set {
			e.RawStr("\"targetPort\"" + ":")
			s.TargetPort.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServicePort = [6]string{
	0: "appProtocol",
	1: "name",
	2: "nodePort",
	3: "port",
	4: "protocol",
	5: "targetPort",
}

// Decode decodes IoK8sAPICoreV1ServicePort from json.
func (s *IoK8sAPICoreV1ServicePort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServicePort to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			s.AppProtocol.Reset()
			if err := s.AppProtocol.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "nodePort":
			s.NodePort.Reset()
			if err := s.NodePort.Decode(d); err != nil {
				return err
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int32()
			s.Port = int32(v)
			if err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		case "targetPort":
			s.TargetPort.Reset()
			if err := s.TargetPort.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServicePort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServicePort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllocateLoadBalancerNodePorts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllocateLoadBalancerNodePorts.Set {
			e.RawStr("\"allocateLoadBalancerNodePorts\"" + ":")
			s.AllocateLoadBalancerNodePorts.Encode(e)
		}
	}
	{
		if s.ClusterIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterIP.Set {
			e.RawStr("\"clusterIP\"" + ":")
			s.ClusterIP.Encode(e)
		}
	}
	{
		if s.ClusterIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterIPs != nil {
			e.RawStr("\"clusterIPs\"" + ":")
			e.ArrStart()
			if len(s.ClusterIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ClusterIPs[0]
					e.Str(elem)
				}
				for _, elem := range s.ClusterIPs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalIPs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalIPs != nil {
			e.RawStr("\"externalIPs\"" + ":")
			e.ArrStart()
			if len(s.ExternalIPs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ExternalIPs[0]
					e.Str(elem)
				}
				for _, elem := range s.ExternalIPs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalName.Set {
			e.RawStr("\"externalName\"" + ":")
			s.ExternalName.Encode(e)
		}
	}
	{
		if s.ExternalTrafficPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalTrafficPolicy.Set {
			e.RawStr("\"externalTrafficPolicy\"" + ":")
			s.ExternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.HealthCheckNodePort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HealthCheckNodePort.Set {
			e.RawStr("\"healthCheckNodePort\"" + ":")
			s.HealthCheckNodePort.Encode(e)
		}
	}
	{
		if s.InternalTrafficPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InternalTrafficPolicy.Set {
			e.RawStr("\"internalTrafficPolicy\"" + ":")
			s.InternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.IpFamilies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpFamilies != nil {
			e.RawStr("\"ipFamilies\"" + ":")
			e.ArrStart()
			if len(s.IpFamilies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.IpFamilies[0]
					e.Str(elem)
				}
				for _, elem := range s.IpFamilies[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.IpFamilyPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpFamilyPolicy.Set {
			e.RawStr("\"ipFamilyPolicy\"" + ":")
			s.IpFamilyPolicy.Encode(e)
		}
	}
	{
		if s.LoadBalancerClass.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerClass.Set {
			e.RawStr("\"loadBalancerClass\"" + ":")
			s.LoadBalancerClass.Encode(e)
		}
	}
	{
		if s.LoadBalancerIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerIP.Set {
			e.RawStr("\"loadBalancerIP\"" + ":")
			s.LoadBalancerIP.Encode(e)
		}
	}
	{
		if s.LoadBalancerSourceRanges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancerSourceRanges != nil {
			e.RawStr("\"loadBalancerSourceRanges\"" + ":")
			e.ArrStart()
			if len(s.LoadBalancerSourceRanges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LoadBalancerSourceRanges[0]
					e.Str(elem)
				}
				for _, elem := range s.LoadBalancerSourceRanges[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.PublishNotReadyAddresses.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublishNotReadyAddresses.Set {
			e.RawStr("\"publishNotReadyAddresses\"" + ":")
			s.PublishNotReadyAddresses.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	{
		if s.SessionAffinity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SessionAffinity.Set {
			e.RawStr("\"sessionAffinity\"" + ":")
			s.SessionAffinity.Encode(e)
		}
	}
	{
		if s.SessionAffinityConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SessionAffinityConfig.Set {
			e.RawStr("\"sessionAffinityConfig\"" + ":")
			s.SessionAffinityConfig.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceSpec = [19]string{
	0:  "allocateLoadBalancerNodePorts",
	1:  "clusterIP",
	2:  "clusterIPs",
	3:  "externalIPs",
	4:  "externalName",
	5:  "externalTrafficPolicy",
	6:  "healthCheckNodePort",
	7:  "internalTrafficPolicy",
	8:  "ipFamilies",
	9:  "ipFamilyPolicy",
	10: "loadBalancerClass",
	11: "loadBalancerIP",
	12: "loadBalancerSourceRanges",
	13: "ports",
	14: "publishNotReadyAddresses",
	15: "selector",
	16: "sessionAffinity",
	17: "sessionAffinityConfig",
	18: "type",
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (s *IoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocateLoadBalancerNodePorts":
			s.AllocateLoadBalancerNodePorts.Reset()
			if err := s.AllocateLoadBalancerNodePorts.Decode(d); err != nil {
				return err
			}
		case "clusterIP":
			s.ClusterIP.Reset()
			if err := s.ClusterIP.Decode(d); err != nil {
				return err
			}
		case "clusterIPs":
			s.ClusterIPs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ClusterIPs = append(s.ClusterIPs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "externalIPs":
			s.ExternalIPs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ExternalIPs = append(s.ExternalIPs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "externalName":
			s.ExternalName.Reset()
			if err := s.ExternalName.Decode(d); err != nil {
				return err
			}
		case "externalTrafficPolicy":
			s.ExternalTrafficPolicy.Reset()
			if err := s.ExternalTrafficPolicy.Decode(d); err != nil {
				return err
			}
		case "healthCheckNodePort":
			s.HealthCheckNodePort.Reset()
			if err := s.HealthCheckNodePort.Decode(d); err != nil {
				return err
			}
		case "internalTrafficPolicy":
			s.InternalTrafficPolicy.Reset()
			if err := s.InternalTrafficPolicy.Decode(d); err != nil {
				return err
			}
		case "ipFamilies":
			s.IpFamilies = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.IpFamilies = append(s.IpFamilies, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ipFamilyPolicy":
			s.IpFamilyPolicy.Reset()
			if err := s.IpFamilyPolicy.Decode(d); err != nil {
				return err
			}
		case "loadBalancerClass":
			s.LoadBalancerClass.Reset()
			if err := s.LoadBalancerClass.Decode(d); err != nil {
				return err
			}
		case "loadBalancerIP":
			s.LoadBalancerIP.Reset()
			if err := s.LoadBalancerIP.Decode(d); err != nil {
				return err
			}
		case "loadBalancerSourceRanges":
			s.LoadBalancerSourceRanges = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.LoadBalancerSourceRanges = append(s.LoadBalancerSourceRanges, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1ServicePort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		case "publishNotReadyAddresses":
			s.PublishNotReadyAddresses.Reset()
			if err := s.PublishNotReadyAddresses.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		case "sessionAffinity":
			s.SessionAffinity.Reset()
			if err := s.SessionAffinity.Decode(d); err != nil {
				return err
			}
		case "sessionAffinityConfig":
			s.SessionAffinityConfig.Reset()
			if err := s.SessionAffinityConfig.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LoadBalancer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancer.Set {
			e.RawStr("\"loadBalancer\"" + ":")
			s.LoadBalancer.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceStatus = [2]string{
	0: "conditions",
	1: "loadBalancer",
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (s *IoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1ServiceStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1Condition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "loadBalancer":
			s.LoadBalancer.Reset()
			if err := s.LoadBalancer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClientIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientIP.Set {
			e.RawStr("\"clientIP\"" + ":")
			s.ClientIP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1SessionAffinityConfig = [1]string{
	0: "clientIP",
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (s *IoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1SessionAffinityConfig to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientIP":
			s.ClientIP.Reset()
			if err := s.ClientIP.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeNamespace.Set {
			e.RawStr("\"volumeNamespace\"" + ":")
			s.VolumeNamespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSPersistentVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1StorageOSPersistentVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "volumeName":
			s.VolumeName.Reset()
			if err := s.VolumeName.Decode(d); err != nil {
				return err
			}
		case "volumeNamespace":
			s.VolumeNamespace.Reset()
			if err := s.VolumeNamespace.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretRef.Set {
			e.RawStr("\"secretRef\"" + ":")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeName.Set {
			e.RawStr("\"volumeName\"" + ":")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeNamespace.Set {
			e.RawStr("\"volumeNamespace\"" + ":")
			s.VolumeNamespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1StorageOSVolumeSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "secretRef":
			s.SecretRef.Reset()
			if err := s.SecretRef.Decode(d); err != nil {
				return err
			}
		case "volumeName":
			s.VolumeName.Reset()
			if err := s.VolumeName.Decode(d); err != nil {
				return err
			}
		case "volumeNamespace":
			s.VolumeNamespace.Reset()
			if err := s.VolumeNamespace.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Sysctl) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Sysctl = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1Sysctl from json.
func (s *IoK8sAPICoreV1Sysctl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Sysctl to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Sysctl) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Sysctl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"port\"" + ":")
		s.Port.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction = [2]string{
	0: "host",
	1: "port",
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (s *IoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1TCPSocketAction to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Port = IoK8sApimachineryPkgUtilIntstrIntOrString(unwrapped)
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Taint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"effect\"" + ":")
		e.Str(s.Effect)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.TimeAdded.Set {
			e.Comma()
		}
		if s.TimeAdded.Set {
			e.RawStr("\"timeAdded\"" + ":")
			s.TimeAdded.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Taint = [4]string{
	0: "effect",
	1: "key",
	2: "timeAdded",
	3: "value",
}

// Decode decodes IoK8sAPICoreV1Taint from json.
func (s *IoK8sAPICoreV1Taint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Taint to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Effect = string(v)
			if err != nil {
				return err
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "timeAdded":
			s.TimeAdded.Reset()
			if err := s.TimeAdded.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Taint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Taint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Toleration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Effect.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Effect.Set {
			e.RawStr("\"effect\"" + ":")
			s.Effect.Encode(e)
		}
	}
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operator.Set {
			e.RawStr("\"operator\"" + ":")
			s.Operator.Encode(e)
		}
	}
	{
		if s.TolerationSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TolerationSeconds.Set {
			e.RawStr("\"tolerationSeconds\"" + ":")
			s.TolerationSeconds.Encode(e)
		}
	}
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Toleration = [5]string{
	0: "effect",
	1: "key",
	2: "operator",
	3: "tolerationSeconds",
	4: "value",
}

// Decode decodes IoK8sAPICoreV1Toleration from json.
func (s *IoK8sAPICoreV1Toleration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Toleration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			s.Effect.Reset()
			if err := s.Effect.Decode(d); err != nil {
				return err
			}
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		case "operator":
			s.Operator.Reset()
			if err := s.Operator.Decode(d); err != nil {
				return err
			}
		case "tolerationSeconds":
			s.TolerationSeconds.Reset()
			if err := s.TolerationSeconds.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySelectorLabelRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"values\"" + ":")
		e.ArrStart()
		if len(s.Values) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Values[0]
				e.Str(elem)
			}
			for _, elem := range s.Values[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement = [2]string{
	0: "key",
	1: "values",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorLabelRequirement from json.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1TopologySelectorLabelRequirement to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "values":
			requiredBitSet[0] |= 1 << 1
			s.Values = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Values = append(s.Values, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySelectorTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchLabelExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchLabelExpressions != nil {
			e.RawStr("\"matchLabelExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchLabelExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchLabelExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchLabelExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorTerm = [1]string{
	0: "matchLabelExpressions",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorTerm from json.
func (s *IoK8sAPICoreV1TopologySelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1TopologySelectorTerm to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchLabelExpressions":
			s.MatchLabelExpressions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1TopologySelectorLabelRequirement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MatchLabelExpressions = append(s.MatchLabelExpressions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TopologySpreadConstraint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelector.Set {
			e.RawStr("\"labelSelector\"" + ":")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"maxSkew\"" + ":")
		e.Int32(s.MaxSkew)
	}
	{
		e.Comma()

		e.RawStr("\"topologyKey\"" + ":")
		e.Str(s.TopologyKey)
	}
	{
		e.Comma()

		e.RawStr("\"whenUnsatisfiable\"" + ":")
		e.Str(s.WhenUnsatisfiable)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint = [4]string{
	0: "labelSelector",
	1: "maxSkew",
	2: "topologyKey",
	3: "whenUnsatisfiable",
}

// Decode decodes IoK8sAPICoreV1TopologySpreadConstraint from json.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1TopologySpreadConstraint to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			s.LabelSelector.Reset()
			if err := s.LabelSelector.Decode(d); err != nil {
				return err
			}
		case "maxSkew":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.MaxSkew = int32(v)
			if err != nil {
				return err
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.TopologyKey = string(v)
			if err != nil {
				return err
			}
		case "whenUnsatisfiable":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.WhenUnsatisfiable = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1TypedLocalObjectReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			s.ApiGroup.Reset()
			if err := s.ApiGroup.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1Volume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AwsElasticBlockStore.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AwsElasticBlockStore.Set {
			e.RawStr("\"awsElasticBlockStore\"" + ":")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureDisk.Set {
			e.RawStr("\"azureDisk\"" + ":")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AzureFile.Set {
			e.RawStr("\"azureFile\"" + ":")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cephfs.Set {
			e.RawStr("\"cephfs\"" + ":")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Cinder.Set {
			e.RawStr("\"cinder\"" + ":")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Csi.Set {
			e.RawStr("\"csi\"" + ":")
			s.Csi.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownwardAPI.Set {
			e.RawStr("\"downwardAPI\"" + ":")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.EmptyDir.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EmptyDir.Set {
			e.RawStr("\"emptyDir\"" + ":")
			s.EmptyDir.Encode(e)
		}
	}
	{
		if s.Ephemeral.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ephemeral.Set {
			e.RawStr("\"ephemeral\"" + ":")
			s.Ephemeral.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fc.Set {
			e.RawStr("\"fc\"" + ":")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FlexVolume.Set {
			e.RawStr("\"flexVolume\"" + ":")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Flocker.Set {
			e.RawStr("\"flocker\"" + ":")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GcePersistentDisk.Set {
			e.RawStr("\"gcePersistentDisk\"" + ":")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.GitRepo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRepo.Set {
			e.RawStr("\"gitRepo\"" + ":")
			s.GitRepo.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Glusterfs.Set {
			e.RawStr("\"glusterfs\"" + ":")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostPath.Set {
			e.RawStr("\"hostPath\"" + ":")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Iscsi.Set {
			e.RawStr("\"iscsi\"" + ":")
			s.Iscsi.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Nfs.Set {
			e.Comma()
		}
		if s.Nfs.Set {
			e.RawStr("\"nfs\"" + ":")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.PersistentVolumeClaim.Set {
			e.Comma()
		}
		if s.PersistentVolumeClaim.Set {
			e.RawStr("\"persistentVolumeClaim\"" + ":")
			s.PersistentVolumeClaim.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			e.Comma()
		}
		if s.PhotonPersistentDisk.Set {
			e.RawStr("\"photonPersistentDisk\"" + ":")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			e.Comma()
		}
		if s.PortworxVolume.Set {
			e.RawStr("\"portworxVolume\"" + ":")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Projected.Set {
			e.Comma()
		}
		if s.Projected.Set {
			e.RawStr("\"projected\"" + ":")
			s.Projected.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			e.Comma()
		}
		if s.Quobyte.Set {
			e.RawStr("\"quobyte\"" + ":")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			e.Comma()
		}
		if s.Rbd.Set {
			e.RawStr("\"rbd\"" + ":")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			e.Comma()
		}
		if s.ScaleIO.Set {
			e.RawStr("\"scaleIO\"" + ":")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			e.Comma()
		}
		if s.Storageos.Set {
			e.RawStr("\"storageos\"" + ":")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			e.Comma()
		}
		if s.VsphereVolume.Set {
			e.RawStr("\"vsphereVolume\"" + ":")
			s.VsphereVolume.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1Volume = [30]string{
	0:  "awsElasticBlockStore",
	1:  "azureDisk",
	2:  "azureFile",
	3:  "cephfs",
	4:  "cinder",
	5:  "configMap",
	6:  "csi",
	7:  "downwardAPI",
	8:  "emptyDir",
	9:  "ephemeral",
	10: "fc",
	11: "flexVolume",
	12: "flocker",
	13: "gcePersistentDisk",
	14: "gitRepo",
	15: "glusterfs",
	16: "hostPath",
	17: "iscsi",
	18: "name",
	19: "nfs",
	20: "persistentVolumeClaim",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "projected",
	24: "quobyte",
	25: "rbd",
	26: "scaleIO",
	27: "secret",
	28: "storageos",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1Volume from json.
func (s *IoK8sAPICoreV1Volume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1Volume to nil`)
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "awsElasticBlockStore":
			s.AwsElasticBlockStore.Reset()
			if err := s.AwsElasticBlockStore.Decode(d); err != nil {
				return err
			}
		case "azureDisk":
			s.AzureDisk.Reset()
			if err := s.AzureDisk.Decode(d); err != nil {
				return err
			}
		case "azureFile":
			s.AzureFile.Reset()
			if err := s.AzureFile.Decode(d); err != nil {
				return err
			}
		case "cephfs":
			s.Cephfs.Reset()
			if err := s.Cephfs.Decode(d); err != nil {
				return err
			}
		case "cinder":
			s.Cinder.Reset()
			if err := s.Cinder.Decode(d); err != nil {
				return err
			}
		case "configMap":
			s.ConfigMap.Reset()
			if err := s.ConfigMap.Decode(d); err != nil {
				return err
			}
		case "csi":
			s.Csi.Reset()
			if err := s.Csi.Decode(d); err != nil {
				return err
			}
		case "downwardAPI":
			s.DownwardAPI.Reset()
			if err := s.DownwardAPI.Decode(d); err != nil {
				return err
			}
		case "emptyDir":
			s.EmptyDir.Reset()
			if err := s.EmptyDir.Decode(d); err != nil {
				return err
			}
		case "ephemeral":
			s.Ephemeral.Reset()
			if err := s.Ephemeral.Decode(d); err != nil {
				return err
			}
		case "fc":
			s.Fc.Reset()
			if err := s.Fc.Decode(d); err != nil {
				return err
			}
		case "flexVolume":
			s.FlexVolume.Reset()
			if err := s.FlexVolume.Decode(d); err != nil {
				return err
			}
		case "flocker":
			s.Flocker.Reset()
			if err := s.Flocker.Decode(d); err != nil {
				return err
			}
		case "gcePersistentDisk":
			s.GcePersistentDisk.Reset()
			if err := s.GcePersistentDisk.Decode(d); err != nil {
				return err
			}
		case "gitRepo":
			s.GitRepo.Reset()
			if err := s.GitRepo.Decode(d); err != nil {
				return err
			}
		case "glusterfs":
			s.Glusterfs.Reset()
			if err := s.Glusterfs.Decode(d); err != nil {
				return err
			}
		case "hostPath":
			s.HostPath.Reset()
			if err := s.HostPath.Decode(d); err != nil {
				return err
			}
		case "iscsi":
			s.Iscsi.Reset()
			if err := s.Iscsi.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "nfs":
			s.Nfs.Reset()
			if err := s.Nfs.Decode(d); err != nil {
				return err
			}
		case "persistentVolumeClaim":
			s.PersistentVolumeClaim.Reset()
			if err := s.PersistentVolumeClaim.Decode(d); err != nil {
				return err
			}
		case "photonPersistentDisk":
			s.PhotonPersistentDisk.Reset()
			if err := s.PhotonPersistentDisk.Decode(d); err != nil {
				return err
			}
		case "portworxVolume":
			s.PortworxVolume.Reset()
			if err := s.PortworxVolume.Decode(d); err != nil {
				return err
			}
		case "projected":
			s.Projected.Reset()
			if err := s.Projected.Decode(d); err != nil {
				return err
			}
		case "quobyte":
			s.Quobyte.Reset()
			if err := s.Quobyte.Decode(d); err != nil {
				return err
			}
		case "rbd":
			s.Rbd.Reset()
			if err := s.Rbd.Decode(d); err != nil {
				return err
			}
		case "scaleIO":
			s.ScaleIO.Reset()
			if err := s.ScaleIO.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "storageos":
			s.Storageos.Reset()
			if err := s.Storageos.Decode(d); err != nil {
				return err
			}
		case "vsphereVolume":
			s.VsphereVolume.Reset()
			if err := s.VsphereVolume.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000000,
		0b00000000,
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Volume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Volume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeDevice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"devicePath\"" + ":")
		e.Str(s.DevicePath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1VolumeDevice from json.
func (s *IoK8sAPICoreV1VolumeDevice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1VolumeDevice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.DevicePath = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeMount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"mountPath\"" + ":")
		e.Str(s.MountPath)
	}
	{
		if s.MountPropagation.Set {
			e.Comma()
		}
		if s.MountPropagation.Set {
			e.RawStr("\"mountPropagation\"" + ":")
			s.MountPropagation.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SubPath.Set {
			e.Comma()
		}
		if s.SubPath.Set {
			e.RawStr("\"subPath\"" + ":")
			s.SubPath.Encode(e)
		}
	}
	{
		if s.SubPathExpr.Set {
			e.Comma()
		}
		if s.SubPathExpr.Set {
			e.RawStr("\"subPathExpr\"" + ":")
			s.SubPathExpr.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeMount = [6]string{
	0: "mountPath",
	1: "mountPropagation",
	2: "name",
	3: "readOnly",
	4: "subPath",
	5: "subPathExpr",
}

// Decode decodes IoK8sAPICoreV1VolumeMount from json.
func (s *IoK8sAPICoreV1VolumeMount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1VolumeMount to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mountPath":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.MountPath = string(v)
			if err != nil {
				return err
			}
		case "mountPropagation":
			s.MountPropagation.Reset()
			if err := s.MountPropagation.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "subPath":
			s.SubPath.Reset()
			if err := s.SubPath.Decode(d); err != nil {
				return err
			}
		case "subPathExpr":
			s.SubPathExpr.Reset()
			if err := s.SubPathExpr.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeMount) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeMount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Required.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Required.Set {
			e.RawStr("\"required\"" + ":")
			s.Required.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeNodeAffinity = [1]string{
	0: "required",
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1VolumeNodeAffinity to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required":
			s.Required.Reset()
			if err := s.Required.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VolumeProjection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ConfigMap.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigMap.Set {
			e.RawStr("\"configMap\"" + ":")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownwardAPI.Set {
			e.RawStr("\"downwardAPI\"" + ":")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.ServiceAccountToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ServiceAccountToken.Set {
			e.RawStr("\"serviceAccountToken\"" + ":")
			s.ServiceAccountToken.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeProjection = [4]string{
	0: "configMap",
	1: "downwardAPI",
	2: "secret",
	3: "serviceAccountToken",
}

// Decode decodes IoK8sAPICoreV1VolumeProjection from json.
func (s *IoK8sAPICoreV1VolumeProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1VolumeProjection to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			s.ConfigMap.Reset()
			if err := s.ConfigMap.Decode(d); err != nil {
				return err
			}
		case "downwardAPI":
			s.DownwardAPI.Reset()
			if err := s.DownwardAPI.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "serviceAccountToken":
			s.ServiceAccountToken.Reset()
			if err := s.ServiceAccountToken.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsType.Set {
			e.RawStr("\"fsType\"" + ":")
			s.FsType.Encode(e)
		}
	}
	{
		if s.StoragePolicyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoragePolicyID.Set {
			e.RawStr("\"storagePolicyID\"" + ":")
			s.StoragePolicyID.Encode(e)
		}
	}
	{
		if s.StoragePolicyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoragePolicyName.Set {
			e.RawStr("\"storagePolicyName\"" + ":")
			s.StoragePolicyName.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"volumePath\"" + ":")
		e.Str(s.VolumePath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource = [4]string{
	0: "fsType",
	1: "storagePolicyID",
	2: "storagePolicyName",
	3: "volumePath",
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			s.FsType.Reset()
			if err := s.FsType.Decode(d); err != nil {
				return err
			}
		case "storagePolicyID":
			s.StoragePolicyID.Reset()
			if err := s.StoragePolicyID.Decode(d); err != nil {
				return err
			}
		case "storagePolicyName":
			s.StoragePolicyName.Reset()
			if err := s.StoragePolicyName.Decode(d); err != nil {
				return err
			}
		case "volumePath":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.VolumePath = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1WeightedPodAffinityTerm) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"podAffinityTerm\"" + ":")
		s.PodAffinityTerm.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"weight\"" + ":")
		e.Int32(s.Weight)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm = [2]string{
	0: "podAffinityTerm",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1WeightedPodAffinityTerm from json.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1WeightedPodAffinityTerm to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 0
			if err := s.PodAffinityTerm.Decode(d); err != nil {
				return err
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.Weight = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GmsaCredentialSpec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GmsaCredentialSpec.Set {
			e.RawStr("\"gmsaCredentialSpec\"" + ":")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GmsaCredentialSpecName.Set {
			e.RawStr("\"gmsaCredentialSpecName\"" + ":")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HostProcess.Set {
			e.RawStr("\"hostProcess\"" + ":")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RunAsUserName.Set {
			e.RawStr("\"runAsUserName\"" + ":")
			s.RunAsUserName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPICoreV1WindowsSecurityContextOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPICoreV1WindowsSecurityContextOptions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			s.GmsaCredentialSpec.Reset()
			if err := s.GmsaCredentialSpec.Decode(d); err != nil {
				return err
			}
		case "gmsaCredentialSpecName":
			s.GmsaCredentialSpecName.Reset()
			if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
				return err
			}
		case "hostProcess":
			s.HostProcess.Reset()
			if err := s.HostProcess.Decode(d); err != nil {
				return err
			}
		case "runAsUserName":
			s.RunAsUserName.Reset()
			if err := s.RunAsUserName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1Endpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addresses\"" + ":")
		e.ArrStart()
		if len(s.Addresses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Addresses[0]
				e.Str(elem)
			}
			for _, elem := range s.Addresses[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.Comma()
		}
		if s.Conditions.Set {
			e.RawStr("\"conditions\"" + ":")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.DeprecatedTopology.Set {
			e.Comma()
		}
		if s.DeprecatedTopology.Set {
			e.RawStr("\"deprecatedTopology\"" + ":")
			s.DeprecatedTopology.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.Comma()
		}
		if s.Hints.Set {
			e.RawStr("\"hints\"" + ":")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.Comma()
		}
		if s.Zone.Set {
			e.RawStr("\"zone\"" + ":")
			s.Zone.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint = [8]string{
	0: "addresses",
	1: "conditions",
	2: "deprecatedTopology",
	3: "hints",
	4: "hostname",
	5: "nodeName",
	6: "targetRef",
	7: "zone",
}

// Decode decodes IoK8sAPIDiscoveryV1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1Endpoint to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			s.Addresses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Addresses = append(s.Addresses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "conditions":
			s.Conditions.Reset()
			if err := s.Conditions.Decode(d); err != nil {
				return err
			}
		case "deprecatedTopology":
			s.DeprecatedTopology.Reset()
			if err := s.DeprecatedTopology.Decode(d); err != nil {
				return err
			}
		case "hints":
			s.Hints.Reset()
			if err := s.Hints.Decode(d); err != nil {
				return err
			}
		case "hostname":
			s.Hostname.Reset()
			if err := s.Hostname.Decode(d); err != nil {
				return err
			}
		case "nodeName":
			s.NodeName.Reset()
			if err := s.NodeName.Decode(d); err != nil {
				return err
			}
		case "targetRef":
			s.TargetRef.Reset()
			if err := s.TargetRef.Decode(d); err != nil {
				return err
			}
		case "zone":
			s.Zone.Reset()
			if err := s.Zone.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ready.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ready.Set {
			e.RawStr("\"ready\"" + ":")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Serving.Set {
			e.RawStr("\"serving\"" + ":")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminating.Set {
			e.RawStr("\"terminating\"" + ":")
			s.Terminating.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1EndpointConditions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			s.Ready.Reset()
			if err := s.Ready.Decode(d); err != nil {
				return err
			}
		case "serving":
			s.Serving.Reset()
			if err := s.Serving.Decode(d); err != nil {
				return err
			}
		case "terminating":
			s.Terminating.Reset()
			if err := s.Terminating.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ForZones != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForZones != nil {
			e.RawStr("\"forZones\"" + ":")
			e.ArrStart()
			if len(s.ForZones) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForZones[0]
					elem.Encode(e)
				}
				for _, elem := range s.ForZones[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1EndpointHints to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			s.ForZones = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1ForZone
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ForZones = append(s.ForZones, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1EndpointPort to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			s.AppProtocol.Reset()
			if err := s.AppProtocol.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointSlice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addressType\"" + ":")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.Comma()
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"endpoints\"" + ":")
		e.ArrStart()
		if len(s.Endpoints) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Endpoints[0]
				elem.Encode(e)
			}
			for _, elem := range s.Endpoints[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSlice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.AddressType = string(v)
			if err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			s.Endpoints = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1Endpoint
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Endpoints = append(s.Endpoints, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1EndpointPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointSliceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSliceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1EndpointSlice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1ForZone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1ForZone from json.
func (s *IoK8sAPIDiscoveryV1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1ForZone to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1Endpoint) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addresses\"" + ":")
		e.ArrStart()
		if len(s.Addresses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Addresses[0]
				e.Str(elem)
			}
			for _, elem := range s.Addresses[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.Comma()
		}
		if s.Conditions.Set {
			e.RawStr("\"conditions\"" + ":")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.Comma()
		}
		if s.Hints.Set {
			e.RawStr("\"hints\"" + ":")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.Comma()
		}
		if s.Hostname.Set {
			e.RawStr("\"hostname\"" + ":")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.Comma()
		}
		if s.NodeName.Set {
			e.RawStr("\"nodeName\"" + ":")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.Comma()
		}
		if s.TargetRef.Set {
			e.RawStr("\"targetRef\"" + ":")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Topology.Set {
			e.Comma()
		}
		if s.Topology.Set {
			e.RawStr("\"topology\"" + ":")
			s.Topology.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint = [7]string{
	0: "addresses",
	1: "conditions",
	2: "hints",
	3: "hostname",
	4: "nodeName",
	5: "targetRef",
	6: "topology",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1Endpoint to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			s.Addresses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Addresses = append(s.Addresses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "conditions":
			s.Conditions.Reset()
			if err := s.Conditions.Decode(d); err != nil {
				return err
			}
		case "hints":
			s.Hints.Reset()
			if err := s.Hints.Decode(d); err != nil {
				return err
			}
		case "hostname":
			s.Hostname.Reset()
			if err := s.Hostname.Decode(d); err != nil {
				return err
			}
		case "nodeName":
			s.NodeName.Reset()
			if err := s.NodeName.Decode(d); err != nil {
				return err
			}
		case "targetRef":
			s.TargetRef.Reset()
			if err := s.TargetRef.Decode(d); err != nil {
				return err
			}
		case "topology":
			s.Topology.Reset()
			if err := s.Topology.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ready.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ready.Set {
			e.RawStr("\"ready\"" + ":")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Serving.Set {
			e.RawStr("\"serving\"" + ":")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Terminating.Set {
			e.RawStr("\"terminating\"" + ":")
			s.Terminating.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointConditions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			s.Ready.Reset()
			if err := s.Ready.Decode(d); err != nil {
				return err
			}
		case "serving":
			s.Serving.Reset()
			if err := s.Serving.Decode(d); err != nil {
				return err
			}
		case "terminating":
			s.Terminating.Reset()
			if err := s.Terminating.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ForZones != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForZones != nil {
			e.RawStr("\"forZones\"" + ":")
			e.ArrStart()
			if len(s.ForZones) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForZones[0]
					elem.Encode(e)
				}
				for _, elem := range s.ForZones[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointHints to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			s.ForZones = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1beta1ForZone
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ForZones = append(s.ForZones, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AppProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AppProtocol.Set {
			e.RawStr("\"appProtocol\"" + ":")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointPort to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			s.AppProtocol.Reset()
			if err := s.AppProtocol.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointSlice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"addressType\"" + ":")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.Comma()
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"endpoints\"" + ":")
		e.ArrStart()
		if len(s.Endpoints) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Endpoints[0]
				elem.Encode(e)
			}
			for _, elem := range s.Endpoints[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.Comma()
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSlice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.AddressType = string(v)
			if err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			s.Endpoints = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1beta1Endpoint
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Endpoints = append(s.Endpoints, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1beta1EndpointPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointSliceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSliceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIDiscoveryV1beta1EndpointSlice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1ForZone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1ForZone from json.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIDiscoveryV1beta1ForZone to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedCount.Set {
			e.RawStr("\"deprecatedCount\"" + ":")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedFirstTimestamp.Set {
			e.RawStr("\"deprecatedFirstTimestamp\"" + ":")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedLastTimestamp.Set {
			e.RawStr("\"deprecatedLastTimestamp\"" + ":")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedSource.Set {
			e.RawStr("\"deprecatedSource\"" + ":")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"eventTime\"" + ":")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.Comma()
		}
		if s.Regarding.Set {
			e.RawStr("\"regarding\"" + ":")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.Comma()
		}
		if s.ReportingController.Set {
			e.RawStr("\"reportingController\"" + ":")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1Event from json.
func (s *IoK8sAPIEventsV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1Event to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "deprecatedCount":
			s.DeprecatedCount.Reset()
			if err := s.DeprecatedCount.Decode(d); err != nil {
				return err
			}
		case "deprecatedFirstTimestamp":
			s.DeprecatedFirstTimestamp.Reset()
			if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
				return err
			}
		case "deprecatedLastTimestamp":
			s.DeprecatedLastTimestamp.Reset()
			if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
				return err
			}
		case "deprecatedSource":
			s.DeprecatedSource.Reset()
			if err := s.DeprecatedSource.Decode(d); err != nil {
				return err
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.EventTime = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "regarding":
			s.Regarding.Reset()
			if err := s.Regarding.Decode(d); err != nil {
				return err
			}
		case "related":
			s.Related.Reset()
			if err := s.Related.Decode(d); err != nil {
				return err
			}
		case "reportingController":
			s.ReportingController.Reset()
			if err := s.ReportingController.Decode(d); err != nil {
				return err
			}
		case "reportingInstance":
			s.ReportingInstance.Reset()
			if err := s.ReportingInstance.Decode(d); err != nil {
				return err
			}
		case "series":
			s.Series.Reset()
			if err := s.Series.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1EventList from json.
func (s *IoK8sAPIEventsV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1EventList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIEventsV1Event
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int32(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"lastObservedTime\"" + ":")
		s.LastObservedTime.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (s *IoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1EventSeries to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.Count = int32(v)
			if err != nil {
				return err
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.LastObservedTime = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedCount.Set {
			e.RawStr("\"deprecatedCount\"" + ":")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedFirstTimestamp.Set {
			e.RawStr("\"deprecatedFirstTimestamp\"" + ":")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedLastTimestamp.Set {
			e.RawStr("\"deprecatedLastTimestamp\"" + ":")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecatedSource.Set {
			e.RawStr("\"deprecatedSource\"" + ":")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"eventTime\"" + ":")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.Comma()
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.Comma()
		}
		if s.Regarding.Set {
			e.RawStr("\"regarding\"" + ":")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.Comma()
		}
		if s.ReportingController.Set {
			e.RawStr("\"reportingController\"" + ":")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.Comma()
		}
		if s.ReportingInstance.Set {
			e.RawStr("\"reportingInstance\"" + ":")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.Comma()
		}
		if s.Series.Set {
			e.RawStr("\"series\"" + ":")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1beta1Event from json.
func (s *IoK8sAPIEventsV1beta1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1beta1Event to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "deprecatedCount":
			s.DeprecatedCount.Reset()
			if err := s.DeprecatedCount.Decode(d); err != nil {
				return err
			}
		case "deprecatedFirstTimestamp":
			s.DeprecatedFirstTimestamp.Reset()
			if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
				return err
			}
		case "deprecatedLastTimestamp":
			s.DeprecatedLastTimestamp.Reset()
			if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
				return err
			}
		case "deprecatedSource":
			s.DeprecatedSource.Reset()
			if err := s.DeprecatedSource.Decode(d); err != nil {
				return err
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.EventTime = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "regarding":
			s.Regarding.Reset()
			if err := s.Regarding.Decode(d); err != nil {
				return err
			}
		case "related":
			s.Related.Reset()
			if err := s.Related.Decode(d); err != nil {
				return err
			}
		case "reportingController":
			s.ReportingController.Reset()
			if err := s.ReportingController.Decode(d); err != nil {
				return err
			}
		case "reportingInstance":
			s.ReportingInstance.Reset()
			if err := s.ReportingInstance.Decode(d); err != nil {
				return err
			}
		case "series":
			s.Series.Reset()
			if err := s.Series.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1EventList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1beta1EventList from json.
func (s *IoK8sAPIEventsV1beta1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1beta1EventList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIEventsV1beta1Event
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int32(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"lastObservedTime\"" + ":")
		s.LastObservedTime.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (s *IoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIEventsV1beta1EventSeries to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.Count = int32(v)
			if err != nil {
				return err
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.LastObservedTime = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchema) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchema to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1FlowSchema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DistinguisherMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DistinguisherMethod.Set {
			e.RawStr("\"distinguisherMethod\"" + ":")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchingPrecedence.Set {
			e.RawStr("\"matchingPrecedence\"" + ":")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"priorityLevelConfiguration\"" + ":")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			s.DistinguisherMethod.Reset()
			if err := s.DistinguisherMethod.Decode(d); err != nil {
				return err
			}
		case "matchingPrecedence":
			s.MatchingPrecedence.Reset()
			if err := s.MatchingPrecedence.Decode(d); err != nil {
				return err
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1GroupSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Queuing.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queuing.Set {
			e.RawStr("\"queuing\"" + ":")
			s.Queuing.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitResponse to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			s.Queuing.Reset()
			if err := s.Queuing.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AssuredConcurrencyShares.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssuredConcurrencyShares.Set {
			e.RawStr("\"assuredConcurrencyShares\"" + ":")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitResponse.Set {
			e.RawStr("\"limitResponse\"" + ":")
			s.LimitResponse.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			s.AssuredConcurrencyShares.Reset()
			if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
				return err
			}
		case "limitResponse":
			s.LimitResponse.Reset()
			if err := s.LimitResponse.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nonResourceURLs\"" + ":")
		e.ArrStart()
		if len(s.NonResourceURLs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NonResourceURLs[0]
				e.Str(elem)
			}
			for _, elem := range s.NonResourceURLs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			s.NonResourceURLs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.NonResourceURLs = append(s.NonResourceURLs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NonResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceRules != nil {
			e.RawStr("\"nonResourceRules\"" + ":")
			e.ArrStart()
			if len(s.NonResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.NonResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceRules != nil {
			e.RawStr("\"resourceRules\"" + ":")
			e.ArrStart()
			if len(s.ResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.ResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subjects\"" + ":")
		e.ArrStart()
		if len(s.Subjects) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subjects[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subjects[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			s.NonResourceRules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NonResourceRules = append(s.NonResourceRules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resourceRules":
			s.ResourceRules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ResourceRules = append(s.ResourceRules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			s.Subjects = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1Subject
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subjects = append(s.Subjects, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limited.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limited.Set {
			e.RawStr("\"limited\"" + ":")
			s.Limited.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			s.Limited.Reset()
			if err := s.Limited.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.HandSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HandSize.Set {
			e.RawStr("\"handSize\"" + ":")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QueueLengthLimit.Set {
			e.RawStr("\"queueLengthLimit\"" + ":")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queues.Set {
			e.RawStr("\"queues\"" + ":")
			s.Queues.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			s.HandSize.Reset()
			if err := s.HandSize.Decode(d); err != nil {
				return err
			}
		case "queueLengthLimit":
			s.QueueLengthLimit.Reset()
			if err := s.QueueLengthLimit.Decode(d); err != nil {
				return err
			}
		case "queues":
			s.Queues.Reset()
			if err := s.Queues.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroups\"" + ":")
		e.ArrStart()
		if len(s.ApiGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ApiGroups[0]
				e.Str(elem)
			}
			for _, elem := range s.ApiGroups[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.Comma()
		}
		if s.ClusterScope.Set {
			e.RawStr("\"clusterScope\"" + ":")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.Comma()
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				e.Str(elem)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			s.ApiGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ApiGroups = append(s.ApiGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "clusterScope":
			s.ClusterScope.Reset()
			if err := s.ClusterScope.Decode(d); err != nil {
				return err
			}
		case "namespaces":
			s.Namespaces = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Namespaces = append(s.Namespaces, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Namespace = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1Subject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			s.Group.Reset()
			if err := s.Group.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "serviceAccount":
			s.ServiceAccount.Reset()
			if err := s.ServiceAccount.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta1UserSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchema) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchema to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2FlowSchema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DistinguisherMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DistinguisherMethod.Set {
			e.RawStr("\"distinguisherMethod\"" + ":")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchingPrecedence.Set {
			e.RawStr("\"matchingPrecedence\"" + ":")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"priorityLevelConfiguration\"" + ":")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.Comma()
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			s.DistinguisherMethod.Reset()
			if err := s.DistinguisherMethod.Decode(d); err != nil {
				return err
			}
		case "matchingPrecedence":
			s.MatchingPrecedence.Reset()
			if err := s.MatchingPrecedence.Decode(d); err != nil {
				return err
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2GroupSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Queuing.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queuing.Set {
			e.RawStr("\"queuing\"" + ":")
			s.Queuing.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitResponse to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			s.Queuing.Reset()
			if err := s.Queuing.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AssuredConcurrencyShares.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssuredConcurrencyShares.Set {
			e.RawStr("\"assuredConcurrencyShares\"" + ":")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitResponse.Set {
			e.RawStr("\"limitResponse\"" + ":")
			s.LimitResponse.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			s.AssuredConcurrencyShares.Reset()
			if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
				return err
			}
		case "limitResponse":
			s.LimitResponse.Reset()
			if err := s.LimitResponse.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"nonResourceURLs\"" + ":")
		e.ArrStart()
		if len(s.NonResourceURLs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.NonResourceURLs[0]
				e.Str(elem)
			}
			for _, elem := range s.NonResourceURLs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			s.NonResourceURLs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.NonResourceURLs = append(s.NonResourceURLs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NonResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceRules != nil {
			e.RawStr("\"nonResourceRules\"" + ":")
			e.ArrStart()
			if len(s.NonResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.NonResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceRules != nil {
			e.RawStr("\"resourceRules\"" + ":")
			e.ArrStart()
			if len(s.ResourceRules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceRules[0]
					elem.Encode(e)
				}
				for _, elem := range s.ResourceRules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subjects\"" + ":")
		e.ArrStart()
		if len(s.Subjects) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subjects[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subjects[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			s.NonResourceRules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NonResourceRules = append(s.NonResourceRules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resourceRules":
			s.ResourceRules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ResourceRules = append(s.ResourceRules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			s.Subjects = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2Subject
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subjects = append(s.Subjects, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Limited.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limited.Set {
			e.RawStr("\"limited\"" + ":")
			s.Limited.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			s.Limited.Reset()
			if err := s.Limited.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.HandSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HandSize.Set {
			e.RawStr("\"handSize\"" + ":")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.QueueLengthLimit.Set {
			e.RawStr("\"queueLengthLimit\"" + ":")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Queues.Set {
			e.RawStr("\"queues\"" + ":")
			s.Queues.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			s.HandSize.Reset()
			if err := s.HandSize.Decode(d); err != nil {
				return err
			}
		case "queueLengthLimit":
			s.QueueLengthLimit.Reset()
			if err := s.QueueLengthLimit.Decode(d); err != nil {
				return err
			}
		case "queues":
			s.Queues.Reset()
			if err := s.Queues.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroups\"" + ":")
		e.ArrStart()
		if len(s.ApiGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ApiGroups[0]
				e.Str(elem)
			}
			for _, elem := range s.ApiGroups[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.Comma()
		}
		if s.ClusterScope.Set {
			e.RawStr("\"clusterScope\"" + ":")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.Comma()
		}
		if s.Namespaces != nil {
			e.RawStr("\"namespaces\"" + ":")
			e.ArrStart()
			if len(s.Namespaces) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Namespaces[0]
					e.Str(elem)
				}
				for _, elem := range s.Namespaces[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				e.Str(elem)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			s.ApiGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ApiGroups = append(s.ApiGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "clusterScope":
			s.ClusterScope.Reset()
			if err := s.ClusterScope.Decode(d); err != nil {
				return err
			}
		case "namespaces":
			s.Namespaces = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Namespaces = append(s.Namespaces, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Namespace = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.Comma()
		}
		if s.ServiceAccount.Set {
			e.RawStr("\"serviceAccount\"" + ":")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2Subject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			s.Group.Reset()
			if err := s.Group.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "serviceAccount":
			s.ServiceAccount.Reset()
			if err := s.ServiceAccount.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIFlowcontrolV1beta2UserSubject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1HTTPIngressPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"backend\"" + ":")
		s.Backend.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pathType\"" + ":")
		e.Str(s.PathType)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath = [3]string{
	0: "backend",
	1: "path",
	2: "pathType",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressPath from json.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressPath to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backend":
			requiredBitSet[0] |= 1 << 0
			if err := s.Backend.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "pathType":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.PathType = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"paths\"" + ":")
		e.ArrStart()
		if len(s.Paths) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Paths[0]
				elem.Encode(e)
			}
			for _, elem := range s.Paths[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue = [1]string{
	0: "paths",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressRuleValue to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "paths":
			requiredBitSet[0] |= 1 << 0
			s.Paths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1HTTPIngressPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Paths = append(s.Paths, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IPBlock) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"cidr\"" + ":")
		e.Str(s.Cidr)
	}
	{
		if s.Except != nil {
			e.Comma()
		}
		if s.Except != nil {
			e.RawStr("\"except\"" + ":")
			e.ArrStart()
			if len(s.Except) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Except[0]
					e.Str(elem)
				}
				for _, elem := range s.Except[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock = [2]string{
	0: "cidr",
	1: "except",
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (s *IoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IPBlock to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cidr":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Cidr = string(v)
			if err != nil {
				return err
			}
		case "except":
			s.Except = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Except = append(s.Except, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1Ingress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1Ingress = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPINetworkingV1Ingress from json.
func (s *IoK8sAPINetworkingV1Ingress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1Ingress to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Service.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressBackend = [2]string{
	0: "resource",
	1: "service",
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (s *IoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressBackend to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "service":
			s.Service.Reset()
			if err := s.Service.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1IngressClass from json.
func (s *IoK8sAPINetworkingV1IngressClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressClass to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassList from json.
func (s *IoK8sAPINetworkingV1IngressClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1IngressClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.Comma()
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.Comma()
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference = [5]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
	4: "scope",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressClassParametersReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			s.ApiGroup.Reset()
			if err := s.ApiGroup.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		case "scope":
			s.Scope.Reset()
			if err := s.Scope.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Controller.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Controller.Set {
			e.RawStr("\"controller\"" + ":")
			s.Controller.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parameters.Set {
			e.RawStr("\"parameters\"" + ":")
			s.Parameters.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassSpec = [2]string{
	0: "controller",
	1: "parameters",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (s *IoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressClassSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controller":
			s.Controller.Reset()
			if err := s.Controller.Decode(d); err != nil {
				return err
			}
		case "parameters":
			s.Parameters.Reset()
			if err := s.Parameters.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressList from json.
func (s *IoK8sAPINetworkingV1IngressList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1Ingress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.HTTP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTP.Set {
			e.RawStr("\"http\"" + ":")
			s.HTTP.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressRule = [2]string{
	0: "host",
	1: "http",
}

// Decode decodes IoK8sAPINetworkingV1IngressRule from json.
func (s *IoK8sAPINetworkingV1IngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressRule to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "http":
			s.HTTP.Reset()
			if err := s.HTTP.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend = [2]string{
	0: "name",
	1: "port",
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressServiceBackend to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DefaultBackend.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBackend.Set {
			e.RawStr("\"defaultBackend\"" + ":")
			s.DefaultBackend.Encode(e)
		}
	}
	{
		if s.IngressClassName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IngressClassName.Set {
			e.RawStr("\"ingressClassName\"" + ":")
			s.IngressClassName.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TLS != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TLS != nil {
			e.RawStr("\"tls\"" + ":")
			e.ArrStart()
			if len(s.TLS) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TLS[0]
					elem.Encode(e)
				}
				for _, elem := range s.TLS[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressSpec = [4]string{
	0: "defaultBackend",
	1: "ingressClassName",
	2: "rules",
	3: "tls",
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (s *IoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultBackend":
			s.DefaultBackend.Reset()
			if err := s.DefaultBackend.Decode(d); err != nil {
				return err
			}
		case "ingressClassName":
			s.IngressClassName.Reset()
			if err := s.IngressClassName.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1IngressRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		case "tls":
			s.TLS = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1IngressTLS
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TLS = append(s.TLS, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LoadBalancer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LoadBalancer.Set {
			e.RawStr("\"loadBalancer\"" + ":")
			s.LoadBalancer.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressStatus = [1]string{
	0: "loadBalancer",
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (s *IoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loadBalancer":
			s.LoadBalancer.Reset()
			if err := s.LoadBalancer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1IngressTLS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Hosts != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hosts != nil {
			e.RawStr("\"hosts\"" + ":")
			e.ArrStart()
			if len(s.Hosts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hosts[0]
					e.Str(elem)
				}
				for _, elem := range s.Hosts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecretName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretName.Set {
			e.RawStr("\"secretName\"" + ":")
			s.SecretName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressTLS = [2]string{
	0: "hosts",
	1: "secretName",
}

// Decode decodes IoK8sAPINetworkingV1IngressTLS from json.
func (s *IoK8sAPINetworkingV1IngressTLS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1IngressTLS to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			s.Hosts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Hosts = append(s.Hosts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "secretName":
			s.SecretName.Reset()
			if err := s.SecretName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicy from json.
func (s *IoK8sAPINetworkingV1NetworkPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyEgressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.To != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.To != nil {
			e.RawStr("\"to\"" + ":")
			e.ArrStart()
			if len(s.To) >= 1 {
				// Encode first element without comma.
				{
					elem := s.To[0]
					elem.Encode(e)
				}
				for _, elem := range s.To[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyEgressRule = [2]string{
	0: "ports",
	1: "to",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyEgressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyEgressRule to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		case "to":
			s.To = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyPeer
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.To = append(s.To, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyIngressRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.From != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.From != nil {
			e.RawStr("\"from\"" + ":")
			e.ArrStart()
			if len(s.From) >= 1 {
				// Encode first element without comma.
				{
					elem := s.From[0]
					elem.Encode(e)
				}
				for _, elem := range s.From[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ports != nil {
			e.RawStr("\"ports\"" + ":")
			e.ArrStart()
			if len(s.Ports) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ports[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ports[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyIngressRule = [2]string{
	0: "from",
	1: "ports",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyIngressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyIngressRule to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			s.From = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyPeer
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.From = append(s.From, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ports":
			s.Ports = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyPort
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ports = append(s.Ports, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyList from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicy
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyPeer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IpBlock.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IpBlock.Set {
			e.RawStr("\"ipBlock\"" + ":")
			s.IpBlock.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NamespaceSelector.Set {
			e.RawStr("\"namespaceSelector\"" + ":")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.PodSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodSelector.Set {
			e.RawStr("\"podSelector\"" + ":")
			s.PodSelector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPeer = [3]string{
	0: "ipBlock",
	1: "namespaceSelector",
	2: "podSelector",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPeer from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPeer to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipBlock":
			s.IpBlock.Reset()
			if err := s.IpBlock.Decode(d); err != nil {
				return err
			}
		case "namespaceSelector":
			s.NamespaceSelector.Reset()
			if err := s.NamespaceSelector.Decode(d); err != nil {
				return err
			}
		case "podSelector":
			s.PodSelector.Reset()
			if err := s.PodSelector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicyPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EndPort.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndPort.Set {
			e.RawStr("\"endPort\"" + ":")
			s.EndPort.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Protocol.Set {
			e.RawStr("\"protocol\"" + ":")
			s.Protocol.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPort = [3]string{
	0: "endPort",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPort from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPort to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endPort":
			s.EndPort.Reset()
			if err := s.EndPort.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		case "protocol":
			s.Protocol.Reset()
			if err := s.Protocol.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Egress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Egress != nil {
			e.RawStr("\"egress\"" + ":")
			e.ArrStart()
			if len(s.Egress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Egress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Egress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ingress != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ingress != nil {
			e.RawStr("\"ingress\"" + ":")
			e.ArrStart()
			if len(s.Ingress) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ingress[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ingress[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"podSelector\"" + ":")
		s.PodSelector.Encode(e)
	}
	{
		if s.PolicyTypes != nil {
			e.Comma()
		}
		if s.PolicyTypes != nil {
			e.RawStr("\"policyTypes\"" + ":")
			e.ArrStart()
			if len(s.PolicyTypes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PolicyTypes[0]
					e.Str(elem)
				}
				for _, elem := range s.PolicyTypes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec = [4]string{
	0: "egress",
	1: "ingress",
	2: "podSelector",
	3: "policyTypes",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicySpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "egress":
			s.Egress = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyEgressRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Egress = append(s.Egress, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ingress":
			s.Ingress = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINetworkingV1NetworkPolicyIngressRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ingress = append(s.Ingress, elem)
				return nil
			}); err != nil {
				return err
			}
		case "podSelector":
			requiredBitSet[0] |= 1 << 2
			if err := s.PodSelector.Decode(d); err != nil {
				return err
			}
		case "policyTypes":
			s.PolicyTypes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.PolicyTypes = append(s.PolicyTypes, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINetworkingV1ServiceBackendPort = [2]string{
	0: "name",
	1: "number",
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINetworkingV1ServiceBackendPort to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "number":
			s.Number.Reset()
			if err := s.Number.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (s *IoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1Overhead to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			s.PodFixed.Reset()
			if err := s.PodFixed.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"handler\"" + ":")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1RuntimeClass from json.
func (s *IoK8sAPINodeV1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1RuntimeClass to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Handler = string(v)
			if err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "overhead":
			s.Overhead.Reset()
			if err := s.Overhead.Decode(d); err != nil {
				return err
			}
		case "scheduling":
			s.Scheduling.Reset()
			if err := s.Scheduling.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1RuntimeClassList from json.
func (s *IoK8sAPINodeV1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1RuntimeClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINodeV1RuntimeClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (s *IoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1Scheduling to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			s.NodeSelector.Reset()
			if err := s.NodeSelector.Decode(d); err != nil {
				return err
			}
		case "tolerations":
			s.Tolerations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Toleration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tolerations = append(s.Tolerations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (s *IoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1alpha1Overhead to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			s.PodFixed.Reset()
			if err := s.PodFixed.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClass from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClass to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassList from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINodeV1alpha1RuntimeClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1RuntimeClassSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Overhead.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runtimeHandler\"" + ":")
		e.Str(s.RuntimeHandler)
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec = [3]string{
	0: "overhead",
	1: "runtimeHandler",
	2: "scheduling",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassSpec from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overhead":
			s.Overhead.Reset()
			if err := s.Overhead.Decode(d); err != nil {
				return err
			}
		case "runtimeHandler":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.RuntimeHandler = string(v)
			if err != nil {
				return err
			}
		case "scheduling":
			s.Scheduling.Reset()
			if err := s.Scheduling.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (s *IoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1alpha1Scheduling to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			s.NodeSelector.Reset()
			if err := s.NodeSelector.Decode(d); err != nil {
				return err
			}
		case "tolerations":
			s.Tolerations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Toleration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tolerations = append(s.Tolerations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1Overhead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PodFixed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodFixed.Set {
			e.RawStr("\"podFixed\"" + ":")
			s.PodFixed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (s *IoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1beta1Overhead to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			s.PodFixed.Reset()
			if err := s.PodFixed.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1RuntimeClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"handler\"" + ":")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.Comma()
		}
		if s.Overhead.Set {
			e.RawStr("\"overhead\"" + ":")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.Comma()
		}
		if s.Scheduling.Set {
			e.RawStr("\"scheduling\"" + ":")
			s.Scheduling.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClass from json.
func (s *IoK8sAPINodeV1beta1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClass to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Handler = string(v)
			if err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "overhead":
			s.Overhead.Reset()
			if err := s.Overhead.Decode(d); err != nil {
				return err
			}
		case "scheduling":
			s.Scheduling.Reset()
			if err := s.Scheduling.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1RuntimeClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClassList from json.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPINodeV1beta1RuntimeClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NodeSelector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeSelector.Set {
			e.RawStr("\"nodeSelector\"" + ":")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tolerations != nil {
			e.RawStr("\"tolerations\"" + ":")
			e.ArrStart()
			if len(s.Tolerations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tolerations[0]
					elem.Encode(e)
				}
				for _, elem := range s.Tolerations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (s *IoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPINodeV1beta1Scheduling to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			s.NodeSelector.Reset()
			if err := s.NodeSelector.Decode(d); err != nil {
				return err
			}
		case "tolerations":
			s.Tolerations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1Toleration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tolerations = append(s.Tolerations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudget to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1PodDisruptionBudget
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinAvailable.Set {
			e.RawStr("\"minAvailable\"" + ":")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			s.MaxUnavailable.Reset()
			if err := s.MaxUnavailable.Decode(d); err != nil {
				return err
			}
		case "minAvailable":
			s.MinAvailable.Reset()
			if err := s.MinAvailable.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentHealthy\"" + ":")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.Comma()

		e.RawStr("\"desiredHealthy\"" + ":")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.Comma()
		}
		if s.DisruptedPods.Set {
			e.RawStr("\"disruptedPods\"" + ":")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"disruptionsAllowed\"" + ":")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.Comma()

		e.RawStr("\"expectedPods\"" + ":")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1Condition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.CurrentHealthy = int32(v)
			if err != nil {
				return err
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.DesiredHealthy = int32(v)
			if err != nil {
				return err
			}
		case "disruptedPods":
			s.DisruptedPods.Reset()
			if err := s.DisruptedPods.Decode(d); err != nil {
				return err
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int32()
			s.DisruptionsAllowed = int32(v)
			if err != nil {
				return err
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Int32()
			s.ExpectedPods = int32(v)
			if err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedCSIDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedCSIDriver from json.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedCSIDriver to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedFlexVolume) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"driver\"" + ":")
		e.Str(s.Driver)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume = [1]string{
	0: "driver",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedFlexVolume from json.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedFlexVolume to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Driver = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1AllowedHostPath) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PathPrefix.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PathPrefix.Set {
			e.RawStr("\"pathPrefix\"" + ":")
			s.PathPrefix.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"readOnly\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedHostPath = [2]string{
	0: "pathPrefix",
	1: "readOnly",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedHostPath from json.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedHostPath to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pathPrefix":
			s.PathPrefix.Reset()
			if err := s.PathPrefix.Decode(d); err != nil {
				return err
			}
		case "readOnly":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rule.Set {
			e.RawStr("\"rule\"" + ":")
			s.Rule.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1FSGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1FSGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1FSGroupStrategyOptions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			s.Ranges = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1IDRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ranges = append(s.Ranges, elem)
				return nil
			}); err != nil {
				return err
			}
		case "rule":
			s.Rule.Reset()
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1HostPortRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"max\"" + ":")
		e.Int32(s.Max)
	}
	{
		e.Comma()

		e.RawStr("\"min\"" + ":")
		e.Int32(s.Min)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1HostPortRange from json.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1HostPortRange to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int32()
			s.Max = int32(v)
			if err != nil {
				return err
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.Min = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1IDRange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"max\"" + ":")
		e.Int64(s.Max)
	}
	{
		e.Comma()

		e.RawStr("\"min\"" + ":")
		e.Int64(s.Min)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1IDRange from json.
func (s *IoK8sAPIPolicyV1beta1IDRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1IDRange to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.Max = int64(v)
			if err != nil {
				return err
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.Min = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudget) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudget to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1PodDisruptionBudget
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MaxUnavailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxUnavailable.Set {
			e.RawStr("\"maxUnavailable\"" + ":")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinAvailable.Set {
			e.RawStr("\"minAvailable\"" + ":")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Selector.Set {
			e.RawStr("\"selector\"" + ":")
			s.Selector.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			s.MaxUnavailable.Reset()
			if err := s.MaxUnavailable.Decode(d); err != nil {
				return err
			}
		case "minAvailable":
			s.MinAvailable.Reset()
			if err := s.MinAvailable.Decode(d); err != nil {
				return err
			}
		case "selector":
			s.Selector.Reset()
			if err := s.Selector.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currentHealthy\"" + ":")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.Comma()

		e.RawStr("\"desiredHealthy\"" + ":")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.Comma()
		}
		if s.DisruptedPods.Set {
			e.RawStr("\"disruptedPods\"" + ":")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"disruptionsAllowed\"" + ":")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.Comma()

		e.RawStr("\"expectedPods\"" + ":")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1Condition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int32()
			s.CurrentHealthy = int32(v)
			if err != nil {
				return err
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.DesiredHealthy = int32(v)
			if err != nil {
				return err
			}
		case "disruptedPods":
			s.DisruptedPods.Reset()
			if err := s.DisruptedPods.Decode(d); err != nil {
				return err
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int32()
			s.DisruptionsAllowed = int32(v)
			if err != nil {
				return err
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Int32()
			s.ExpectedPods = int32(v)
			if err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicy from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicy to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicyList from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicyList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1PodSecurityPolicy
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowPrivilegeEscalation.Set {
			e.RawStr("\"allowPrivilegeEscalation\"" + ":")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.AllowedCSIDrivers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedCSIDrivers != nil {
			e.RawStr("\"allowedCSIDrivers\"" + ":")
			e.ArrStart()
			if len(s.AllowedCSIDrivers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedCSIDrivers[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedCSIDrivers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedCapabilities != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedCapabilities != nil {
			e.RawStr("\"allowedCapabilities\"" + ":")
			e.ArrStart()
			if len(s.AllowedCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedFlexVolumes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedFlexVolumes != nil {
			e.RawStr("\"allowedFlexVolumes\"" + ":")
			e.ArrStart()
			if len(s.AllowedFlexVolumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedFlexVolumes[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedFlexVolumes[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedHostPaths != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedHostPaths != nil {
			e.RawStr("\"allowedHostPaths\"" + ":")
			e.ArrStart()
			if len(s.AllowedHostPaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedHostPaths[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedHostPaths[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedProcMountTypes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedProcMountTypes != nil {
			e.RawStr("\"allowedProcMountTypes\"" + ":")
			e.ArrStart()
			if len(s.AllowedProcMountTypes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedProcMountTypes[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedProcMountTypes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedUnsafeSysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedUnsafeSysctls != nil {
			e.RawStr("\"allowedUnsafeSysctls\"" + ":")
			e.ArrStart()
			if len(s.AllowedUnsafeSysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedUnsafeSysctls[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedUnsafeSysctls[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAddCapabilities != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultAddCapabilities != nil {
			e.RawStr("\"defaultAddCapabilities\"" + ":")
			e.ArrStart()
			if len(s.DefaultAddCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.DefaultAddCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.DefaultAddCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAllowPrivilegeEscalation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultAllowPrivilegeEscalation.Set {
			e.RawStr("\"defaultAllowPrivilegeEscalation\"" + ":")
			s.DefaultAllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.ForbiddenSysctls != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForbiddenSysctls != nil {
			e.RawStr("\"forbiddenSysctls\"" + ":")
			e.ArrStart()
			if len(s.ForbiddenSysctls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ForbiddenSysctls[0]
					e.Str(elem)
				}
				for _, elem := range s.ForbiddenSysctls[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"fsGroup\"" + ":")
		s.FsGroup.Encode(e)
	}
	{
		if s.HostIPC.Set {
			e.Comma()
		}
		if s.HostIPC.Set {
			e.RawStr("\"hostIPC\"" + ":")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.Comma()
		}
		if s.HostNetwork.Set {
			e.RawStr("\"hostNetwork\"" + ":")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.Comma()
		}
		if s.HostPID.Set {
			e.RawStr("\"hostPID\"" + ":")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.HostPorts != nil {
			e.Comma()
		}
		if s.HostPorts != nil {
			e.RawStr("\"hostPorts\"" + ":")
			e.ArrStart()
			if len(s.HostPorts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.HostPorts[0]
					elem.Encode(e)
				}
				for _, elem := range s.HostPorts[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privileged.Set {
			e.Comma()
		}
		if s.Privileged.Set {
			e.RawStr("\"privileged\"" + ":")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.Comma()
		}
		if s.ReadOnlyRootFilesystem.Set {
			e.RawStr("\"readOnlyRootFilesystem\"" + ":")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RequiredDropCapabilities != nil {
			e.Comma()
		}
		if s.RequiredDropCapabilities != nil {
			e.RawStr("\"requiredDropCapabilities\"" + ":")
			e.ArrStart()
			if len(s.RequiredDropCapabilities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredDropCapabilities[0]
					e.Str(elem)
				}
				for _, elem := range s.RequiredDropCapabilities[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RunAsGroup.Set {
			e.Comma()
		}
		if s.RunAsGroup.Set {
			e.RawStr("\"runAsGroup\"" + ":")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runAsUser\"" + ":")
		s.RunAsUser.Encode(e)
	}
	{
		if s.RuntimeClass.Set {
			e.Comma()
		}
		if s.RuntimeClass.Set {
			e.RawStr("\"runtimeClass\"" + ":")
			s.RuntimeClass.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"seLinux\"" + ":")
		s.SeLinux.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"supplementalGroups\"" + ":")
		s.SupplementalGroups.Encode(e)
	}
	{
		if s.Volumes != nil {
			e.Comma()
		}
		if s.Volumes != nil {
			e.RawStr("\"volumes\"" + ":")
			e.ArrStart()
			if len(s.Volumes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Volumes[0]
					e.Str(elem)
				}
				for _, elem := range s.Volumes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec = [24]string{
	0:  "allowPrivilegeEscalation",
	1:  "allowedCSIDrivers",
	2:  "allowedCapabilities",
	3:  "allowedFlexVolumes",
	4:  "allowedHostPaths",
	5:  "allowedProcMountTypes",
	6:  "allowedUnsafeSysctls",
	7:  "defaultAddCapabilities",
	8:  "defaultAllowPrivilegeEscalation",
	9:  "forbiddenSysctls",
	10: "fsGroup",
	11: "hostIPC",
	12: "hostNetwork",
	13: "hostPID",
	14: "hostPorts",
	15: "privileged",
	16: "readOnlyRootFilesystem",
	17: "requiredDropCapabilities",
	18: "runAsGroup",
	19: "runAsUser",
	20: "runtimeClass",
	21: "seLinux",
	22: "supplementalGroups",
	23: "volumes",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			s.AllowPrivilegeEscalation.Reset()
			if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
				return err
			}
		case "allowedCSIDrivers":
			s.AllowedCSIDrivers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1AllowedCSIDriver
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AllowedCSIDrivers = append(s.AllowedCSIDrivers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allowedCapabilities":
			s.AllowedCapabilities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedCapabilities = append(s.AllowedCapabilities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allowedFlexVolumes":
			s.AllowedFlexVolumes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1AllowedFlexVolume
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AllowedFlexVolumes = append(s.AllowedFlexVolumes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allowedHostPaths":
			s.AllowedHostPaths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1AllowedHostPath
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AllowedHostPaths = append(s.AllowedHostPaths, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allowedProcMountTypes":
			s.AllowedProcMountTypes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedProcMountTypes = append(s.AllowedProcMountTypes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "allowedUnsafeSysctls":
			s.AllowedUnsafeSysctls = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUnsafeSysctls = append(s.AllowedUnsafeSysctls, elem)
				return nil
			}); err != nil {
				return err
			}
		case "defaultAddCapabilities":
			s.DefaultAddCapabilities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.DefaultAddCapabilities = append(s.DefaultAddCapabilities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "defaultAllowPrivilegeEscalation":
			s.DefaultAllowPrivilegeEscalation.Reset()
			if err := s.DefaultAllowPrivilegeEscalation.Decode(d); err != nil {
				return err
			}
		case "forbiddenSysctls":
			s.ForbiddenSysctls = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ForbiddenSysctls = append(s.ForbiddenSysctls, elem)
				return nil
			}); err != nil {
				return err
			}
		case "fsGroup":
			requiredBitSet[1] |= 1 << 2
			if err := s.FsGroup.Decode(d); err != nil {
				return err
			}
		case "hostIPC":
			s.HostIPC.Reset()
			if err := s.HostIPC.Decode(d); err != nil {
				return err
			}
		case "hostNetwork":
			s.HostNetwork.Reset()
			if err := s.HostNetwork.Decode(d); err != nil {
				return err
			}
		case "hostPID":
			s.HostPID.Reset()
			if err := s.HostPID.Decode(d); err != nil {
				return err
			}
		case "hostPorts":
			s.HostPorts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1HostPortRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.HostPorts = append(s.HostPorts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "privileged":
			s.Privileged.Reset()
			if err := s.Privileged.Decode(d); err != nil {
				return err
			}
		case "readOnlyRootFilesystem":
			s.ReadOnlyRootFilesystem.Reset()
			if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
				return err
			}
		case "requiredDropCapabilities":
			s.RequiredDropCapabilities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RequiredDropCapabilities = append(s.RequiredDropCapabilities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "runAsGroup":
			s.RunAsGroup.Reset()
			if err := s.RunAsGroup.Decode(d); err != nil {
				return err
			}
		case "runAsUser":
			requiredBitSet[2] |= 1 << 3
			if err := s.RunAsUser.Decode(d); err != nil {
				return err
			}
		case "runtimeClass":
			s.RuntimeClass.Reset()
			if err := s.RuntimeClass.Decode(d); err != nil {
				return err
			}
		case "seLinux":
			requiredBitSet[2] |= 1 << 5
			if err := s.SeLinux.Decode(d); err != nil {
				return err
			}
		case "supplementalGroups":
			requiredBitSet[2] |= 1 << 6
			if err := s.SupplementalGroups.Decode(d); err != nil {
				return err
			}
		case "volumes":
			s.Volumes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Volumes = append(s.Volumes, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000100,
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			s.Ranges = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1IDRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ranges = append(s.Ranges, elem)
				return nil
			}); err != nil {
				return err
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Rule = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			s.Ranges = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1IDRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ranges = append(s.Ranges, elem)
				return nil
			}); err != nil {
				return err
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Rule = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"allowedRuntimeClassNames\"" + ":")
		e.ArrStart()
		if len(s.AllowedRuntimeClassNames) >= 1 {
			// Encode first element without comma.
			{
				elem := s.AllowedRuntimeClassNames[0]
				e.Str(elem)
			}
			for _, elem := range s.AllowedRuntimeClassNames[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.DefaultRuntimeClassName.Set {
			e.Comma()
		}
		if s.DefaultRuntimeClassName.Set {
			e.RawStr("\"defaultRuntimeClassName\"" + ":")
			s.DefaultRuntimeClassName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions = [2]string{
	0: "allowedRuntimeClassNames",
	1: "defaultRuntimeClassName",
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedRuntimeClassNames":
			requiredBitSet[0] |= 1 << 0
			s.AllowedRuntimeClassNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedRuntimeClassNames = append(s.AllowedRuntimeClassNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "defaultRuntimeClassName":
			s.DefaultRuntimeClassName.Reset()
			if err := s.DefaultRuntimeClassName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"rule\"" + ":")
		e.Str(s.Rule)
	}
	{
		if s.SeLinuxOptions.Set {
			e.Comma()
		}
		if s.SeLinuxOptions.Set {
			e.RawStr("\"seLinuxOptions\"" + ":")
			s.SeLinuxOptions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions = [2]string{
	0: "rule",
	1: "seLinuxOptions",
}

// Decode decodes IoK8sAPIPolicyV1beta1SELinuxStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1SELinuxStrategyOptions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Rule = string(v)
			if err != nil {
				return err
			}
		case "seLinuxOptions":
			s.SeLinuxOptions.Reset()
			if err := s.SeLinuxOptions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ranges != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ranges != nil {
			e.RawStr("\"ranges\"" + ":")
			e.ArrStart()
			if len(s.Ranges) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Ranges[0]
					elem.Encode(e)
				}
				for _, elem := range s.Ranges[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rule.Set {
			e.RawStr("\"rule\"" + ":")
			s.Rule.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			s.Ranges = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIPolicyV1beta1IDRange
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Ranges = append(s.Ranges, elem)
				return nil
			}); err != nil {
				return err
			}
		case "rule":
			s.Rule.Reset()
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1AggregationRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClusterRoleSelectors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterRoleSelectors != nil {
			e.RawStr("\"clusterRoleSelectors\"" + ":")
			e.ArrStart()
			if len(s.ClusterRoleSelectors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ClusterRoleSelectors[0]
					elem.Encode(e)
				}
				for _, elem := range s.ClusterRoleSelectors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1AggregationRule = [1]string{
	0: "clusterRoleSelectors",
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (s *IoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1AggregationRule to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterRoleSelectors":
			s.ClusterRoleSelectors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1LabelSelector
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ClusterRoleSelectors = append(s.ClusterRoleSelectors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRole) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AggregationRule.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AggregationRule.Set {
			e.RawStr("\"aggregationRule\"" + ":")
			s.AggregationRule.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRole = [5]string{
	0: "aggregationRule",
	1: "apiVersion",
	2: "kind",
	3: "metadata",
	4: "rules",
}

// Decode decodes IoK8sAPIRbacV1ClusterRole from json.
func (s *IoK8sAPIRbacV1ClusterRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1ClusterRole to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aggregationRule":
			s.AggregationRule.Reset()
			if err := s.AggregationRule.Decode(d); err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1PolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleBinding) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"roleRef\"" + ":")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.Comma()
		}
		if s.Subjects != nil {
			e.RawStr("\"subjects\"" + ":")
			e.ArrStart()
			if len(s.Subjects) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subjects[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subjects[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBinding from json.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBinding to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := s.RoleRef.Decode(d); err != nil {
				return err
			}
		case "subjects":
			s.Subjects = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1Subject
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subjects = append(s.Subjects, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleBindingList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBindingList from json.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBindingList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1ClusterRoleBinding
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1ClusterRoleList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleList from json.
func (s *IoK8sAPIRbacV1ClusterRoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1ClusterRoleList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1ClusterRole
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1PolicyRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroups != nil {
			e.RawStr("\"apiGroups\"" + ":")
			e.ArrStart()
			if len(s.ApiGroups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ApiGroups[0]
					e.Str(elem)
				}
				for _, elem := range s.ApiGroups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.NonResourceURLs != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NonResourceURLs != nil {
			e.RawStr("\"nonResourceURLs\"" + ":")
			e.ArrStart()
			if len(s.NonResourceURLs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NonResourceURLs[0]
					e.Str(elem)
				}
				for _, elem := range s.NonResourceURLs[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceNames != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceNames != nil {
			e.RawStr("\"resourceNames\"" + ":")
			e.ArrStart()
			if len(s.ResourceNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ResourceNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ResourceNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resources != nil {
			e.RawStr("\"resources\"" + ":")
			e.ArrStart()
			if len(s.Resources) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Resources[0]
					e.Str(elem)
				}
				for _, elem := range s.Resources[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule = [5]string{
	0: "apiGroups",
	1: "nonResourceURLs",
	2: "resourceNames",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIRbacV1PolicyRule from json.
func (s *IoK8sAPIRbacV1PolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1PolicyRule to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			s.ApiGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ApiGroups = append(s.ApiGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "nonResourceURLs":
			s.NonResourceURLs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.NonResourceURLs = append(s.NonResourceURLs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resourceNames":
			s.ResourceNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ResourceNames = append(s.ResourceNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1Role) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Rules != nil {
			e.RawStr("\"rules\"" + ":")
			e.ArrStart()
			if len(s.Rules) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Rules[0]
					elem.Encode(e)
				}
				for _, elem := range s.Rules[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1Role = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "rules",
}

// Decode decodes IoK8sAPIRbacV1Role from json.
func (s *IoK8sAPIRbacV1Role) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1Role to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "rules":
			s.Rules = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1PolicyRule
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = append(s.Rules, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleBinding) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"roleRef\"" + ":")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.Comma()
		}
		if s.Subjects != nil {
			e.RawStr("\"subjects\"" + ":")
			e.ArrStart()
			if len(s.Subjects) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subjects[0]
					elem.Encode(e)
				}
				for _, elem := range s.Subjects[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1RoleBinding from json.
func (s *IoK8sAPIRbacV1RoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1RoleBinding to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := s.RoleRef.Decode(d); err != nil {
				return err
			}
		case "subjects":
			s.Subjects = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1Subject
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subjects = append(s.Subjects, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleBindingList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleBindingList from json.
func (s *IoK8sAPIRbacV1RoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1RoleBindingList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1RoleBinding
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleList from json.
func (s *IoK8sAPIRbacV1RoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1RoleList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIRbacV1Role
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1RoleRef) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiGroup\"" + ":")
		e.Str(s.ApiGroup)
	}
	{
		e.Comma()

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleRef = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIRbacV1RoleRef from json.
func (s *IoK8sAPIRbacV1RoleRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1RoleRef to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ApiGroup = string(v)
			if err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleRef) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIRbacV1Subject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiGroup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiGroup.Set {
			e.RawStr("\"apiGroup\"" + ":")
			s.ApiGroup.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.Comma()
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIRbacV1Subject = [4]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
}

// Decode decodes IoK8sAPIRbacV1Subject from json.
func (s *IoK8sAPIRbacV1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIRbacV1Subject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			s.ApiGroup.Reset()
			if err := s.ApiGroup.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1Subject) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPISchedulingV1PriorityClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.GlobalDefault.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GlobalDefault.Set {
			e.RawStr("\"globalDefault\"" + ":")
			s.GlobalDefault.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreemptionPolicy.Set {
			e.RawStr("\"preemptionPolicy\"" + ":")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Int32(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass = [7]string{
	0: "apiVersion",
	1: "description",
	2: "globalDefault",
	3: "kind",
	4: "metadata",
	5: "preemptionPolicy",
	6: "value",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClass from json.
func (s *IoK8sAPISchedulingV1PriorityClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPISchedulingV1PriorityClass to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "globalDefault":
			s.GlobalDefault.Reset()
			if err := s.GlobalDefault.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "preemptionPolicy":
			s.PreemptionPolicy.Reset()
			if err := s.PreemptionPolicy.Decode(d); err != nil {
				return err
			}
		case "value":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.Value = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPISchedulingV1PriorityClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClassList from json.
func (s *IoK8sAPISchedulingV1PriorityClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPISchedulingV1PriorityClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPISchedulingV1PriorityClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSIDriver from json.
func (s *IoK8sAPIStorageV1CSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSIDriver to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriverList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverList from json.
func (s *IoK8sAPIStorageV1CSIDriverList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSIDriverList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1CSIDriver
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSIDriverSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AttachRequired.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AttachRequired.Set {
			e.RawStr("\"attachRequired\"" + ":")
			s.AttachRequired.Encode(e)
		}
	}
	{
		if s.FsGroupPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FsGroupPolicy.Set {
			e.RawStr("\"fsGroupPolicy\"" + ":")
			s.FsGroupPolicy.Encode(e)
		}
	}
	{
		if s.PodInfoOnMount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PodInfoOnMount.Set {
			e.RawStr("\"podInfoOnMount\"" + ":")
			s.PodInfoOnMount.Encode(e)
		}
	}
	{
		if s.RequiresRepublish.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiresRepublish.Set {
			e.RawStr("\"requiresRepublish\"" + ":")
			s.RequiresRepublish.Encode(e)
		}
	}
	{
		if s.StorageCapacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StorageCapacity.Set {
			e.RawStr("\"storageCapacity\"" + ":")
			s.StorageCapacity.Encode(e)
		}
	}
	{
		if s.TokenRequests != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TokenRequests != nil {
			e.RawStr("\"tokenRequests\"" + ":")
			e.ArrStart()
			if len(s.TokenRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TokenRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.TokenRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeLifecycleModes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VolumeLifecycleModes != nil {
			e.RawStr("\"volumeLifecycleModes\"" + ":")
			e.ArrStart()
			if len(s.VolumeLifecycleModes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.VolumeLifecycleModes[0]
					e.Str(elem)
				}
				for _, elem := range s.VolumeLifecycleModes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverSpec = [7]string{
	0: "attachRequired",
	1: "fsGroupPolicy",
	2: "podInfoOnMount",
	3: "requiresRepublish",
	4: "storageCapacity",
	5: "tokenRequests",
	6: "volumeLifecycleModes",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverSpec from json.
func (s *IoK8sAPIStorageV1CSIDriverSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSIDriverSpec to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachRequired":
			s.AttachRequired.Reset()
			if err := s.AttachRequired.Decode(d); err != nil {
				return err
			}
		case "fsGroupPolicy":
			s.FsGroupPolicy.Reset()
			if err := s.FsGroupPolicy.Decode(d); err != nil {
				return err
			}
		case "podInfoOnMount":
			s.PodInfoOnMount.Reset()
			if err := s.PodInfoOnMount.Decode(d); err != nil {
				return err
			}
		case "requiresRepublish":
			s.RequiresRepublish.Reset()
			if err := s.RequiresRepublish.Decode(d); err != nil {
				return err
			}
		case "storageCapacity":
			s.StorageCapacity.Reset()
			if err := s.StorageCapacity.Decode(d); err != nil {
				return err
			}
		case "tokenRequests":
			s.TokenRequests = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1TokenRequest
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TokenRequests = append(s.TokenRequests, elem)
				return nil
			}); err != nil {
				return err
			}
		case "volumeLifecycleModes":
			s.VolumeLifecycleModes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.VolumeLifecycleModes = append(s.VolumeLifecycleModes, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINode) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINode = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSINode from json.
func (s *IoK8sAPIStorageV1CSINode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSINode to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINode) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeDriver) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Allocatable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Allocatable.Set {
			e.RawStr("\"allocatable\"" + ":")
			s.Allocatable.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"nodeID\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.TopologyKeys != nil {
			e.Comma()
		}
		if s.TopologyKeys != nil {
			e.RawStr("\"topologyKeys\"" + ":")
			e.ArrStart()
			if len(s.TopologyKeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TopologyKeys[0]
					e.Str(elem)
				}
				for _, elem := range s.TopologyKeys[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver = [4]string{
	0: "allocatable",
	1: "name",
	2: "nodeID",
	3: "topologyKeys",
}

// Decode decodes IoK8sAPIStorageV1CSINodeDriver from json.
func (s *IoK8sAPIStorageV1CSINodeDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSINodeDriver to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocatable":
			s.Allocatable.Reset()
			if err := s.Allocatable.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "nodeID":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "topologyKeys":
			s.TopologyKeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.TopologyKeys = append(s.TopologyKeys, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSINodeList from json.
func (s *IoK8sAPIStorageV1CSINodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSINodeList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1CSINode
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1CSINodeSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"drivers\"" + ":")
		e.ArrStart()
		if len(s.Drivers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Drivers[0]
				elem.Encode(e)
			}
			for _, elem := range s.Drivers[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec = [1]string{
	0: "drivers",
}

// Decode decodes IoK8sAPIStorageV1CSINodeSpec from json.
func (s *IoK8sAPIStorageV1CSINodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1CSINodeSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drivers":
			requiredBitSet[0] |= 1 << 0
			s.Drivers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1CSINodeDriver
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Drivers = append(s.Drivers, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClass) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowVolumeExpansion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowVolumeExpansion.Set {
			e.RawStr("\"allowVolumeExpansion\"" + ":")
			s.AllowVolumeExpansion.Encode(e)
		}
	}
	{
		if s.AllowedTopologies != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedTopologies != nil {
			e.RawStr("\"allowedTopologies\"" + ":")
			e.ArrStart()
			if len(s.AllowedTopologies) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedTopologies[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllowedTopologies[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MountOptions != nil {
			e.RawStr("\"mountOptions\"" + ":")
			e.ArrStart()
			if len(s.MountOptions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MountOptions[0]
					e.Str(elem)
				}
				for _, elem := range s.MountOptions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Parameters.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parameters.Set {
			e.RawStr("\"parameters\"" + ":")
			s.Parameters.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"provisioner\"" + ":")
		e.Str(s.Provisioner)
	}
	{
		if s.ReclaimPolicy.Set {
			e.Comma()
		}
		if s.ReclaimPolicy.Set {
			e.RawStr("\"reclaimPolicy\"" + ":")
			s.ReclaimPolicy.Encode(e)
		}
	}
	{
		if s.VolumeBindingMode.Set {
			e.Comma()
		}
		if s.VolumeBindingMode.Set {
			e.RawStr("\"volumeBindingMode\"" + ":")
			s.VolumeBindingMode.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClass = [10]string{
	0: "allowVolumeExpansion",
	1: "allowedTopologies",
	2: "apiVersion",
	3: "kind",
	4: "metadata",
	5: "mountOptions",
	6: "parameters",
	7: "provisioner",
	8: "reclaimPolicy",
	9: "volumeBindingMode",
}

// Decode decodes IoK8sAPIStorageV1StorageClass from json.
func (s *IoK8sAPIStorageV1StorageClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1StorageClass to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowVolumeExpansion":
			s.AllowVolumeExpansion.Reset()
			if err := s.AllowVolumeExpansion.Decode(d); err != nil {
				return err
			}
		case "allowedTopologies":
			s.AllowedTopologies = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPICoreV1TopologySelectorTerm
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AllowedTopologies = append(s.AllowedTopologies, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "mountOptions":
			s.MountOptions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.MountOptions = append(s.MountOptions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "parameters":
			s.Parameters.Reset()
			if err := s.Parameters.Decode(d); err != nil {
				return err
			}
		case "provisioner":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Str()
			s.Provisioner = string(v)
			if err != nil {
				return err
			}
		case "reclaimPolicy":
			s.ReclaimPolicy.Reset()
			if err := s.ReclaimPolicy.Decode(d); err != nil {
				return err
			}
		case "volumeBindingMode":
			s.VolumeBindingMode.Reset()
			if err := s.VolumeBindingMode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClass) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClassList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1StorageClassList from json.
func (s *IoK8sAPIStorageV1StorageClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1StorageClassList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1StorageClass
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1TokenRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"audience\"" + ":")
		e.Str(s.Audience)
	}
	{
		if s.ExpirationSeconds.Set {
			e.Comma()
		}
		if s.ExpirationSeconds.Set {
			e.RawStr("\"expirationSeconds\"" + ":")
			s.ExpirationSeconds.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest = [2]string{
	0: "audience",
	1: "expirationSeconds",
}

// Decode decodes IoK8sAPIStorageV1TokenRequest from json.
func (s *IoK8sAPIStorageV1TokenRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1TokenRequest to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Audience = string(v)
			if err != nil {
				return err
			}
		case "expirationSeconds":
			s.ExpirationSeconds.Reset()
			if err := s.ExpirationSeconds.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachment from json.
func (s *IoK8sAPIStorageV1VolumeAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeAttachment to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentList from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1VolumeAttachment
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.InlineVolumeSpec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineVolumeSpec.Set {
			e.RawStr("\"inlineVolumeSpec\"" + ":")
			s.InlineVolumeSpec.Encode(e)
		}
	}
	{
		if s.PersistentVolumeName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PersistentVolumeName.Set {
			e.RawStr("\"persistentVolumeName\"" + ":")
			s.PersistentVolumeName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSource = [2]string{
	0: "inlineVolumeSpec",
	1: "persistentVolumeName",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSource from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSource to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inlineVolumeSpec":
			s.InlineVolumeSpec.Reset()
			if err := s.InlineVolumeSpec.Decode(d); err != nil {
				return err
			}
		case "persistentVolumeName":
			s.PersistentVolumeName.Reset()
			if err := s.PersistentVolumeName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"attacher\"" + ":")
		e.Str(s.Attacher)
	}
	{
		e.Comma()

		e.RawStr("\"nodeName\"" + ":")
		e.Str(s.NodeName)
	}
	{
		e.Comma()

		e.RawStr("\"source\"" + ":")
		s.Source.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec = [3]string{
	0: "attacher",
	1: "nodeName",
	2: "source",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSpec from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacher":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Attacher = string(v)
			if err != nil {
				return err
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.NodeName = string(v)
			if err != nil {
				return err
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AttachError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AttachError.Set {
			e.RawStr("\"attachError\"" + ":")
			s.AttachError.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"attached\"" + ":")
		e.Bool(s.Attached)
	}
	{
		if s.AttachmentMetadata.Set {
			e.Comma()
		}
		if s.AttachmentMetadata.Set {
			e.RawStr("\"attachmentMetadata\"" + ":")
			s.AttachmentMetadata.Encode(e)
		}
	}
	{
		if s.DetachError.Set {
			e.Comma()
		}
		if s.DetachError.Set {
			e.RawStr("\"detachError\"" + ":")
			s.DetachError.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus = [4]string{
	0: "attachError",
	1: "attached",
	2: "attachmentMetadata",
	3: "detachError",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentStatus to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachError":
			s.AttachError.Reset()
			if err := s.AttachError.Decode(d); err != nil {
				return err
			}
		case "attached":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Attached = bool(v)
			if err != nil {
				return err
			}
		case "attachmentMetadata":
			s.AttachmentMetadata.Reset()
			if err := s.AttachmentMetadata.Decode(d); err != nil {
				return err
			}
		case "detachError":
			s.DetachError.Reset()
			if err := s.DetachError.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Time.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Time.Set {
			e.RawStr("\"time\"" + ":")
			s.Time.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeError = [2]string{
	0: "message",
	1: "time",
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (s *IoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeError to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "time":
			s.Time.Reset()
			if err := s.Time.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Count.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Count.Set {
			e.RawStr("\"count\"" + ":")
			s.Count.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeNodeResources = [1]string{
	0: "count",
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (s *IoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1VolumeNodeResources to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			s.Count.Reset()
			if err := s.Count.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1alpha1CSIStorageCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaximumVolumeSize.Set {
			e.RawStr("\"maximumVolumeSize\"" + ":")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeTopology.Set {
			e.RawStr("\"nodeTopology\"" + ":")
			s.NodeTopology.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"storageClassName\"" + ":")
		e.Str(s.StorageClassName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacity to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "capacity":
			s.Capacity.Reset()
			if err := s.Capacity.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "maximumVolumeSize":
			s.MaximumVolumeSize.Reset()
			if err := s.MaximumVolumeSize.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "nodeTopology":
			s.NodeTopology.Reset()
			if err := s.NodeTopology.Decode(d); err != nil {
				return err
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.StorageClassName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacityList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1alpha1CSIStorageCapacity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1beta1CSIStorageCapacity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Capacity.Set {
			e.RawStr("\"capacity\"" + ":")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaximumVolumeSize.Set {
			e.RawStr("\"maximumVolumeSize\"" + ":")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeTopology.Set {
			e.RawStr("\"nodeTopology\"" + ":")
			s.NodeTopology.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"storageClassName\"" + ":")
		e.Str(s.StorageClassName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacity to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "capacity":
			s.Capacity.Reset()
			if err := s.Capacity.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "maximumVolumeSize":
			s.MaximumVolumeSize.Reset()
			if err := s.MaximumVolumeSize.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "nodeTopology":
			s.NodeTopology.Reset()
			if err := s.NodeTopology.Decode(d); err != nil {
				return err
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.StorageClassName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1beta1CSIStorageCapacityList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacityList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sAPIStorageV1beta1CSIStorageCapacity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Format.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Format.Set {
			e.RawStr("\"format\"" + ":")
			s.Format.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"jsonPath\"" + ":")
		e.Str(s.JsonPath)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Priority.Set {
			e.Comma()
		}
		if s.Priority.Set {
			e.RawStr("\"priority\"" + ":")
			s.Priority.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition = [6]string{
	0: "description",
	1: "format",
	2: "jsonPath",
	3: "name",
	4: "priority",
	5: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "format":
			s.Format.Reset()
			if err := s.Format.Decode(d); err != nil {
				return err
			}
		case "jsonPath":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.JsonPath = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "priority":
			s.Priority.Reset()
			if err := s.Priority.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"strategy\"" + ":")
		e.Str(s.Strategy)
	}
	{
		if s.Webhook.Set {
			e.Comma()
		}
		if s.Webhook.Set {
			e.RawStr("\"webhook\"" + ":")
			s.Webhook.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion = [2]string{
	0: "strategy",
	1: "webhook",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strategy":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Strategy = string(v)
			if err != nil {
				return err
			}
		case "webhook":
			s.Webhook.Reset()
			if err := s.Webhook.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"spec\"" + ":")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Categories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Str(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		if s.ListKind.Set {
			e.Comma()
		}
		if s.ListKind.Set {
			e.RawStr("\"listKind\"" + ":")
			s.ListKind.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"plural\"" + ":")
		e.Str(s.Plural)
	}
	{
		if s.ShortNames != nil {
			e.Comma()
		}
		if s.ShortNames != nil {
			e.RawStr("\"shortNames\"" + ":")
			e.ArrStart()
			if len(s.ShortNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ShortNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ShortNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Singular.Set {
			e.Comma()
		}
		if s.Singular.Set {
			e.RawStr("\"singular\"" + ":")
			s.Singular.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames = [6]string{
	0: "categories",
	1: "kind",
	2: "listKind",
	3: "plural",
	4: "shortNames",
	5: "singular",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "listKind":
			s.ListKind.Reset()
			if err := s.ListKind.Decode(d); err != nil {
				return err
			}
		case "plural":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Plural = string(v)
			if err != nil {
				return err
			}
		case "shortNames":
			s.ShortNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ShortNames = append(s.ShortNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "singular":
			s.Singular.Reset()
			if err := s.Singular.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conversion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conversion.Set {
			e.RawStr("\"conversion\"" + ":")
			s.Conversion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group\"" + ":")
		e.Str(s.Group)
	}
	{
		e.Comma()

		e.RawStr("\"names\"" + ":")
		s.Names.Encode(e)
	}
	{
		if s.PreserveUnknownFields.Set {
			e.Comma()
		}
		if s.PreserveUnknownFields.Set {
			e.RawStr("\"preserveUnknownFields\"" + ":")
			s.PreserveUnknownFields.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"scope\"" + ":")
		e.Str(s.Scope)
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec = [6]string{
	0: "conversion",
	1: "group",
	2: "names",
	3: "preserveUnknownFields",
	4: "scope",
	5: "versions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversion":
			s.Conversion.Reset()
			if err := s.Conversion.Decode(d); err != nil {
				return err
			}
		case "group":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Group = string(v)
			if err != nil {
				return err
			}
		case "names":
			requiredBitSet[0] |= 1 << 2
			if err := s.Names.Decode(d); err != nil {
				return err
			}
		case "preserveUnknownFields":
			s.PreserveUnknownFields.Reset()
			if err := s.PreserveUnknownFields.Decode(d); err != nil {
				return err
			}
		case "scope":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Scope = string(v)
			if err != nil {
				return err
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			s.Versions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Versions = append(s.Versions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AcceptedNames.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AcceptedNames.Set {
			e.RawStr("\"acceptedNames\"" + ":")
			s.AcceptedNames.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StoredVersions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StoredVersions != nil {
			e.RawStr("\"storedVersions\"" + ":")
			e.ArrStart()
			if len(s.StoredVersions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.StoredVersions[0]
					e.Str(elem)
				}
				for _, elem := range s.StoredVersions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus = [3]string{
	0: "acceptedNames",
	1: "conditions",
	2: "storedVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acceptedNames":
			s.AcceptedNames.Reset()
			if err := s.AcceptedNames.Decode(d); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "storedVersions":
			s.StoredVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.StoredVersions = append(s.StoredVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdditionalPrinterColumns != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalPrinterColumns != nil {
			e.RawStr("\"additionalPrinterColumns\"" + ":")
			e.ArrStart()
			if len(s.AdditionalPrinterColumns) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AdditionalPrinterColumns[0]
					elem.Encode(e)
				}
				for _, elem := range s.AdditionalPrinterColumns[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Deprecated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deprecated.Set {
			e.RawStr("\"deprecated\"" + ":")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.DeprecationWarning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeprecationWarning.Set {
			e.RawStr("\"deprecationWarning\"" + ":")
			s.DeprecationWarning.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Schema.Set {
			e.Comma()
		}
		if s.Schema.Set {
			e.RawStr("\"schema\"" + ":")
			s.Schema.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"served\"" + ":")
		e.Bool(s.Served)
	}
	{
		e.Comma()

		e.RawStr("\"storage\"" + ":")
		e.Bool(s.Storage)
	}
	{
		if s.Subresources.Set {
			e.Comma()
		}
		if s.Subresources.Set {
			e.RawStr("\"subresources\"" + ":")
			s.Subresources.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion = [8]string{
	0: "additionalPrinterColumns",
	1: "deprecated",
	2: "deprecationWarning",
	3: "name",
	4: "schema",
	5: "served",
	6: "storage",
	7: "subresources",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additionalPrinterColumns":
			s.AdditionalPrinterColumns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalPrinterColumns = append(s.AdditionalPrinterColumns, elem)
				return nil
			}); err != nil {
				return err
			}
		case "deprecated":
			s.Deprecated.Reset()
			if err := s.Deprecated.Decode(d); err != nil {
				return err
			}
		case "deprecationWarning":
			s.DeprecationWarning.Reset()
			if err := s.DeprecationWarning.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "schema":
			s.Schema.Reset()
			if err := s.Schema.Decode(d); err != nil {
				return err
			}
		case "served":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.Served = bool(v)
			if err != nil {
				return err
			}
		case "storage":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Bool()
			s.Storage = bool(v)
			if err != nil {
				return err
			}
		case "subresources":
			s.Subresources.Reset()
			if err := s.Subresources.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LabelSelectorPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelSelectorPath.Set {
			e.RawStr("\"labelSelectorPath\"" + ":")
			s.LabelSelectorPath.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"specReplicasPath\"" + ":")
		e.Str(s.SpecReplicasPath)
	}
	{
		e.Comma()

		e.RawStr("\"statusReplicasPath\"" + ":")
		e.Str(s.StatusReplicasPath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale = [3]string{
	0: "labelSelectorPath",
	1: "specReplicasPath",
	2: "statusReplicasPath",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelectorPath":
			s.LabelSelectorPath.Reset()
			if err := s.LabelSelectorPath.Decode(d); err != nil {
				return err
			}
		case "specReplicasPath":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.SpecReplicasPath = string(v)
			if err != nil {
				return err
			}
		case "statusReplicasPath":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.StatusReplicasPath = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scale.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scale.Set {
			e.RawStr("\"scale\"" + ":")
			s.Scale.Encode(e)
		}
	}
	{
		if s.Status != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status != nil {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources = [2]string{
	0: "scale",
	1: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scale":
			s.Scale.Reset()
			if err := s.Scale.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Status = &elem
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.OpenAPIV3Schema.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenAPIV3Schema.Set {
			e.RawStr("\"openAPIV3Schema\"" + ":")
			s.OpenAPIV3Schema.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation = [1]string{
	0: "openAPIV3Schema",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openAPIV3Schema":
			s.OpenAPIV3Schema.Reset()
			if err := s.OpenAPIV3Schema.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation = [2]string{
	0: "description",
	1: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schema.Set {
			e.RawStr("\"$schema\"" + ":")
			s.Schema.Encode(e)
		}
	}
	{
		if s.AdditionalItems != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalItems != nil {
			e.RawStr("\"additionalItems\"" + ":")
			s.AdditionalItems.Encode(e)
		}
	}
	{
		if s.AdditionalProperties != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdditionalProperties != nil {
			e.RawStr("\"additionalProperties\"" + ":")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.AllOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllOf != nil {
			e.RawStr("\"allOf\"" + ":")
			e.ArrStart()
			if len(s.AllOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.AllOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnyOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnyOf != nil {
			e.RawStr("\"anyOf\"" + ":")
			e.ArrStart()
			if len(s.AnyOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AnyOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.AnyOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Default != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default != nil {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.Definitions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Definitions.Set {
			e.RawStr("\"definitions\"" + ":")
			s.Definitions.Encode(e)
		}
	}
	{
		if s.Dependencies.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Dependencies.Set {
			e.RawStr("\"dependencies\"" + ":")
			s.Dependencies.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Enum != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enum != nil {
			e.RawStr("\"enum\"" + ":")
			e.ArrStart()
			if len(s.Enum) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Enum[0]
					elem.Encode(e)
				}
				for _, elem := range s.Enum[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Example != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Example != nil {
			e.RawStr("\"example\"" + ":")
			s.Example.Encode(e)
		}
	}
	{
		if s.ExclusiveMaximum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExclusiveMaximum.Set {
			e.RawStr("\"exclusiveMaximum\"" + ":")
			s.ExclusiveMaximum.Encode(e)
		}
	}
	{
		if s.ExclusiveMinimum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExclusiveMinimum.Set {
			e.RawStr("\"exclusiveMinimum\"" + ":")
			s.ExclusiveMinimum.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalDocs.Set {
			e.RawStr("\"externalDocs\"" + ":")
			s.ExternalDocs.Encode(e)
		}
	}
	{
		if s.Format.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Format.Set {
			e.RawStr("\"format\"" + ":")
			s.Format.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Items != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Items != nil {
			e.RawStr("\"items\"" + ":")
			s.Items.Encode(e)
		}
	}
	{
		if s.MaxItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxItems.Set {
			e.RawStr("\"maxItems\"" + ":")
			s.MaxItems.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxLength.Set {
			e.RawStr("\"maxLength\"" + ":")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.MaxProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaxProperties.Set {
			e.RawStr("\"maxProperties\"" + ":")
			s.MaxProperties.Encode(e)
		}
	}
	{
		if s.Maximum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maximum.Set {
			e.RawStr("\"maximum\"" + ":")
			s.Maximum.Encode(e)
		}
	}
	{
		if s.MinItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinItems.Set {
			e.RawStr("\"minItems\"" + ":")
			s.MinItems.Encode(e)
		}
	}
	{
		if s.MinLength.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinLength.Set {
			e.RawStr("\"minLength\"" + ":")
			s.MinLength.Encode(e)
		}
	}
	{
		if s.MinProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MinProperties.Set {
			e.RawStr("\"minProperties\"" + ":")
			s.MinProperties.Encode(e)
		}
	}
	{
		if s.Minimum.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Minimum.Set {
			e.RawStr("\"minimum\"" + ":")
			s.Minimum.Encode(e)
		}
	}
	{
		if s.MultipleOf.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MultipleOf.Set {
			e.RawStr("\"multipleOf\"" + ":")
			s.MultipleOf.Encode(e)
		}
	}
	{
		if s.Not != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Not != nil {
			e.RawStr("\"not\"" + ":")
			s.Not.Encode(e)
		}
	}
	{
		if s.Nullable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nullable.Set {
			e.RawStr("\"nullable\"" + ":")
			s.Nullable.Encode(e)
		}
	}
	{
		if s.OneOf != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OneOf != nil {
			e.RawStr("\"oneOf\"" + ":")
			e.ArrStart()
			if len(s.OneOf) >= 1 {
				// Encode first element without comma.
				{
					elem := s.OneOf[0]
					elem.Encode(e)
				}
				for _, elem := range s.OneOf[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pattern.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pattern.Set {
			e.RawStr("\"pattern\"" + ":")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.PatternProperties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PatternProperties.Set {
			e.RawStr("\"patternProperties\"" + ":")
			s.PatternProperties.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Properties.Set {
			e.RawStr("\"properties\"" + ":")
			s.Properties.Encode(e)
		}
	}
	{
		if s.Required != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Required != nil {
			e.RawStr("\"required\"" + ":")
			e.ArrStart()
			if len(s.Required) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Required[0]
					e.Str(elem)
				}
				for _, elem := range s.Required[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.UniqueItems.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UniqueItems.Set {
			e.RawStr("\"uniqueItems\"" + ":")
			s.UniqueItems.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusEmbeddedMinusResource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusEmbeddedMinusResource.Set {
			e.RawStr("\"x-kubernetes-embedded-resource\"" + ":")
			s.XMinusKubernetesMinusEmbeddedMinusResource.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusIntMinusOrMinusString.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusIntMinusOrMinusString.Set {
			e.RawStr("\"x-kubernetes-int-or-string\"" + ":")
			s.XMinusKubernetesMinusIntMinusOrMinusString.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusMapMinusKeys != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusListMinusMapMinusKeys != nil {
			e.RawStr("\"x-kubernetes-list-map-keys\"" + ":")
			e.ArrStart()
			if len(s.XMinusKubernetesMinusListMinusMapMinusKeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.XMinusKubernetesMinusListMinusMapMinusKeys[0]
					e.Str(elem)
				}
				for _, elem := range s.XMinusKubernetesMinusListMinusMapMinusKeys[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusListMinusType.Set {
			e.RawStr("\"x-kubernetes-list-type\"" + ":")
			s.XMinusKubernetesMinusListMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusMapMinusType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusMapMinusType.Set {
			e.RawStr("\"x-kubernetes-map-type\"" + ":")
			s.XMinusKubernetesMinusMapMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Set {
			e.RawStr("\"x-kubernetes-preserve-unknown-fields\"" + ":")
			s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps = [43]string{
	0:  "$ref",
	1:  "$schema",
	2:  "additionalItems",
	3:  "additionalProperties",
	4:  "allOf",
	5:  "anyOf",
	6:  "default",
	7:  "definitions",
	8:  "dependencies",
	9:  "description",
	10: "enum",
	11: "example",
	12: "exclusiveMaximum",
	13: "exclusiveMinimum",
	14: "externalDocs",
	15: "format",
	16: "id",
	17: "items",
	18: "maxItems",
	19: "maxLength",
	20: "maxProperties",
	21: "maximum",
	22: "minItems",
	23: "minLength",
	24: "minProperties",
	25: "minimum",
	26: "multipleOf",
	27: "not",
	28: "nullable",
	29: "oneOf",
	30: "pattern",
	31: "patternProperties",
	32: "properties",
	33: "required",
	34: "title",
	35: "type",
	36: "uniqueItems",
	37: "x-kubernetes-embedded-resource",
	38: "x-kubernetes-int-or-string",
	39: "x-kubernetes-list-map-keys",
	40: "x-kubernetes-list-type",
	41: "x-kubernetes-map-type",
	42: "x-kubernetes-preserve-unknown-fields",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "$schema":
			s.Schema.Reset()
			if err := s.Schema.Decode(d); err != nil {
				return err
			}
		case "additionalItems":
			s.AdditionalItems = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.AdditionalItems = &elem
		case "additionalProperties":
			s.AdditionalProperties = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.AdditionalProperties = &elem
		case "allOf":
			s.AllOf = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AllOf = append(s.AllOf, elem)
				return nil
			}); err != nil {
				return err
			}
		case "anyOf":
			s.AnyOf = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AnyOf = append(s.AnyOf, elem)
				return nil
			}); err != nil {
				return err
			}
		case "default":
			s.Default = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Default = &elem
		case "definitions":
			s.Definitions.Reset()
			if err := s.Definitions.Decode(d); err != nil {
				return err
			}
		case "dependencies":
			s.Dependencies.Reset()
			if err := s.Dependencies.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "enum":
			s.Enum = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Enum = append(s.Enum, elem)
				return nil
			}); err != nil {
				return err
			}
		case "example":
			s.Example = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Example = &elem
		case "exclusiveMaximum":
			s.ExclusiveMaximum.Reset()
			if err := s.ExclusiveMaximum.Decode(d); err != nil {
				return err
			}
		case "exclusiveMinimum":
			s.ExclusiveMinimum.Reset()
			if err := s.ExclusiveMinimum.Decode(d); err != nil {
				return err
			}
		case "externalDocs":
			s.ExternalDocs.Reset()
			if err := s.ExternalDocs.Decode(d); err != nil {
				return err
			}
		case "format":
			s.Format.Reset()
			if err := s.Format.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "items":
			s.Items = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Items = &elem
		case "maxItems":
			s.MaxItems.Reset()
			if err := s.MaxItems.Decode(d); err != nil {
				return err
			}
		case "maxLength":
			s.MaxLength.Reset()
			if err := s.MaxLength.Decode(d); err != nil {
				return err
			}
		case "maxProperties":
			s.MaxProperties.Reset()
			if err := s.MaxProperties.Decode(d); err != nil {
				return err
			}
		case "maximum":
			s.Maximum.Reset()
			if err := s.Maximum.Decode(d); err != nil {
				return err
			}
		case "minItems":
			s.MinItems.Reset()
			if err := s.MinItems.Decode(d); err != nil {
				return err
			}
		case "minLength":
			s.MinLength.Reset()
			if err := s.MinLength.Decode(d); err != nil {
				return err
			}
		case "minProperties":
			s.MinProperties.Reset()
			if err := s.MinProperties.Decode(d); err != nil {
				return err
			}
		case "minimum":
			s.Minimum.Reset()
			if err := s.Minimum.Decode(d); err != nil {
				return err
			}
		case "multipleOf":
			s.MultipleOf.Reset()
			if err := s.MultipleOf.Decode(d); err != nil {
				return err
			}
		case "not":
			s.Not = nil
			var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Not = &elem
		case "nullable":
			s.Nullable.Reset()
			if err := s.Nullable.Decode(d); err != nil {
				return err
			}
		case "oneOf":
			s.OneOf = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OneOf = append(s.OneOf, elem)
				return nil
			}); err != nil {
				return err
			}
		case "pattern":
			s.Pattern.Reset()
			if err := s.Pattern.Decode(d); err != nil {
				return err
			}
		case "patternProperties":
			s.PatternProperties.Reset()
			if err := s.PatternProperties.Decode(d); err != nil {
				return err
			}
		case "properties":
			s.Properties.Reset()
			if err := s.Properties.Decode(d); err != nil {
				return err
			}
		case "required":
			s.Required = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Required = append(s.Required, elem)
				return nil
			}); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "uniqueItems":
			s.UniqueItems.Reset()
			if err := s.UniqueItems.Decode(d); err != nil {
				return err
			}
		case "x-kubernetes-embedded-resource":
			s.XMinusKubernetesMinusEmbeddedMinusResource.Reset()
			if err := s.XMinusKubernetesMinusEmbeddedMinusResource.Decode(d); err != nil {
				return err
			}
		case "x-kubernetes-int-or-string":
			s.XMinusKubernetesMinusIntMinusOrMinusString.Reset()
			if err := s.XMinusKubernetesMinusIntMinusOrMinusString.Decode(d); err != nil {
				return err
			}
		case "x-kubernetes-list-map-keys":
			s.XMinusKubernetesMinusListMinusMapMinusKeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.XMinusKubernetesMinusListMinusMapMinusKeys = append(s.XMinusKubernetesMinusListMinusMapMinusKeys, elem)
				return nil
			}); err != nil {
				return err
			}
		case "x-kubernetes-list-type":
			s.XMinusKubernetesMinusListMinusType.Reset()
			if err := s.XMinusKubernetesMinusListMinusType.Decode(d); err != nil {
				return err
			}
		case "x-kubernetes-map-type":
			s.XMinusKubernetesMinusMapMinusType.Reset()
			if err := s.XMinusKubernetesMinusMapMinusType.Decode(d); err != nil {
				return err
			}
		case "x-kubernetes-preserve-unknown-fields":
			s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Reset()
			if err := s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespace\"" + ":")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.Comma()
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Namespace = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			v, err := d.Base64()
			s.CaBundle = []byte(v)
			if err != nil {
				return err
			}
		case "service":
			s.Service.Reset()
			if err := s.Service.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ClientConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientConfig.Set {
			e.RawStr("\"clientConfig\"" + ":")
			s.ClientConfig.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"conversionReviewVersions\"" + ":")
		e.ArrStart()
		if len(s.ConversionReviewVersions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ConversionReviewVersions[0]
				e.Str(elem)
			}
			for _, elem := range s.ConversionReviewVersions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion = [2]string{
	0: "clientConfig",
	1: "conversionReviewVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientConfig":
			s.ClientConfig.Reset()
			if err := s.ClientConfig.Decode(d); err != nil {
				return err
			}
		case "conversionReviewVersions":
			requiredBitSet[0] |= 1 << 1
			s.ConversionReviewVersions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ConversionReviewVersions = append(s.ConversionReviewVersions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (s IoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (s *IoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgAPIResourceQuantity to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIGroup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.PreferredVersion.Set {
			e.Comma()
		}
		if s.PreferredVersion.Set {
			e.RawStr("\"preferredVersion\"" + ":")
			s.PreferredVersion.Encode(e)
		}
	}
	{
		if s.ServerAddressByClientCIDRs != nil {
			e.Comma()
		}
		if s.ServerAddressByClientCIDRs != nil {
			e.RawStr("\"serverAddressByClientCIDRs\"" + ":")
			e.ArrStart()
			if len(s.ServerAddressByClientCIDRs) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ServerAddressByClientCIDRs[0]
					elem.Encode(e)
				}
				for _, elem := range s.ServerAddressByClientCIDRs[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup = [6]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
	3: "preferredVersion",
	4: "serverAddressByClientCIDRs",
	5: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroup from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroup to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "preferredVersion":
			s.PreferredVersion.Reset()
			if err := s.PreferredVersion.Decode(d); err != nil {
				return err
			}
		case "serverAddressByClientCIDRs":
			s.ServerAddressByClientCIDRs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			s.Versions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Versions = append(s.Versions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIGroupList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groups\"" + ":")
		e.ArrStart()
		if len(s.Groups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Groups[0]
				elem.Encode(e)
			}
			for _, elem := range s.Groups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList = [3]string{
	0: "apiVersion",
	1: "groups",
	2: "kind",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroupList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroupList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "groups":
			requiredBitSet[0] |= 1 << 1
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1APIGroup
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIResource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Categories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Str(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Group.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"namespaced\"" + ":")
		e.Bool(s.Namespaced)
	}
	{
		if s.ShortNames != nil {
			e.Comma()
		}
		if s.ShortNames != nil {
			e.RawStr("\"shortNames\"" + ":")
			e.ArrStart()
			if len(s.ShortNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ShortNames[0]
					e.Str(elem)
				}
				for _, elem := range s.ShortNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"singularName\"" + ":")
		e.Str(s.SingularName)
	}
	{
		if s.StorageVersionHash.Set {
			e.Comma()
		}
		if s.StorageVersionHash.Set {
			e.RawStr("\"storageVersionHash\"" + ":")
			s.StorageVersionHash.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"verbs\"" + ":")
		e.ArrStart()
		if len(s.Verbs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Verbs[0]
				e.Str(elem)
			}
			for _, elem := range s.Verbs[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Version.Set {
			e.Comma()
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource = [10]string{
	0: "categories",
	1: "group",
	2: "kind",
	3: "name",
	4: "namespaced",
	5: "shortNames",
	6: "singularName",
	7: "storageVersionHash",
	8: "verbs",
	9: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResource from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResource to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			s.Categories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Categories = append(s.Categories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "group":
			s.Group.Reset()
			if err := s.Group.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "namespaced":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.Namespaced = bool(v)
			if err != nil {
				return err
			}
		case "shortNames":
			s.ShortNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ShortNames = append(s.ShortNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "singularName":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.SingularName = string(v)
			if err != nil {
				return err
			}
		case "storageVersionHash":
			s.StorageVersionHash.Reset()
			if err := s.StorageVersionHash.Decode(d); err != nil {
				return err
			}
		case "verbs":
			requiredBitSet[1] |= 1 << 0
			s.Verbs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Verbs = append(s.Verbs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIResourceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groupVersion\"" + ":")
		e.Str(s.GroupVersion)
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList = [4]string{
	0: "apiVersion",
	1: "groupVersion",
	2: "kind",
	3: "resources",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResourceList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResourceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "groupVersion":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.GroupVersion = string(v)
			if err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1APIResource
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1APIVersions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"serverAddressByClientCIDRs\"" + ":")
		e.ArrStart()
		if len(s.ServerAddressByClientCIDRs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ServerAddressByClientCIDRs[0]
				elem.Encode(e)
			}
			for _, elem := range s.ServerAddressByClientCIDRs[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"versions\"" + ":")
		e.ArrStart()
		if len(s.Versions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Versions[0]
				e.Str(elem)
			}
			for _, elem := range s.Versions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "serverAddressByClientCIDRs",
	3: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIVersions from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIVersions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "serverAddressByClientCIDRs":
			requiredBitSet[0] |= 1 << 2
			s.ServerAddressByClientCIDRs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
				return nil
			}); err != nil {
				return err
			}
		case "versions":
			requiredBitSet[0] |= 1 << 3
			s.Versions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Versions = append(s.Versions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1Condition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lastTransitionTime\"" + ":")
		s.LastTransitionTime.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		if s.ObservedGeneration.Set {
			e.Comma()
		}
		if s.ObservedGeneration.Set {
			e.RawStr("\"observedGeneration\"" + ":")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Condition from json.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Condition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			requiredBitSet[0] |= 1 << 0
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.LastTransitionTime = IoK8sApimachineryPkgApisMetaV1Time(unwrapped)
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "observedGeneration":
			s.ObservedGeneration.Reset()
			if err := s.ObservedGeneration.Decode(d); err != nil {
				return err
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1FieldsV1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1FieldsV1 = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1FieldsV1 from json.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1FieldsV1 to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groupVersion\"" + ":")
		e.Str(s.GroupVersion)
	}
	{
		e.Comma()

		e.RawStr("\"version\"" + ":")
		e.Str(s.Version)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery = [2]string{
	0: "groupVersion",
	1: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groupVersion":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.GroupVersion = string(v)
			if err != nil {
				return err
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Version = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MatchExpressions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchExpressions != nil {
			e.RawStr("\"matchExpressions\"" + ":")
			e.ArrStart()
			if len(s.MatchExpressions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.MatchExpressions[0]
					elem.Encode(e)
				}
				for _, elem := range s.MatchExpressions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MatchLabels.Set {
			e.RawStr("\"matchLabels\"" + ":")
			s.MatchLabels.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelector to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			s.MatchExpressions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MatchExpressions = append(s.MatchExpressions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "matchLabels":
			s.MatchLabels.Reset()
			if err := s.MatchLabels.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"operator\"" + ":")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.Comma()
		}
		if s.Values != nil {
			e.RawStr("\"values\"" + ":")
			e.ArrStart()
			if len(s.Values) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Values[0]
					e.Str(elem)
				}
				for _, elem := range s.Values[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Operator = string(v)
			if err != nil {
				return err
			}
		case "values":
			s.Values = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Values = append(s.Values, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Continue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Continue.Set {
			e.RawStr("\"continue\"" + ":")
			s.Continue.Encode(e)
		}
	}
	{
		if s.RemainingItemCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemainingItemCount.Set {
			e.RawStr("\"remainingItemCount\"" + ":")
			s.RemainingItemCount.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelfLink.Set {
			e.RawStr("\"selfLink\"" + ":")
			s.SelfLink.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ListMeta = [4]string{
	0: "continue",
	1: "remainingItemCount",
	2: "resourceVersion",
	3: "selfLink",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ListMeta to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continue":
			s.Continue.Reset()
			if err := s.Continue.Decode(d); err != nil {
				return err
			}
		case "remainingItemCount":
			s.RemainingItemCount.Reset()
			if err := s.RemainingItemCount.Decode(d); err != nil {
				return err
			}
		case "resourceVersion":
			s.ResourceVersion.Reset()
			if err := s.ResourceVersion.Decode(d); err != nil {
				return err
			}
		case "selfLink":
			s.SelfLink.Reset()
			if err := s.SelfLink.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldsType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldsType.Set {
			e.RawStr("\"fieldsType\"" + ":")
			s.FieldsType.Encode(e)
		}
	}
	{
		if s.FieldsV1 != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FieldsV1 != nil {
			e.RawStr("\"fieldsV1\"" + ":")
			s.FieldsV1.Encode(e)
		}
	}
	{
		if s.Manager.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Manager.Set {
			e.RawStr("\"manager\"" + ":")
			s.Manager.Encode(e)
		}
	}
	{
		if s.Operation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Operation.Set {
			e.RawStr("\"operation\"" + ":")
			s.Operation.Encode(e)
		}
	}
	{
		if s.Subresource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subresource.Set {
			e.RawStr("\"subresource\"" + ":")
			s.Subresource.Encode(e)
		}
	}
	{
		if s.Time.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Time.Set {
			e.RawStr("\"time\"" + ":")
			s.Time.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry = [7]string{
	0: "apiVersion",
	1: "fieldsType",
	2: "fieldsV1",
	3: "manager",
	4: "operation",
	5: "subresource",
	6: "time",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry from json.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "fieldsType":
			s.FieldsType.Reset()
			if err := s.FieldsType.Decode(d); err != nil {
				return err
			}
		case "fieldsV1":
			s.FieldsV1 = nil
			var elem IoK8sApimachineryPkgApisMetaV1FieldsV1
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.FieldsV1 = &elem
		case "manager":
			s.Manager.Reset()
			if err := s.Manager.Decode(d); err != nil {
				return err
			}
		case "operation":
			s.Operation.Reset()
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		case "subresource":
			s.Subresource.Reset()
			if err := s.Subresource.Decode(d); err != nil {
				return err
			}
		case "time":
			s.Time.Reset()
			if err := s.Time.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (s IoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (s *IoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1MicroTime to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Annotations.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Annotations.Set {
			e.RawStr("\"annotations\"" + ":")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClusterName.Set {
			e.RawStr("\"clusterName\"" + ":")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreationTimestamp.Set {
			e.RawStr("\"creationTimestamp\"" + ":")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.DeletionGracePeriodSeconds.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeletionGracePeriodSeconds.Set {
			e.RawStr("\"deletionGracePeriodSeconds\"" + ":")
			s.DeletionGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.DeletionTimestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeletionTimestamp.Set {
			e.RawStr("\"deletionTimestamp\"" + ":")
			s.DeletionTimestamp.Encode(e)
		}
	}
	{
		if s.Finalizers != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Finalizers != nil {
			e.RawStr("\"finalizers\"" + ":")
			e.ArrStart()
			if len(s.Finalizers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Finalizers[0]
					e.Str(elem)
				}
				for _, elem := range s.Finalizers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.GenerateName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GenerateName.Set {
			e.RawStr("\"generateName\"" + ":")
			s.GenerateName.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Generation.Set {
			e.RawStr("\"generation\"" + ":")
			s.Generation.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Labels.Set {
			e.RawStr("\"labels\"" + ":")
			s.Labels.Encode(e)
		}
	}
	{
		if s.ManagedFields != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ManagedFields != nil {
			e.RawStr("\"managedFields\"" + ":")
			e.ArrStart()
			if len(s.ManagedFields) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ManagedFields[0]
					elem.Encode(e)
				}
				for _, elem := range s.ManagedFields[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.OwnerReferences != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OwnerReferences != nil {
			e.RawStr("\"ownerReferences\"" + ":")
			e.ArrStart()
			if len(s.OwnerReferences) >= 1 {
				// Encode first element without comma.
				{
					elem := s.OwnerReferences[0]
					elem.Encode(e)
				}
				for _, elem := range s.OwnerReferences[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceVersion.Set {
			e.RawStr("\"resourceVersion\"" + ":")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SelfLink.Set {
			e.RawStr("\"selfLink\"" + ":")
			s.SelfLink.Encode(e)
		}
	}
	{
		if s.UID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UID.Set {
			e.RawStr("\"uid\"" + ":")
			s.UID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ObjectMeta = [16]string{
	0:  "annotations",
	1:  "clusterName",
	2:  "creationTimestamp",
	3:  "deletionGracePeriodSeconds",
	4:  "deletionTimestamp",
	5:  "finalizers",
	6:  "generateName",
	7:  "generation",
	8:  "labels",
	9:  "managedFields",
	10: "name",
	11: "namespace",
	12: "ownerReferences",
	13: "resourceVersion",
	14: "selfLink",
	15: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMeta to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotations":
			s.Annotations.Reset()
			if err := s.Annotations.Decode(d); err != nil {
				return err
			}
		case "clusterName":
			s.ClusterName.Reset()
			if err := s.ClusterName.Decode(d); err != nil {
				return err
			}
		case "creationTimestamp":
			s.CreationTimestamp.Reset()
			if err := s.CreationTimestamp.Decode(d); err != nil {
				return err
			}
		case "deletionGracePeriodSeconds":
			s.DeletionGracePeriodSeconds.Reset()
			if err := s.DeletionGracePeriodSeconds.Decode(d); err != nil {
				return err
			}
		case "deletionTimestamp":
			s.DeletionTimestamp.Reset()
			if err := s.DeletionTimestamp.Decode(d); err != nil {
				return err
			}
		case "finalizers":
			s.Finalizers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Finalizers = append(s.Finalizers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "generateName":
			s.GenerateName.Reset()
			if err := s.GenerateName.Decode(d); err != nil {
				return err
			}
		case "generation":
			s.Generation.Reset()
			if err := s.Generation.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels.Reset()
			if err := s.Labels.Decode(d); err != nil {
				return err
			}
		case "managedFields":
			s.ManagedFields = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ManagedFields = append(s.ManagedFields, elem)
				return nil
			}); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		case "ownerReferences":
			s.OwnerReferences = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sApimachineryPkgApisMetaV1OwnerReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OwnerReferences = append(s.OwnerReferences, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resourceVersion":
			s.ResourceVersion.Reset()
			if err := s.ResourceVersion.Decode(d); err != nil {
				return err
			}
		case "selfLink":
			s.SelfLink.Reset()
			if err := s.SelfLink.Decode(d); err != nil {
				return err
			}
		case "uid":
			s.UID.Reset()
			if err := s.UID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1OwnerReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apiVersion\"" + ":")
		e.Str(s.ApiVersion)
	}
	{
		if s.BlockOwnerDeletion.Set {
			e.Comma()
		}
		if s.BlockOwnerDeletion.Set {
			e.RawStr("\"blockOwnerDeletion\"" + ":")
			s.BlockOwnerDeletion.Encode(e)
		}
	}
	{
		if s.Controller.Set {
			e.Comma()
		}
		if s.Controller.Set {
			e.RawStr("\"controller\"" + ":")
			s.Controller.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"kind\"" + ":")
		e.Str(s.Kind)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"uid\"" + ":")
		e.Str(s.UID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference = [6]string{
	0: "apiVersion",
	1: "blockOwnerDeletion",
	2: "controller",
	3: "kind",
	4: "name",
	5: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1OwnerReference from json.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1OwnerReference to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ApiVersion = string(v)
			if err != nil {
				return err
			}
		case "blockOwnerDeletion":
			s.BlockOwnerDeletion.Reset()
			if err := s.BlockOwnerDeletion.Decode(d); err != nil {
				return err
			}
		case "controller":
			s.Controller.Reset()
			if err := s.Controller.Decode(d); err != nil {
				return err
			}
		case "kind":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Kind = string(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "uid":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.UID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"clientCIDR\"" + ":")
		e.Str(s.ClientCIDR)
	}
	{
		e.Comma()

		e.RawStr("\"serverAddress\"" + ":")
		e.Str(s.ServerAddress)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR = [2]string{
	0: "clientCIDR",
	1: "serverAddress",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR from json.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientCIDR":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ClientCIDR = string(v)
			if err != nil {
				return err
			}
		case "serverAddress":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ServerAddress = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (s IoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (s *IoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Time to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1Time(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1WatchEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent = [2]string{
	0: "object",
	1: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1WatchEvent from json.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgApisMetaV1WatchEvent to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgRuntimeRawExtension) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgRuntimeRawExtension = [0]string{}

// Decode decodes IoK8sApimachineryPkgRuntimeRawExtension from json.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgRuntimeRawExtension to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (s IoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (s *IoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgUtilIntstrIntOrString to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgUtilIntstrIntOrString(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgVersionInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"buildDate\"" + ":")
		e.Str(s.BuildDate)
	}
	{
		e.Comma()

		e.RawStr("\"compiler\"" + ":")
		e.Str(s.Compiler)
	}
	{
		e.Comma()

		e.RawStr("\"gitCommit\"" + ":")
		e.Str(s.GitCommit)
	}
	{
		e.Comma()

		e.RawStr("\"gitTreeState\"" + ":")
		e.Str(s.GitTreeState)
	}
	{
		e.Comma()

		e.RawStr("\"gitVersion\"" + ":")
		e.Str(s.GitVersion)
	}
	{
		e.Comma()

		e.RawStr("\"goVersion\"" + ":")
		e.Str(s.GoVersion)
	}
	{
		e.Comma()

		e.RawStr("\"major\"" + ":")
		e.Str(s.Major)
	}
	{
		e.Comma()

		e.RawStr("\"minor\"" + ":")
		e.Str(s.Minor)
	}
	{
		e.Comma()

		e.RawStr("\"platform\"" + ":")
		e.Str(s.Platform)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo = [9]string{
	0: "buildDate",
	1: "compiler",
	2: "gitCommit",
	3: "gitTreeState",
	4: "gitVersion",
	5: "goVersion",
	6: "major",
	7: "minor",
	8: "platform",
}

// Decode decodes IoK8sApimachineryPkgVersionInfo from json.
func (s *IoK8sApimachineryPkgVersionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sApimachineryPkgVersionInfo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "buildDate":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.BuildDate = string(v)
			if err != nil {
				return err
			}
		case "compiler":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Compiler = string(v)
			if err != nil {
				return err
			}
		case "gitCommit":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.GitCommit = string(v)
			if err != nil {
				return err
			}
		case "gitTreeState":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.GitTreeState = string(v)
			if err != nil {
				return err
			}
		case "gitVersion":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.GitVersion = string(v)
			if err != nil {
				return err
			}
		case "goVersion":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.GoVersion = string(v)
			if err != nil {
				return err
			}
		case "major":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.Major = string(v)
			if err != nil {
				return err
			}
		case "minor":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Str()
			s.Minor = string(v)
			if err != nil {
				return err
			}
		case "platform":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Str()
			s.Platform = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Spec.Set {
			e.RawStr("\"spec\"" + ":")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIService = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIService from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIService to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "spec":
			s.Spec.Reset()
			if err := s.Spec.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastTransitionTime.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastTransitionTime.Set {
			e.RawStr("\"lastTransitionTime\"" + ":")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			s.LastTransitionTime.Reset()
			if err := s.LastTransitionTime.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ApiVersion.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ApiVersion.Set {
			e.RawStr("\"apiVersion\"" + ":")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.Comma()
		}
		if s.Kind.Set {
			e.RawStr("\"kind\"" + ":")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			s.ApiVersion.Reset()
			if err := s.ApiVersion.Decode(d); err != nil {
				return err
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		case "kind":
			s.Kind.Reset()
			if err := s.Kind.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"caBundle\"" + ":")
		e.Base64(s.CaBundle)
	}
	{
		if s.Group.Set {
			e.Comma()
		}
		if s.Group.Set {
			e.RawStr("\"group\"" + ":")
			s.Group.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"groupPriorityMinimum\"" + ":")
		e.Int32(s.GroupPriorityMinimum)
	}
	{
		if s.InsecureSkipTLSVerify.Set {
			e.Comma()
		}
		if s.InsecureSkipTLSVerify.Set {
			e.RawStr("\"insecureSkipTLSVerify\"" + ":")
			s.InsecureSkipTLSVerify.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.Comma()
		}
		if s.Service.Set {
			e.RawStr("\"service\"" + ":")
			s.Service.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.Comma()
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"versionPriority\"" + ":")
		e.Int32(s.VersionPriority)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec = [7]string{
	0: "caBundle",
	1: "group",
	2: "groupPriorityMinimum",
	3: "insecureSkipTLSVerify",
	4: "service",
	5: "version",
	6: "versionPriority",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			v, err := d.Base64()
			s.CaBundle = []byte(v)
			if err != nil {
				return err
			}
		case "group":
			s.Group.Reset()
			if err := s.Group.Decode(d); err != nil {
				return err
			}
		case "groupPriorityMinimum":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int32()
			s.GroupPriorityMinimum = int32(v)
			if err != nil {
				return err
			}
		case "insecureSkipTLSVerify":
			s.InsecureSkipTLSVerify.Reset()
			if err := s.InsecureSkipTLSVerify.Decode(d); err != nil {
				return err
			}
		case "service":
			s.Service.Reset()
			if err := s.Service.Decode(d); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		case "versionPriority":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Int32()
			s.VersionPriority = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Conditions != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Conditions != nil {
			e.RawStr("\"conditions\"" + ":")
			e.ArrStart()
			if len(s.Conditions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Conditions[0]
					elem.Encode(e)
				}
				for _, elem := range s.Conditions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Namespace.Set {
			e.RawStr("\"namespace\"" + ":")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Port.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Port.Set {
			e.RawStr("\"port\"" + ":")
			s.Port.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference = [3]string{
	0: "name",
	1: "namespace",
	2: "port",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "namespace":
			s.Namespace.Reset()
			if err := s.Namespace.Decode(d); err != nil {
				return err
			}
		case "port":
			s.Port.Reset()
			if err := s.Port.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes ListAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized from json.
func (s *ListAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes ListAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized from json.
func (s *ListAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListApiextensionsV1CustomResourceDefinitionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListApiextensionsV1CustomResourceDefinitionUnauthorized = [0]string{}

// Decode decodes ListApiextensionsV1CustomResourceDefinitionUnauthorized from json.
func (s *ListApiextensionsV1CustomResourceDefinitionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListApiextensionsV1CustomResourceDefinitionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListApiregistrationV1APIServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListApiregistrationV1APIServiceUnauthorized = [0]string{}

// Decode decodes ListApiregistrationV1APIServiceUnauthorized from json.
func (s *ListApiregistrationV1APIServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListApiregistrationV1APIServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1ControllerRevisionForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1ControllerRevisionForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAppsV1ControllerRevisionForAllNamespacesUnauthorized from json.
func (s *ListAppsV1ControllerRevisionForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1ControllerRevisionForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1DaemonSetForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1DaemonSetForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAppsV1DaemonSetForAllNamespacesUnauthorized from json.
func (s *ListAppsV1DaemonSetForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1DaemonSetForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1DeploymentForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1DeploymentForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAppsV1DeploymentForAllNamespacesUnauthorized from json.
func (s *ListAppsV1DeploymentForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1DeploymentForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1NamespacedControllerRevisionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1NamespacedControllerRevisionUnauthorized = [0]string{}

// Decode decodes ListAppsV1NamespacedControllerRevisionUnauthorized from json.
func (s *ListAppsV1NamespacedControllerRevisionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1NamespacedControllerRevisionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1NamespacedDaemonSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1NamespacedDaemonSetUnauthorized = [0]string{}

// Decode decodes ListAppsV1NamespacedDaemonSetUnauthorized from json.
func (s *ListAppsV1NamespacedDaemonSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1NamespacedDaemonSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1NamespacedDeploymentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1NamespacedDeploymentUnauthorized = [0]string{}

// Decode decodes ListAppsV1NamespacedDeploymentUnauthorized from json.
func (s *ListAppsV1NamespacedDeploymentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1NamespacedDeploymentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1NamespacedReplicaSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1NamespacedReplicaSetUnauthorized = [0]string{}

// Decode decodes ListAppsV1NamespacedReplicaSetUnauthorized from json.
func (s *ListAppsV1NamespacedReplicaSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1NamespacedReplicaSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1NamespacedStatefulSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1NamespacedStatefulSetUnauthorized = [0]string{}

// Decode decodes ListAppsV1NamespacedStatefulSetUnauthorized from json.
func (s *ListAppsV1NamespacedStatefulSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1NamespacedStatefulSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1ReplicaSetForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1ReplicaSetForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAppsV1ReplicaSetForAllNamespacesUnauthorized from json.
func (s *ListAppsV1ReplicaSetForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1ReplicaSetForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAppsV1StatefulSetForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAppsV1StatefulSetForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAppsV1StatefulSetForAllNamespacesUnauthorized from json.
func (s *ListAppsV1StatefulSetForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAppsV1StatefulSetForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesUnauthorized from json.
func (s *ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ListAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesUnauthorized from json.
func (s *ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesUnauthorized from json.
func (s *ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1CronJobForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1CronJobForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListBatchV1CronJobForAllNamespacesUnauthorized from json.
func (s *ListBatchV1CronJobForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1CronJobForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1JobForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1JobForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListBatchV1JobForAllNamespacesUnauthorized from json.
func (s *ListBatchV1JobForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1JobForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes ListBatchV1NamespacedCronJobUnauthorized from json.
func (s *ListBatchV1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1NamespacedJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1NamespacedJobUnauthorized = [0]string{}

// Decode decodes ListBatchV1NamespacedJobUnauthorized from json.
func (s *ListBatchV1NamespacedJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1NamespacedJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1beta1CronJobForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1beta1CronJobForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListBatchV1beta1CronJobForAllNamespacesUnauthorized from json.
func (s *ListBatchV1beta1CronJobForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1beta1CronJobForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListBatchV1beta1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListBatchV1beta1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes ListBatchV1beta1NamespacedCronJobUnauthorized from json.
func (s *ListBatchV1beta1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListBatchV1beta1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCertificatesV1CertificateSigningRequestUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCertificatesV1CertificateSigningRequestUnauthorized = [0]string{}

// Decode decodes ListCertificatesV1CertificateSigningRequestUnauthorized from json.
func (s *ListCertificatesV1CertificateSigningRequestUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCertificatesV1CertificateSigningRequestUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoordinationV1LeaseForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoordinationV1LeaseForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoordinationV1LeaseForAllNamespacesUnauthorized from json.
func (s *ListCoordinationV1LeaseForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoordinationV1LeaseForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoordinationV1NamespacedLeaseUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoordinationV1NamespacedLeaseUnauthorized = [0]string{}

// Decode decodes ListCoordinationV1NamespacedLeaseUnauthorized from json.
func (s *ListCoordinationV1NamespacedLeaseUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoordinationV1NamespacedLeaseUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ComponentStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ComponentStatusUnauthorized = [0]string{}

// Decode decodes ListCoreV1ComponentStatusUnauthorized from json.
func (s *ListCoreV1ComponentStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ComponentStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ConfigMapForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ConfigMapForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1ConfigMapForAllNamespacesUnauthorized from json.
func (s *ListCoreV1ConfigMapForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ConfigMapForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1EndpointsForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1EndpointsForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1EndpointsForAllNamespacesUnauthorized from json.
func (s *ListCoreV1EndpointsForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1EndpointsForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1EventForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1EventForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1EventForAllNamespacesUnauthorized from json.
func (s *ListCoreV1EventForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1EventForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1LimitRangeForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1LimitRangeForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1LimitRangeForAllNamespacesUnauthorized from json.
func (s *ListCoreV1LimitRangeForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1LimitRangeForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespaceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespaceUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespaceUnauthorized from json.
func (s *ListCoreV1NamespaceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespaceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedConfigMapUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedConfigMapUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedConfigMapUnauthorized from json.
func (s *ListCoreV1NamespacedConfigMapUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedConfigMapUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedEndpointsUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedEndpointsUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedEndpointsUnauthorized from json.
func (s *ListCoreV1NamespacedEndpointsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedEndpointsUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedEventUnauthorized from json.
func (s *ListCoreV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedLimitRangeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedLimitRangeUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedLimitRangeUnauthorized from json.
func (s *ListCoreV1NamespacedLimitRangeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedLimitRangeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedPersistentVolumeClaimUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedPersistentVolumeClaimUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedPersistentVolumeClaimUnauthorized from json.
func (s *ListCoreV1NamespacedPersistentVolumeClaimUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedPersistentVolumeClaimUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedPodTemplateUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedPodTemplateUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedPodTemplateUnauthorized from json.
func (s *ListCoreV1NamespacedPodTemplateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedPodTemplateUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedPodUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedPodUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedPodUnauthorized from json.
func (s *ListCoreV1NamespacedPodUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedPodUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedReplicationControllerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedReplicationControllerUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedReplicationControllerUnauthorized from json.
func (s *ListCoreV1NamespacedReplicationControllerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedReplicationControllerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedResourceQuotaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedResourceQuotaUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedResourceQuotaUnauthorized from json.
func (s *ListCoreV1NamespacedResourceQuotaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedResourceQuotaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedSecretUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedSecretUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedSecretUnauthorized from json.
func (s *ListCoreV1NamespacedSecretUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedSecretUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedServiceAccountUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedServiceAccountUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedServiceAccountUnauthorized from json.
func (s *ListCoreV1NamespacedServiceAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedServiceAccountUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NamespacedServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NamespacedServiceUnauthorized = [0]string{}

// Decode decodes ListCoreV1NamespacedServiceUnauthorized from json.
func (s *ListCoreV1NamespacedServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NamespacedServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1NodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1NodeUnauthorized = [0]string{}

// Decode decodes ListCoreV1NodeUnauthorized from json.
func (s *ListCoreV1NodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1NodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1PersistentVolumeClaimForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1PersistentVolumeClaimForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1PersistentVolumeClaimForAllNamespacesUnauthorized from json.
func (s *ListCoreV1PersistentVolumeClaimForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1PersistentVolumeClaimForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1PersistentVolumeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1PersistentVolumeUnauthorized = [0]string{}

// Decode decodes ListCoreV1PersistentVolumeUnauthorized from json.
func (s *ListCoreV1PersistentVolumeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1PersistentVolumeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1PodForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1PodForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1PodForAllNamespacesUnauthorized from json.
func (s *ListCoreV1PodForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1PodForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1PodTemplateForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1PodTemplateForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1PodTemplateForAllNamespacesUnauthorized from json.
func (s *ListCoreV1PodTemplateForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1PodTemplateForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ReplicationControllerForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ReplicationControllerForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1ReplicationControllerForAllNamespacesUnauthorized from json.
func (s *ListCoreV1ReplicationControllerForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ReplicationControllerForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ResourceQuotaForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ResourceQuotaForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1ResourceQuotaForAllNamespacesUnauthorized from json.
func (s *ListCoreV1ResourceQuotaForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ResourceQuotaForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1SecretForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1SecretForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1SecretForAllNamespacesUnauthorized from json.
func (s *ListCoreV1SecretForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1SecretForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ServiceAccountForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ServiceAccountForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1ServiceAccountForAllNamespacesUnauthorized from json.
func (s *ListCoreV1ServiceAccountForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ServiceAccountForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListCoreV1ServiceForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListCoreV1ServiceForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListCoreV1ServiceForAllNamespacesUnauthorized from json.
func (s *ListCoreV1ServiceForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListCoreV1ServiceForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListDiscoveryV1EndpointSliceForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListDiscoveryV1EndpointSliceForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListDiscoveryV1EndpointSliceForAllNamespacesUnauthorized from json.
func (s *ListDiscoveryV1EndpointSliceForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListDiscoveryV1EndpointSliceForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListDiscoveryV1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListDiscoveryV1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes ListDiscoveryV1NamespacedEndpointSliceUnauthorized from json.
func (s *ListDiscoveryV1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListDiscoveryV1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListDiscoveryV1beta1EndpointSliceForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListDiscoveryV1beta1EndpointSliceForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListDiscoveryV1beta1EndpointSliceForAllNamespacesUnauthorized from json.
func (s *ListDiscoveryV1beta1EndpointSliceForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListDiscoveryV1beta1EndpointSliceForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListDiscoveryV1beta1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes ListDiscoveryV1beta1NamespacedEndpointSliceUnauthorized from json.
func (s *ListDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListDiscoveryV1beta1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListEventsV1EventForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListEventsV1EventForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListEventsV1EventForAllNamespacesUnauthorized from json.
func (s *ListEventsV1EventForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListEventsV1EventForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListEventsV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListEventsV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ListEventsV1NamespacedEventUnauthorized from json.
func (s *ListEventsV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListEventsV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListEventsV1beta1EventForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListEventsV1beta1EventForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListEventsV1beta1EventForAllNamespacesUnauthorized from json.
func (s *ListEventsV1beta1EventForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListEventsV1beta1EventForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListEventsV1beta1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListEventsV1beta1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ListEventsV1beta1NamespacedEventUnauthorized from json.
func (s *ListEventsV1beta1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListEventsV1beta1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListFlowcontrolApiserverV1beta1FlowSchemaUnauthorized = [0]string{}

// Decode decodes ListFlowcontrolApiserverV1beta1FlowSchemaUnauthorized from json.
func (s *ListFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListFlowcontrolApiserverV1beta1FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized from json.
func (s *ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListFlowcontrolApiserverV1beta2FlowSchemaUnauthorized = [0]string{}

// Decode decodes ListFlowcontrolApiserverV1beta2FlowSchemaUnauthorized from json.
func (s *ListFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListFlowcontrolApiserverV1beta2FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized from json.
func (s *ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListInternalApiserverV1alpha1StorageVersionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListInternalApiserverV1alpha1StorageVersionUnauthorized = [0]string{}

// Decode decodes ListInternalApiserverV1alpha1StorageVersionUnauthorized from json.
func (s *ListInternalApiserverV1alpha1StorageVersionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListInternalApiserverV1alpha1StorageVersionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNetworkingV1IngressClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNetworkingV1IngressClassUnauthorized = [0]string{}

// Decode decodes ListNetworkingV1IngressClassUnauthorized from json.
func (s *ListNetworkingV1IngressClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNetworkingV1IngressClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNetworkingV1IngressForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNetworkingV1IngressForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListNetworkingV1IngressForAllNamespacesUnauthorized from json.
func (s *ListNetworkingV1IngressForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNetworkingV1IngressForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNetworkingV1NamespacedIngressUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNetworkingV1NamespacedIngressUnauthorized = [0]string{}

// Decode decodes ListNetworkingV1NamespacedIngressUnauthorized from json.
func (s *ListNetworkingV1NamespacedIngressUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNetworkingV1NamespacedIngressUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNetworkingV1NamespacedNetworkPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNetworkingV1NamespacedNetworkPolicyUnauthorized = [0]string{}

// Decode decodes ListNetworkingV1NamespacedNetworkPolicyUnauthorized from json.
func (s *ListNetworkingV1NamespacedNetworkPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNetworkingV1NamespacedNetworkPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNetworkingV1NetworkPolicyForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNetworkingV1NetworkPolicyForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListNetworkingV1NetworkPolicyForAllNamespacesUnauthorized from json.
func (s *ListNetworkingV1NetworkPolicyForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNetworkingV1NetworkPolicyForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNodeV1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNodeV1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ListNodeV1RuntimeClassUnauthorized from json.
func (s *ListNodeV1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNodeV1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNodeV1alpha1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNodeV1alpha1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ListNodeV1alpha1RuntimeClassUnauthorized from json.
func (s *ListNodeV1alpha1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNodeV1alpha1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListNodeV1beta1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListNodeV1beta1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ListNodeV1beta1RuntimeClassUnauthorized from json.
func (s *ListNodeV1beta1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListNodeV1beta1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListPolicyV1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes ListPolicyV1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *ListPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPolicyV1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListPolicyV1PodDisruptionBudgetForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListPolicyV1PodDisruptionBudgetForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListPolicyV1PodDisruptionBudgetForAllNamespacesUnauthorized from json.
func (s *ListPolicyV1PodDisruptionBudgetForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPolicyV1PodDisruptionBudgetForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes ListPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *ListPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListPolicyV1beta1PodDisruptionBudgetForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesUnauthorized from json.
func (s *ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListPolicyV1beta1PodSecurityPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListPolicyV1beta1PodSecurityPolicyUnauthorized = [0]string{}

// Decode decodes ListPolicyV1beta1PodSecurityPolicyUnauthorized from json.
func (s *ListPolicyV1beta1PodSecurityPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListPolicyV1beta1PodSecurityPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1ClusterRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1ClusterRoleBindingUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1ClusterRoleBindingUnauthorized from json.
func (s *ListRbacAuthorizationV1ClusterRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1ClusterRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1ClusterRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1ClusterRoleUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1ClusterRoleUnauthorized from json.
func (s *ListRbacAuthorizationV1ClusterRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1ClusterRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1NamespacedRoleBindingUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1NamespacedRoleBindingUnauthorized from json.
func (s *ListRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1NamespacedRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1NamespacedRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1NamespacedRoleUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1NamespacedRoleUnauthorized from json.
func (s *ListRbacAuthorizationV1NamespacedRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1NamespacedRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1RoleBindingForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1RoleBindingForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1RoleBindingForAllNamespacesUnauthorized from json.
func (s *ListRbacAuthorizationV1RoleBindingForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1RoleBindingForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListRbacAuthorizationV1RoleForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListRbacAuthorizationV1RoleForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListRbacAuthorizationV1RoleForAllNamespacesUnauthorized from json.
func (s *ListRbacAuthorizationV1RoleForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListRbacAuthorizationV1RoleForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListSchedulingV1PriorityClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListSchedulingV1PriorityClassUnauthorized = [0]string{}

// Decode decodes ListSchedulingV1PriorityClassUnauthorized from json.
func (s *ListSchedulingV1PriorityClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListSchedulingV1PriorityClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1CSIDriverUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1CSIDriverUnauthorized = [0]string{}

// Decode decodes ListStorageV1CSIDriverUnauthorized from json.
func (s *ListStorageV1CSIDriverUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1CSIDriverUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1CSINodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1CSINodeUnauthorized = [0]string{}

// Decode decodes ListStorageV1CSINodeUnauthorized from json.
func (s *ListStorageV1CSINodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1CSINodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1StorageClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1StorageClassUnauthorized = [0]string{}

// Decode decodes ListStorageV1StorageClassUnauthorized from json.
func (s *ListStorageV1StorageClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1StorageClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1VolumeAttachmentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1VolumeAttachmentUnauthorized = [0]string{}

// Decode decodes ListStorageV1VolumeAttachmentUnauthorized from json.
func (s *ListStorageV1VolumeAttachmentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1VolumeAttachmentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1alpha1CSIStorageCapacityForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1alpha1CSIStorageCapacityForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListStorageV1alpha1CSIStorageCapacityForAllNamespacesUnauthorized from json.
func (s *ListStorageV1alpha1CSIStorageCapacityForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1alpha1CSIStorageCapacityForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes ListStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *ListStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1beta1CSIStorageCapacityForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1beta1CSIStorageCapacityForAllNamespacesUnauthorized = [0]string{}

// Decode decodes ListStorageV1beta1CSIStorageCapacityForAllNamespacesUnauthorized from json.
func (s *ListStorageV1beta1CSIStorageCapacityForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1beta1CSIStorageCapacityForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ListStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfListStorageV1beta1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes ListStorageV1beta1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *ListStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ListStorageV1beta1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LogFileHandlerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfLogFileHandlerUnauthorized = [0]string{}

// Decode decodes LogFileHandlerUnauthorized from json.
func (s *LogFileHandlerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LogFileHandlerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LogFileListHandlerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfLogFileListHandlerUnauthorized = [0]string{}

// Decode decodes LogFileListHandlerUnauthorized from json.
func (s *LogFileListHandlerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LogFileListHandlerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBool`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt32 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int32()
		if err != nil {
			return err
		}
		o.Value = int32(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt32`, d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt64`, d.Next())
	}
}

// Encode encodes IoK8sAPIAdmissionregistrationV1ServiceReference as json.
func (o OptIoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (o *OptIoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAdmissionregistrationV1ServiceReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAdmissionregistrationV1ServiceReference`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetSpec as json.
func (o OptIoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (o *OptIoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetStatus as json.
func (o OptIoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (o *OptIoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DaemonSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetUpdateStrategy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DaemonSetUpdateStrategy`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentSpec as json.
func (o OptIoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (o *OptIoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DeploymentSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentStatus as json.
func (o OptIoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (o *OptIoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1DeploymentStrategy as json.
func (o OptIoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (o *OptIoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStrategy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1DeploymentStrategy`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetSpec as json.
func (o OptIoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1ReplicaSetSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetStatus as json.
func (o OptIoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1ReplicaSetStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDaemonSet as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDaemonSet to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateDaemonSet`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDeployment as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDeployment to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateDeployment`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy as json.
func (o OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetSpec as json.
func (o OptIoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (o *OptIoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetStatus as json.
func (o OptIoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (o *OptIoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAppsV1StatefulSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetUpdateStrategy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAppsV1StatefulSetUpdateStrategy`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleSpec as json.
func (o OptIoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV1ScaleSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleStatus as json.
func (o OptIoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV1ScaleStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1PodsMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HPAScalingRules as json.
func (o OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HPAScalingRules to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HPAScalingRules`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2PodsMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource`, d.Next())
	}
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1CronJobSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1CronJobSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1CronJobStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1CronJobStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1JobSpec as json.
func (o OptIoK8sAPIBatchV1JobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (o *OptIoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1JobSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1JobSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1JobStatus as json.
func (o OptIoK8sAPIBatchV1JobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (o *OptIoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1JobStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1JobStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1UncountedTerminatedPods as json.
func (o OptIoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (o *OptIoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1UncountedTerminatedPods to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1UncountedTerminatedPods`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1beta1CronJobSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIBatchV1beta1CronJobStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra`, d.Next())
	}
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestStatus as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICertificatesV1CertificateSigningRequestStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoordinationV1LeaseSpec as json.
func (o OptIoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (o *OptIoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoordinationV1LeaseSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoordinationV1LeaseSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource as json.
func (o OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (o *OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Affinity as json.
func (o OptIoK8sAPICoreV1Affinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (o *OptIoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1Affinity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1Affinity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1AzureDiskVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1AzureDiskVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureFilePersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1AzureFilePersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1AzureFilePersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1AzureFileVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1AzureFileVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1AzureFileVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CSIPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CSIVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Capabilities as json.
func (o OptIoK8sAPICoreV1Capabilities) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (o *OptIoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1Capabilities to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1Capabilities`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CephFSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CephFSPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CephFSPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CephFSVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CephFSVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CephFSVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CinderPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CinderPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CinderPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1CinderVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1CinderVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1CinderVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ClientIPConfig as json.
func (o OptIoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (o *OptIoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ClientIPConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ClientIPConfig`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapBinaryData as json.
func (o OptIoK8sAPICoreV1ConfigMapBinaryData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapBinaryData from json.
func (o *OptIoK8sAPICoreV1ConfigMapBinaryData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapBinaryData to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapBinaryData`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapData as json.
func (o OptIoK8sAPICoreV1ConfigMapData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapData from json.
func (o *OptIoK8sAPICoreV1ConfigMapData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapData to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapData`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapEnvSource as json.
func (o OptIoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapEnvSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapEnvSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapKeySelector as json.
func (o OptIoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (o *OptIoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapKeySelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapKeySelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapNodeConfigSource as json.
func (o OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapNodeConfigSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapNodeConfigSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapProjection as json.
func (o OptIoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (o *OptIoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapProjection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapProjection`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ConfigMapVolumeSource as json.
func (o OptIoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ConfigMapVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ConfigMapVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerState as json.
func (o OptIoK8sAPICoreV1ContainerState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (o *OptIoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ContainerState to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ContainerState`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateRunning as json.
func (o OptIoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (o *OptIoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ContainerStateRunning to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateRunning`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateTerminated as json.
func (o OptIoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (o *OptIoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ContainerStateTerminated to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateTerminated`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ContainerStateWaiting as json.
func (o OptIoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (o *OptIoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ContainerStateWaiting to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ContainerStateWaiting`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DaemonEndpoint as json.
func (o OptIoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (o *OptIoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1DaemonEndpoint to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1DaemonEndpoint`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DownwardAPIProjection as json.
func (o OptIoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (o *OptIoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIProjection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1DownwardAPIProjection`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1DownwardAPIVolumeSource as json.
func (o OptIoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (o *OptIoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1DownwardAPIVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EmptyDirVolumeSource as json.
func (o OptIoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (o *OptIoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1EmptyDirVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1EmptyDirVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EnvVarSource as json.
func (o OptIoK8sAPICoreV1EnvVarSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (o *OptIoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1EnvVarSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1EnvVarSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EphemeralVolumeSource as json.
func (o OptIoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (o *OptIoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1EphemeralVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1EphemeralVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EventSeries as json.
func (o OptIoK8sAPICoreV1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (o *OptIoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1EventSeries to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1EventSeries`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1EventSource as json.
func (o OptIoK8sAPICoreV1EventSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (o *OptIoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1EventSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1EventSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ExecAction as json.
func (o OptIoK8sAPICoreV1ExecAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (o *OptIoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ExecAction to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ExecAction`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FCVolumeSource as json.
func (o OptIoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (o *OptIoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FCVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FCVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FlexPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FlexVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexVolumeSourceOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSourceOptions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FlexVolumeSourceOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1FlockerVolumeSource as json.
func (o OptIoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1FlockerVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1FlockerVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GitRepoVolumeSource as json.
func (o OptIoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (o *OptIoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1GitRepoVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1GitRepoVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1GlusterfsVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1GlusterfsVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1GlusterfsVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1HTTPGetAction as json.
func (o OptIoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (o *OptIoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1HTTPGetAction to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1HTTPGetAction`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Handler as json.
func (o OptIoK8sAPICoreV1Handler) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (o *OptIoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1Handler to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1Handler`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1HostPathVolumeSource as json.
func (o OptIoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (o *OptIoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1HostPathVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1HostPathVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ISCSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ISCSIPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ISCSIPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ISCSIVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ISCSIVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ISCSIVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Lifecycle as json.
func (o OptIoK8sAPICoreV1Lifecycle) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (o *OptIoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1Lifecycle to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1Lifecycle`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefault as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefault) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefault from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefault) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefault to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemDefault`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefaultRequest as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefaultRequest from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefaultRequest to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemDefaultRequest`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMax as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMax) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMax from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMax) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMax to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMax`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMin as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMin) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMin from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMin to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeItemMin`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LimitRangeSpec as json.
func (o OptIoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (o *OptIoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LimitRangeSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LimitRangeSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LoadBalancerStatus as json.
func (o OptIoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (o *OptIoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LoadBalancerStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LoadBalancerStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LocalObjectReference as json.
func (o OptIoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (o *OptIoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LocalObjectReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LocalObjectReference`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1LocalVolumeSource as json.
func (o OptIoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (o *OptIoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1LocalVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1LocalVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NFSVolumeSource as json.
func (o OptIoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NFSVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NFSVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NamespaceSpec as json.
func (o OptIoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (o *OptIoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NamespaceSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NamespaceSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NamespaceStatus as json.
func (o OptIoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (o *OptIoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NamespaceStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NamespaceStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeAffinity as json.
func (o OptIoK8sAPICoreV1NodeAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (o *OptIoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeAffinity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeAffinity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeConfigSource as json.
func (o OptIoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (o *OptIoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeConfigSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeConfigSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeConfigStatus as json.
func (o OptIoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (o *OptIoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeConfigStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeConfigStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeDaemonEndpoints as json.
func (o OptIoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (o *OptIoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeDaemonEndpoints to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeDaemonEndpoints`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSelector as json.
func (o OptIoK8sAPICoreV1NodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (o *OptIoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeSelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSpec as json.
func (o OptIoK8sAPICoreV1NodeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (o *OptIoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatus as json.
func (o OptIoK8sAPICoreV1NodeStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (o *OptIoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatusAllocatable as json.
func (o OptIoK8sAPICoreV1NodeStatusAllocatable) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusAllocatable from json.
func (o *OptIoK8sAPICoreV1NodeStatusAllocatable) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeStatusAllocatable to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeStatusAllocatable`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeStatusCapacity as json.
func (o OptIoK8sAPICoreV1NodeStatusCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusCapacity from json.
func (o *OptIoK8sAPICoreV1NodeStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeStatusCapacity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeStatusCapacity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1NodeSystemInfo as json.
func (o OptIoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (o *OptIoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1NodeSystemInfo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1NodeSystemInfo`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ObjectFieldSelector as json.
func (o OptIoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (o *OptIoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ObjectFieldSelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ObjectFieldSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ObjectReference as json.
func (o OptIoK8sAPICoreV1ObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (o *OptIoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ObjectReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ObjectReference`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimTemplate as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimTemplate to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimTemplate`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpecCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpecCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpecCapacity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeSpecCapacity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PersistentVolumeStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodAffinity as json.
func (o OptIoK8sAPICoreV1PodAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (o *OptIoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodAffinity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodAffinity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodAntiAffinity as json.
func (o OptIoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (o *OptIoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodAntiAffinity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodAntiAffinity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodDNSConfig as json.
func (o OptIoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (o *OptIoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodDNSConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodDNSConfig`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSecurityContext as json.
func (o OptIoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (o *OptIoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodSecurityContext to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodSecurityContext`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpec as json.
func (o OptIoK8sAPICoreV1PodSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (o *OptIoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpecNodeSelector as json.
func (o OptIoK8sAPICoreV1PodSpecNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecNodeSelector from json.
func (o *OptIoK8sAPICoreV1PodSpecNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodSpecNodeSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodSpecNodeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodSpecOverhead as json.
func (o OptIoK8sAPICoreV1PodSpecOverhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecOverhead from json.
func (o *OptIoK8sAPICoreV1PodSpecOverhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodSpecOverhead to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodSpecOverhead`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodStatus as json.
func (o OptIoK8sAPICoreV1PodStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (o *OptIoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PodTemplateSpec as json.
func (o OptIoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (o *OptIoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PodTemplateSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PodTemplateSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1PortworxVolumeSource as json.
func (o OptIoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (o *OptIoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1PortworxVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1PortworxVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1Probe as json.
func (o OptIoK8sAPICoreV1Probe) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (o *OptIoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1Probe to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1Probe`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ProjectedVolumeSource as json.
func (o OptIoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (o *OptIoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ProjectedVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ProjectedVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1QuobyteVolumeSource as json.
func (o OptIoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (o *OptIoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1QuobyteVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1QuobyteVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1RBDPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1RBDPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1RBDPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1RBDVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1RBDVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1RBDVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpec as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpecSelector as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpecSelector from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpecSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerSpecSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerStatus as json.
func (o OptIoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ReplicationControllerStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceFieldSelector as json.
func (o OptIoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (o *OptIoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceFieldSelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceFieldSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpec as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpecHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpecHard) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpecHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpecHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpecHard to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaSpecHard`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatus as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusHard) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusHard to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatusHard`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusUsed as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusUsed from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusUsed to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceQuotaStatusUsed`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirements as json.
func (o OptIoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (o *OptIoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirements to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirements`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsLimits as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsLimits) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsLimits from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsLimits to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirementsLimits`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsRequests as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsRequests) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsRequests from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsRequests to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ResourceRequirementsRequests`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SELinuxOptions as json.
func (o OptIoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (o *OptIoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SELinuxOptions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SELinuxOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScaleIOVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ScaleIOVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ScaleIOVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ScopeSelector as json.
func (o OptIoK8sAPICoreV1ScopeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (o *OptIoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ScopeSelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ScopeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SeccompProfile as json.
func (o OptIoK8sAPICoreV1SeccompProfile) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (o *OptIoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SeccompProfile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SeccompProfile`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretData as json.
func (o OptIoK8sAPICoreV1SecretData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretData from json.
func (o *OptIoK8sAPICoreV1SecretData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretData to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretData`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretEnvSource as json.
func (o OptIoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (o *OptIoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretEnvSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretEnvSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretKeySelector as json.
func (o OptIoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (o *OptIoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretKeySelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretKeySelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretProjection as json.
func (o OptIoK8sAPICoreV1SecretProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (o *OptIoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretProjection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretProjection`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretReference as json.
func (o OptIoK8sAPICoreV1SecretReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (o *OptIoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretReference`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretStringData as json.
func (o OptIoK8sAPICoreV1SecretStringData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretStringData from json.
func (o *OptIoK8sAPICoreV1SecretStringData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretStringData to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretStringData`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecretVolumeSource as json.
func (o OptIoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (o *OptIoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecretVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecretVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SecurityContext as json.
func (o OptIoK8sAPICoreV1SecurityContext) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (o *OptIoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SecurityContext to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SecurityContext`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceAccountTokenProjection as json.
func (o OptIoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (o *OptIoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ServiceAccountTokenProjection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ServiceAccountTokenProjection`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceSpec as json.
func (o OptIoK8sAPICoreV1ServiceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (o *OptIoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ServiceSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ServiceSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceSpecSelector as json.
func (o OptIoK8sAPICoreV1ServiceSpecSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpecSelector from json.
func (o *OptIoK8sAPICoreV1ServiceSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ServiceSpecSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ServiceSpecSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1ServiceStatus as json.
func (o OptIoK8sAPICoreV1ServiceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (o *OptIoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1ServiceStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1ServiceStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1SessionAffinityConfig as json.
func (o OptIoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (o *OptIoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1SessionAffinityConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1SessionAffinityConfig`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1StorageOSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1StorageOSPersistentVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1StorageOSPersistentVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1StorageOSVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1StorageOSVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1StorageOSVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1TCPSocketAction as json.
func (o OptIoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (o *OptIoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1TCPSocketAction to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1TCPSocketAction`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1TypedLocalObjectReference as json.
func (o OptIoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (o *OptIoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1TypedLocalObjectReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1TypedLocalObjectReference`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1VolumeNodeAffinity as json.
func (o OptIoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (o *OptIoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1VolumeNodeAffinity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1VolumeNodeAffinity`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource`, d.Next())
	}
}

// Encode encodes IoK8sAPICoreV1WindowsSecurityContextOptions as json.
func (o OptIoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (o *OptIoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPICoreV1WindowsSecurityContextOptions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPICoreV1WindowsSecurityContextOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointConditions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointConditions`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology as json.
func (o OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointHints to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1EndpointHints`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointConditions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointConditions`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointHints to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointHints`, d.Next())
	}
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointTopology as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointTopology from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointTopology to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIDiscoveryV1beta1EndpointTopology`, d.Next())
	}
}

// Encode encodes IoK8sAPIEventsV1EventSeries as json.
func (o OptIoK8sAPIEventsV1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (o *OptIoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIEventsV1EventSeries to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIEventsV1EventSeries`, d.Next())
	}
}

// Encode encodes IoK8sAPIEventsV1beta1EventSeries as json.
func (o OptIoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (o *OptIoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIEventsV1beta1EventSeries to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIEventsV1beta1EventSeries`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1GroupSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1GroupSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitResponse to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1LimitResponse`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1UserSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta1UserSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2GroupSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2GroupSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitResponse to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2LimitResponse`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2UserSubject to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIFlowcontrolV1beta2UserSubject`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1HTTPIngressRuleValue as json.
func (o OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (o *OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1HTTPIngressRuleValue to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1HTTPIngressRuleValue`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IPBlock as json.
func (o OptIoK8sAPINetworkingV1IPBlock) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (o *OptIoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IPBlock to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IPBlock`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressBackend as json.
func (o OptIoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressBackend to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressBackend`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressClassParametersReference as json.
func (o OptIoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (o *OptIoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassParametersReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressClassParametersReference`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressClassSpec as json.
func (o OptIoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressClassSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressServiceBackend as json.
func (o OptIoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressServiceBackend to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressServiceBackend`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressSpec as json.
func (o OptIoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1IngressStatus as json.
func (o OptIoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (o *OptIoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1IngressStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1IngressStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1NetworkPolicySpec as json.
func (o OptIoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (o *OptIoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1NetworkPolicySpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1NetworkPolicySpec`, d.Next())
	}
}

// Encode encodes IoK8sAPINetworkingV1ServiceBackendPort as json.
func (o OptIoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (o *OptIoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINetworkingV1ServiceBackendPort to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINetworkingV1ServiceBackendPort`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1Overhead as json.
func (o OptIoK8sAPINodeV1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (o *OptIoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1Overhead to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1Overhead`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1OverheadPodFixed to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1OverheadPodFixed`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1Scheduling as json.
func (o OptIoK8sAPINodeV1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (o *OptIoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1Scheduling to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1Scheduling`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1SchedulingNodeSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1SchedulingNodeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1Overhead as json.
func (o OptIoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (o *OptIoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1alpha1Overhead to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1alpha1Overhead`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1alpha1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1alpha1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1alpha1OverheadPodFixed to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1alpha1OverheadPodFixed`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1Scheduling as json.
func (o OptIoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (o *OptIoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1alpha1Scheduling to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1alpha1Scheduling`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1alpha1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1alpha1SchedulingNodeSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1alpha1SchedulingNodeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1Overhead as json.
func (o OptIoK8sAPINodeV1beta1Overhead) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (o *OptIoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1beta1Overhead to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1beta1Overhead`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1beta1OverheadPodFixed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1beta1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1beta1OverheadPodFixed to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1beta1OverheadPodFixed`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1Scheduling as json.
func (o OptIoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (o *OptIoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1beta1Scheduling to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1beta1Scheduling`, d.Next())
	}
}

// Encode encodes IoK8sAPINodeV1beta1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPINodeV1beta1SchedulingNodeSelector to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPINodeV1beta1SchedulingNodeSelector`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions`, d.Next())
	}
}

// Encode encodes IoK8sAPIRbacV1AggregationRule as json.
func (o OptIoK8sAPIRbacV1AggregationRule) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (o *OptIoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIRbacV1AggregationRule to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIRbacV1AggregationRule`, d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1StorageClassParameters as json.
func (o OptIoK8sAPIStorageV1StorageClassParameters) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1StorageClassParameters from json.
func (o *OptIoK8sAPIStorageV1StorageClassParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIStorageV1StorageClassParameters to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIStorageV1StorageClassParameters`, d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatus as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIStorageV1VolumeAttachmentStatus`, d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata`, d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeError as json.
func (o OptIoK8sAPIStorageV1VolumeError) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (o *OptIoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIStorageV1VolumeError to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIStorageV1VolumeError`, d.Next())
	}
}

// Encode encodes IoK8sAPIStorageV1VolumeNodeResources as json.
func (o OptIoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (o *OptIoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sAPIStorageV1VolumeNodeResources to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sAPIStorageV1VolumeNodeResources`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig`, d.Next())
	}
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (o OptIoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (o *OptIoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgAPIResourceQuantity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgAPIResourceQuantity`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery as json.
func (o OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelector as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelector to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1LabelSelector`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ListMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ListMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ListMeta`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (o OptIoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1MicroTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1MicroTime`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMeta`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (o OptIoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1Time to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgApisMetaV1Time`, d.Next())
	}
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (o OptIoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (o *OptIoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sApimachineryPkgUtilIntstrIntOrString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sApimachineryPkgUtilIntstrIntOrString`, d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec`, d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus`, d.Next())
	}
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s ReadAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes ReadAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized from json.
func (s *ReadAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes ReadAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized from json.
func (s *ReadAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadApiextensionsV1CustomResourceDefinitionStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadApiextensionsV1CustomResourceDefinitionStatusUnauthorized = [0]string{}

// Decode decodes ReadApiextensionsV1CustomResourceDefinitionStatusUnauthorized from json.
func (s *ReadApiextensionsV1CustomResourceDefinitionStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadApiextensionsV1CustomResourceDefinitionStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadApiextensionsV1CustomResourceDefinitionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadApiextensionsV1CustomResourceDefinitionUnauthorized = [0]string{}

// Decode decodes ReadApiextensionsV1CustomResourceDefinitionUnauthorized from json.
func (s *ReadApiextensionsV1CustomResourceDefinitionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadApiextensionsV1CustomResourceDefinitionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadApiregistrationV1APIServiceStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadApiregistrationV1APIServiceStatusUnauthorized = [0]string{}

// Decode decodes ReadApiregistrationV1APIServiceStatusUnauthorized from json.
func (s *ReadApiregistrationV1APIServiceStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadApiregistrationV1APIServiceStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadApiregistrationV1APIServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadApiregistrationV1APIServiceUnauthorized = [0]string{}

// Decode decodes ReadApiregistrationV1APIServiceUnauthorized from json.
func (s *ReadApiregistrationV1APIServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadApiregistrationV1APIServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedControllerRevisionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedControllerRevisionUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedControllerRevisionUnauthorized from json.
func (s *ReadAppsV1NamespacedControllerRevisionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedControllerRevisionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedDaemonSetStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedDaemonSetStatusUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedDaemonSetStatusUnauthorized from json.
func (s *ReadAppsV1NamespacedDaemonSetStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedDaemonSetStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedDaemonSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedDaemonSetUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedDaemonSetUnauthorized from json.
func (s *ReadAppsV1NamespacedDaemonSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedDaemonSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedDeploymentScaleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedDeploymentScaleUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedDeploymentScaleUnauthorized from json.
func (s *ReadAppsV1NamespacedDeploymentScaleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedDeploymentScaleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedDeploymentStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedDeploymentStatusUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedDeploymentStatusUnauthorized from json.
func (s *ReadAppsV1NamespacedDeploymentStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedDeploymentStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedDeploymentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedDeploymentUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedDeploymentUnauthorized from json.
func (s *ReadAppsV1NamespacedDeploymentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedDeploymentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedReplicaSetScaleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedReplicaSetScaleUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedReplicaSetScaleUnauthorized from json.
func (s *ReadAppsV1NamespacedReplicaSetScaleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedReplicaSetScaleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedReplicaSetStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedReplicaSetStatusUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedReplicaSetStatusUnauthorized from json.
func (s *ReadAppsV1NamespacedReplicaSetStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedReplicaSetStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedReplicaSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedReplicaSetUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedReplicaSetUnauthorized from json.
func (s *ReadAppsV1NamespacedReplicaSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedReplicaSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedStatefulSetScaleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedStatefulSetScaleUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedStatefulSetScaleUnauthorized from json.
func (s *ReadAppsV1NamespacedStatefulSetScaleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedStatefulSetScaleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedStatefulSetStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedStatefulSetStatusUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedStatefulSetStatusUnauthorized from json.
func (s *ReadAppsV1NamespacedStatefulSetStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedStatefulSetStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAppsV1NamespacedStatefulSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAppsV1NamespacedStatefulSetUnauthorized = [0]string{}

// Decode decodes ReadAppsV1NamespacedStatefulSetUnauthorized from json.
func (s *ReadAppsV1NamespacedStatefulSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAppsV1NamespacedStatefulSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusUnauthorized from json.
func (s *ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ReadAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusUnauthorized from json.
func (s *ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusUnauthorized from json.
func (s *ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1NamespacedCronJobStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1NamespacedCronJobStatusUnauthorized = [0]string{}

// Decode decodes ReadBatchV1NamespacedCronJobStatusUnauthorized from json.
func (s *ReadBatchV1NamespacedCronJobStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1NamespacedCronJobStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes ReadBatchV1NamespacedCronJobUnauthorized from json.
func (s *ReadBatchV1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1NamespacedJobStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1NamespacedJobStatusUnauthorized = [0]string{}

// Decode decodes ReadBatchV1NamespacedJobStatusUnauthorized from json.
func (s *ReadBatchV1NamespacedJobStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1NamespacedJobStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1NamespacedJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1NamespacedJobUnauthorized = [0]string{}

// Decode decodes ReadBatchV1NamespacedJobUnauthorized from json.
func (s *ReadBatchV1NamespacedJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1NamespacedJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1beta1NamespacedCronJobStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1beta1NamespacedCronJobStatusUnauthorized = [0]string{}

// Decode decodes ReadBatchV1beta1NamespacedCronJobStatusUnauthorized from json.
func (s *ReadBatchV1beta1NamespacedCronJobStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1beta1NamespacedCronJobStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadBatchV1beta1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadBatchV1beta1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes ReadBatchV1beta1NamespacedCronJobUnauthorized from json.
func (s *ReadBatchV1beta1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadBatchV1beta1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCertificatesV1CertificateSigningRequestApprovalUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCertificatesV1CertificateSigningRequestApprovalUnauthorized = [0]string{}

// Decode decodes ReadCertificatesV1CertificateSigningRequestApprovalUnauthorized from json.
func (s *ReadCertificatesV1CertificateSigningRequestApprovalUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCertificatesV1CertificateSigningRequestApprovalUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCertificatesV1CertificateSigningRequestStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCertificatesV1CertificateSigningRequestStatusUnauthorized = [0]string{}

// Decode decodes ReadCertificatesV1CertificateSigningRequestStatusUnauthorized from json.
func (s *ReadCertificatesV1CertificateSigningRequestStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCertificatesV1CertificateSigningRequestStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCertificatesV1CertificateSigningRequestUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCertificatesV1CertificateSigningRequestUnauthorized = [0]string{}

// Decode decodes ReadCertificatesV1CertificateSigningRequestUnauthorized from json.
func (s *ReadCertificatesV1CertificateSigningRequestUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCertificatesV1CertificateSigningRequestUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoordinationV1NamespacedLeaseUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoordinationV1NamespacedLeaseUnauthorized = [0]string{}

// Decode decodes ReadCoordinationV1NamespacedLeaseUnauthorized from json.
func (s *ReadCoordinationV1NamespacedLeaseUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoordinationV1NamespacedLeaseUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1ComponentStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1ComponentStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1ComponentStatusUnauthorized from json.
func (s *ReadCoreV1ComponentStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1ComponentStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespaceStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespaceStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespaceStatusUnauthorized from json.
func (s *ReadCoreV1NamespaceStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespaceStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespaceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespaceUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespaceUnauthorized from json.
func (s *ReadCoreV1NamespaceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespaceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedConfigMapUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedConfigMapUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedConfigMapUnauthorized from json.
func (s *ReadCoreV1NamespacedConfigMapUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedConfigMapUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedEndpointsUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedEndpointsUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedEndpointsUnauthorized from json.
func (s *ReadCoreV1NamespacedEndpointsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedEndpointsUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedEventUnauthorized from json.
func (s *ReadCoreV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedLimitRangeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedLimitRangeUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedLimitRangeUnauthorized from json.
func (s *ReadCoreV1NamespacedLimitRangeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedLimitRangeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPersistentVolumeClaimStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPersistentVolumeClaimStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPersistentVolumeClaimStatusUnauthorized from json.
func (s *ReadCoreV1NamespacedPersistentVolumeClaimStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPersistentVolumeClaimStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPersistentVolumeClaimUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPersistentVolumeClaimUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPersistentVolumeClaimUnauthorized from json.
func (s *ReadCoreV1NamespacedPersistentVolumeClaimUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPersistentVolumeClaimUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPodEphemeralcontainersUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPodEphemeralcontainersUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPodEphemeralcontainersUnauthorized from json.
func (s *ReadCoreV1NamespacedPodEphemeralcontainersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodEphemeralcontainersUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode encodes ReadCoreV1NamespacedPodLogOKApplicationJSON as json.
func (s ReadCoreV1NamespacedPodLogOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes ReadCoreV1NamespacedPodLogOKApplicationJSON from json.
func (s *ReadCoreV1NamespacedPodLogOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodLogOKApplicationJSON to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadCoreV1NamespacedPodLogOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPodLogUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPodLogUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPodLogUnauthorized from json.
func (s *ReadCoreV1NamespacedPodLogUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodLogUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPodStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPodStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPodStatusUnauthorized from json.
func (s *ReadCoreV1NamespacedPodStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPodTemplateUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPodTemplateUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPodTemplateUnauthorized from json.
func (s *ReadCoreV1NamespacedPodTemplateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodTemplateUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedPodUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedPodUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedPodUnauthorized from json.
func (s *ReadCoreV1NamespacedPodUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedPodUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedReplicationControllerScaleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedReplicationControllerScaleUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedReplicationControllerScaleUnauthorized from json.
func (s *ReadCoreV1NamespacedReplicationControllerScaleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedReplicationControllerScaleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedReplicationControllerStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedReplicationControllerStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedReplicationControllerStatusUnauthorized from json.
func (s *ReadCoreV1NamespacedReplicationControllerStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedReplicationControllerStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedReplicationControllerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedReplicationControllerUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedReplicationControllerUnauthorized from json.
func (s *ReadCoreV1NamespacedReplicationControllerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedReplicationControllerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedResourceQuotaStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedResourceQuotaStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedResourceQuotaStatusUnauthorized from json.
func (s *ReadCoreV1NamespacedResourceQuotaStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedResourceQuotaStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedResourceQuotaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedResourceQuotaUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedResourceQuotaUnauthorized from json.
func (s *ReadCoreV1NamespacedResourceQuotaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedResourceQuotaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedSecretUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedSecretUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedSecretUnauthorized from json.
func (s *ReadCoreV1NamespacedSecretUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedSecretUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedServiceAccountUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedServiceAccountUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedServiceAccountUnauthorized from json.
func (s *ReadCoreV1NamespacedServiceAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedServiceAccountUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedServiceStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedServiceStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedServiceStatusUnauthorized from json.
func (s *ReadCoreV1NamespacedServiceStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedServiceStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NamespacedServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NamespacedServiceUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NamespacedServiceUnauthorized from json.
func (s *ReadCoreV1NamespacedServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NamespacedServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NodeStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NodeStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NodeStatusUnauthorized from json.
func (s *ReadCoreV1NodeStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NodeStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1NodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1NodeUnauthorized = [0]string{}

// Decode decodes ReadCoreV1NodeUnauthorized from json.
func (s *ReadCoreV1NodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1NodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1PersistentVolumeStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1PersistentVolumeStatusUnauthorized = [0]string{}

// Decode decodes ReadCoreV1PersistentVolumeStatusUnauthorized from json.
func (s *ReadCoreV1PersistentVolumeStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1PersistentVolumeStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadCoreV1PersistentVolumeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadCoreV1PersistentVolumeUnauthorized = [0]string{}

// Decode decodes ReadCoreV1PersistentVolumeUnauthorized from json.
func (s *ReadCoreV1PersistentVolumeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadCoreV1PersistentVolumeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadDiscoveryV1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadDiscoveryV1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes ReadDiscoveryV1NamespacedEndpointSliceUnauthorized from json.
func (s *ReadDiscoveryV1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadDiscoveryV1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadDiscoveryV1beta1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes ReadDiscoveryV1beta1NamespacedEndpointSliceUnauthorized from json.
func (s *ReadDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadDiscoveryV1beta1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadEventsV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadEventsV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ReadEventsV1NamespacedEventUnauthorized from json.
func (s *ReadEventsV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadEventsV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadEventsV1beta1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadEventsV1beta1NamespacedEventUnauthorized = [0]string{}

// Decode decodes ReadEventsV1beta1NamespacedEventUnauthorized from json.
func (s *ReadEventsV1beta1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadEventsV1beta1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta1FlowSchemaStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta1FlowSchemaStatusUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta1FlowSchemaStatusUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta1FlowSchemaStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta1FlowSchemaStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta1FlowSchemaUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta1FlowSchemaUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta1FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta2FlowSchemaStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta2FlowSchemaStatusUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta2FlowSchemaStatusUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta2FlowSchemaStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta2FlowSchemaStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta2FlowSchemaUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta2FlowSchemaUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta2FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized from json.
func (s *ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadInternalApiserverV1alpha1StorageVersionStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadInternalApiserverV1alpha1StorageVersionStatusUnauthorized = [0]string{}

// Decode decodes ReadInternalApiserverV1alpha1StorageVersionStatusUnauthorized from json.
func (s *ReadInternalApiserverV1alpha1StorageVersionStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadInternalApiserverV1alpha1StorageVersionStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadInternalApiserverV1alpha1StorageVersionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadInternalApiserverV1alpha1StorageVersionUnauthorized = [0]string{}

// Decode decodes ReadInternalApiserverV1alpha1StorageVersionUnauthorized from json.
func (s *ReadInternalApiserverV1alpha1StorageVersionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadInternalApiserverV1alpha1StorageVersionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNetworkingV1IngressClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNetworkingV1IngressClassUnauthorized = [0]string{}

// Decode decodes ReadNetworkingV1IngressClassUnauthorized from json.
func (s *ReadNetworkingV1IngressClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNetworkingV1IngressClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNetworkingV1NamespacedIngressStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNetworkingV1NamespacedIngressStatusUnauthorized = [0]string{}

// Decode decodes ReadNetworkingV1NamespacedIngressStatusUnauthorized from json.
func (s *ReadNetworkingV1NamespacedIngressStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNetworkingV1NamespacedIngressStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNetworkingV1NamespacedIngressUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNetworkingV1NamespacedIngressUnauthorized = [0]string{}

// Decode decodes ReadNetworkingV1NamespacedIngressUnauthorized from json.
func (s *ReadNetworkingV1NamespacedIngressUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNetworkingV1NamespacedIngressUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNetworkingV1NamespacedNetworkPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNetworkingV1NamespacedNetworkPolicyUnauthorized = [0]string{}

// Decode decodes ReadNetworkingV1NamespacedNetworkPolicyUnauthorized from json.
func (s *ReadNetworkingV1NamespacedNetworkPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNetworkingV1NamespacedNetworkPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNodeV1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNodeV1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ReadNodeV1RuntimeClassUnauthorized from json.
func (s *ReadNodeV1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNodeV1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNodeV1alpha1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNodeV1alpha1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ReadNodeV1alpha1RuntimeClassUnauthorized from json.
func (s *ReadNodeV1alpha1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNodeV1alpha1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadNodeV1beta1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadNodeV1beta1RuntimeClassUnauthorized = [0]string{}

// Decode decodes ReadNodeV1beta1RuntimeClassUnauthorized from json.
func (s *ReadNodeV1beta1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadNodeV1beta1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadPolicyV1NamespacedPodDisruptionBudgetStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadPolicyV1NamespacedPodDisruptionBudgetStatusUnauthorized = [0]string{}

// Decode decodes ReadPolicyV1NamespacedPodDisruptionBudgetStatusUnauthorized from json.
func (s *ReadPolicyV1NamespacedPodDisruptionBudgetStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadPolicyV1NamespacedPodDisruptionBudgetStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadPolicyV1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes ReadPolicyV1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *ReadPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadPolicyV1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusUnauthorized = [0]string{}

// Decode decodes ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusUnauthorized from json.
func (s *ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes ReadPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *ReadPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadPolicyV1beta1PodSecurityPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadPolicyV1beta1PodSecurityPolicyUnauthorized = [0]string{}

// Decode decodes ReadPolicyV1beta1PodSecurityPolicyUnauthorized from json.
func (s *ReadPolicyV1beta1PodSecurityPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadPolicyV1beta1PodSecurityPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadRbacAuthorizationV1ClusterRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadRbacAuthorizationV1ClusterRoleBindingUnauthorized = [0]string{}

// Decode decodes ReadRbacAuthorizationV1ClusterRoleBindingUnauthorized from json.
func (s *ReadRbacAuthorizationV1ClusterRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadRbacAuthorizationV1ClusterRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadRbacAuthorizationV1ClusterRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadRbacAuthorizationV1ClusterRoleUnauthorized = [0]string{}

// Decode decodes ReadRbacAuthorizationV1ClusterRoleUnauthorized from json.
func (s *ReadRbacAuthorizationV1ClusterRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadRbacAuthorizationV1ClusterRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadRbacAuthorizationV1NamespacedRoleBindingUnauthorized = [0]string{}

// Decode decodes ReadRbacAuthorizationV1NamespacedRoleBindingUnauthorized from json.
func (s *ReadRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadRbacAuthorizationV1NamespacedRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadRbacAuthorizationV1NamespacedRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadRbacAuthorizationV1NamespacedRoleUnauthorized = [0]string{}

// Decode decodes ReadRbacAuthorizationV1NamespacedRoleUnauthorized from json.
func (s *ReadRbacAuthorizationV1NamespacedRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadRbacAuthorizationV1NamespacedRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadSchedulingV1PriorityClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadSchedulingV1PriorityClassUnauthorized = [0]string{}

// Decode decodes ReadSchedulingV1PriorityClassUnauthorized from json.
func (s *ReadSchedulingV1PriorityClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadSchedulingV1PriorityClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1CSIDriverUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1CSIDriverUnauthorized = [0]string{}

// Decode decodes ReadStorageV1CSIDriverUnauthorized from json.
func (s *ReadStorageV1CSIDriverUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1CSIDriverUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1CSINodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1CSINodeUnauthorized = [0]string{}

// Decode decodes ReadStorageV1CSINodeUnauthorized from json.
func (s *ReadStorageV1CSINodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1CSINodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1StorageClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1StorageClassUnauthorized = [0]string{}

// Decode decodes ReadStorageV1StorageClassUnauthorized from json.
func (s *ReadStorageV1StorageClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1StorageClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1VolumeAttachmentStatusUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1VolumeAttachmentStatusUnauthorized = [0]string{}

// Decode decodes ReadStorageV1VolumeAttachmentStatusUnauthorized from json.
func (s *ReadStorageV1VolumeAttachmentStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1VolumeAttachmentStatusUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1VolumeAttachmentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1VolumeAttachmentUnauthorized = [0]string{}

// Decode decodes ReadStorageV1VolumeAttachmentUnauthorized from json.
func (s *ReadStorageV1VolumeAttachmentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1VolumeAttachmentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes ReadStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *ReadStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReadStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfReadStorageV1beta1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes ReadStorageV1beta1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *ReadStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReadStorageV1beta1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAdmissionregistrationV1MutatingWebhookConfigurationListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAdmissionregistrationV1MutatingWebhookConfigurationListUnauthorized = [0]string{}

// Decode decodes WatchAdmissionregistrationV1MutatingWebhookConfigurationListUnauthorized from json.
func (s *WatchAdmissionregistrationV1MutatingWebhookConfigurationListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAdmissionregistrationV1MutatingWebhookConfigurationListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes WatchAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized from json.
func (s *WatchAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAdmissionregistrationV1MutatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAdmissionregistrationV1ValidatingWebhookConfigurationListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAdmissionregistrationV1ValidatingWebhookConfigurationListUnauthorized = [0]string{}

// Decode decodes WatchAdmissionregistrationV1ValidatingWebhookConfigurationListUnauthorized from json.
func (s *WatchAdmissionregistrationV1ValidatingWebhookConfigurationListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAdmissionregistrationV1ValidatingWebhookConfigurationListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized = [0]string{}

// Decode decodes WatchAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized from json.
func (s *WatchAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAdmissionregistrationV1ValidatingWebhookConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchApiextensionsV1CustomResourceDefinitionListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchApiextensionsV1CustomResourceDefinitionListUnauthorized = [0]string{}

// Decode decodes WatchApiextensionsV1CustomResourceDefinitionListUnauthorized from json.
func (s *WatchApiextensionsV1CustomResourceDefinitionListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchApiextensionsV1CustomResourceDefinitionListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchApiextensionsV1CustomResourceDefinitionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchApiextensionsV1CustomResourceDefinitionUnauthorized = [0]string{}

// Decode decodes WatchApiextensionsV1CustomResourceDefinitionUnauthorized from json.
func (s *WatchApiextensionsV1CustomResourceDefinitionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchApiextensionsV1CustomResourceDefinitionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchApiregistrationV1APIServiceListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchApiregistrationV1APIServiceListUnauthorized = [0]string{}

// Decode decodes WatchApiregistrationV1APIServiceListUnauthorized from json.
func (s *WatchApiregistrationV1APIServiceListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchApiregistrationV1APIServiceListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchApiregistrationV1APIServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchApiregistrationV1APIServiceUnauthorized = [0]string{}

// Decode decodes WatchApiregistrationV1APIServiceUnauthorized from json.
func (s *WatchApiregistrationV1APIServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchApiregistrationV1APIServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1ControllerRevisionListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1ControllerRevisionListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAppsV1ControllerRevisionListForAllNamespacesUnauthorized from json.
func (s *WatchAppsV1ControllerRevisionListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1ControllerRevisionListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1DaemonSetListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1DaemonSetListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAppsV1DaemonSetListForAllNamespacesUnauthorized from json.
func (s *WatchAppsV1DaemonSetListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1DaemonSetListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1DeploymentListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1DeploymentListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAppsV1DeploymentListForAllNamespacesUnauthorized from json.
func (s *WatchAppsV1DeploymentListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1DeploymentListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedControllerRevisionListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedControllerRevisionListUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedControllerRevisionListUnauthorized from json.
func (s *WatchAppsV1NamespacedControllerRevisionListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedControllerRevisionListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedControllerRevisionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedControllerRevisionUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedControllerRevisionUnauthorized from json.
func (s *WatchAppsV1NamespacedControllerRevisionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedControllerRevisionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedDaemonSetListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedDaemonSetListUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedDaemonSetListUnauthorized from json.
func (s *WatchAppsV1NamespacedDaemonSetListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedDaemonSetListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedDaemonSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedDaemonSetUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedDaemonSetUnauthorized from json.
func (s *WatchAppsV1NamespacedDaemonSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedDaemonSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedDeploymentListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedDeploymentListUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedDeploymentListUnauthorized from json.
func (s *WatchAppsV1NamespacedDeploymentListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedDeploymentListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedDeploymentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedDeploymentUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedDeploymentUnauthorized from json.
func (s *WatchAppsV1NamespacedDeploymentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedDeploymentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedReplicaSetListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedReplicaSetListUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedReplicaSetListUnauthorized from json.
func (s *WatchAppsV1NamespacedReplicaSetListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedReplicaSetListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedReplicaSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedReplicaSetUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedReplicaSetUnauthorized from json.
func (s *WatchAppsV1NamespacedReplicaSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedReplicaSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedStatefulSetListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedStatefulSetListUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedStatefulSetListUnauthorized from json.
func (s *WatchAppsV1NamespacedStatefulSetListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedStatefulSetListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1NamespacedStatefulSetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1NamespacedStatefulSetUnauthorized = [0]string{}

// Decode decodes WatchAppsV1NamespacedStatefulSetUnauthorized from json.
func (s *WatchAppsV1NamespacedStatefulSetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1NamespacedStatefulSetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1ReplicaSetListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1ReplicaSetListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAppsV1ReplicaSetListForAllNamespacesUnauthorized from json.
func (s *WatchAppsV1ReplicaSetListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1ReplicaSetListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAppsV1StatefulSetListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAppsV1StatefulSetListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAppsV1StatefulSetListForAllNamespacesUnauthorized from json.
func (s *WatchAppsV1StatefulSetListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAppsV1StatefulSetListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesUnauthorized from json.
func (s *WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListUnauthorized from json.
func (s *WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *WatchAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesUnauthorized from json.
func (s *WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListUnauthorized from json.
func (s *WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesUnauthorized from json.
func (s *WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListUnauthorized from json.
func (s *WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized = [0]string{}

// Decode decodes WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized from json.
func (s *WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1CronJobListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1CronJobListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchBatchV1CronJobListForAllNamespacesUnauthorized from json.
func (s *WatchBatchV1CronJobListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1CronJobListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1JobListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1JobListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchBatchV1JobListForAllNamespacesUnauthorized from json.
func (s *WatchBatchV1JobListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1JobListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1NamespacedCronJobListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1NamespacedCronJobListUnauthorized = [0]string{}

// Decode decodes WatchBatchV1NamespacedCronJobListUnauthorized from json.
func (s *WatchBatchV1NamespacedCronJobListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1NamespacedCronJobListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes WatchBatchV1NamespacedCronJobUnauthorized from json.
func (s *WatchBatchV1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1NamespacedJobListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1NamespacedJobListUnauthorized = [0]string{}

// Decode decodes WatchBatchV1NamespacedJobListUnauthorized from json.
func (s *WatchBatchV1NamespacedJobListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1NamespacedJobListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1NamespacedJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1NamespacedJobUnauthorized = [0]string{}

// Decode decodes WatchBatchV1NamespacedJobUnauthorized from json.
func (s *WatchBatchV1NamespacedJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1NamespacedJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1beta1CronJobListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1beta1CronJobListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchBatchV1beta1CronJobListForAllNamespacesUnauthorized from json.
func (s *WatchBatchV1beta1CronJobListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1beta1CronJobListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1beta1NamespacedCronJobListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1beta1NamespacedCronJobListUnauthorized = [0]string{}

// Decode decodes WatchBatchV1beta1NamespacedCronJobListUnauthorized from json.
func (s *WatchBatchV1beta1NamespacedCronJobListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1beta1NamespacedCronJobListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchBatchV1beta1NamespacedCronJobUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchBatchV1beta1NamespacedCronJobUnauthorized = [0]string{}

// Decode decodes WatchBatchV1beta1NamespacedCronJobUnauthorized from json.
func (s *WatchBatchV1beta1NamespacedCronJobUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchBatchV1beta1NamespacedCronJobUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCertificatesV1CertificateSigningRequestListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCertificatesV1CertificateSigningRequestListUnauthorized = [0]string{}

// Decode decodes WatchCertificatesV1CertificateSigningRequestListUnauthorized from json.
func (s *WatchCertificatesV1CertificateSigningRequestListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCertificatesV1CertificateSigningRequestListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCertificatesV1CertificateSigningRequestUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCertificatesV1CertificateSigningRequestUnauthorized = [0]string{}

// Decode decodes WatchCertificatesV1CertificateSigningRequestUnauthorized from json.
func (s *WatchCertificatesV1CertificateSigningRequestUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCertificatesV1CertificateSigningRequestUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoordinationV1LeaseListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoordinationV1LeaseListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoordinationV1LeaseListForAllNamespacesUnauthorized from json.
func (s *WatchCoordinationV1LeaseListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoordinationV1LeaseListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoordinationV1NamespacedLeaseListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoordinationV1NamespacedLeaseListUnauthorized = [0]string{}

// Decode decodes WatchCoordinationV1NamespacedLeaseListUnauthorized from json.
func (s *WatchCoordinationV1NamespacedLeaseListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoordinationV1NamespacedLeaseListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoordinationV1NamespacedLeaseUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoordinationV1NamespacedLeaseUnauthorized = [0]string{}

// Decode decodes WatchCoordinationV1NamespacedLeaseUnauthorized from json.
func (s *WatchCoordinationV1NamespacedLeaseUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoordinationV1NamespacedLeaseUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1ConfigMapListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1ConfigMapListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1ConfigMapListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1ConfigMapListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1ConfigMapListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1EndpointsListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1EndpointsListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1EndpointsListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1EndpointsListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1EndpointsListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1EventListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1EventListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1EventListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1EventListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1EventListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1LimitRangeListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1LimitRangeListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1LimitRangeListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1LimitRangeListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1LimitRangeListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespaceListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespaceListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespaceListUnauthorized from json.
func (s *WatchCoreV1NamespaceListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespaceListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespaceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespaceUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespaceUnauthorized from json.
func (s *WatchCoreV1NamespaceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespaceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedConfigMapListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedConfigMapListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedConfigMapListUnauthorized from json.
func (s *WatchCoreV1NamespacedConfigMapListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedConfigMapListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedConfigMapUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedConfigMapUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedConfigMapUnauthorized from json.
func (s *WatchCoreV1NamespacedConfigMapUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedConfigMapUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedEndpointsListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedEndpointsListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedEndpointsListUnauthorized from json.
func (s *WatchCoreV1NamespacedEndpointsListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedEndpointsListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedEndpointsUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedEndpointsUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedEndpointsUnauthorized from json.
func (s *WatchCoreV1NamespacedEndpointsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedEndpointsUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedEventListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedEventListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedEventListUnauthorized from json.
func (s *WatchCoreV1NamespacedEventListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedEventListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedEventUnauthorized from json.
func (s *WatchCoreV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedLimitRangeListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedLimitRangeListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedLimitRangeListUnauthorized from json.
func (s *WatchCoreV1NamespacedLimitRangeListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedLimitRangeListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedLimitRangeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedLimitRangeUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedLimitRangeUnauthorized from json.
func (s *WatchCoreV1NamespacedLimitRangeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedLimitRangeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPersistentVolumeClaimListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPersistentVolumeClaimListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPersistentVolumeClaimListUnauthorized from json.
func (s *WatchCoreV1NamespacedPersistentVolumeClaimListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPersistentVolumeClaimListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPersistentVolumeClaimUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPersistentVolumeClaimUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPersistentVolumeClaimUnauthorized from json.
func (s *WatchCoreV1NamespacedPersistentVolumeClaimUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPersistentVolumeClaimUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPodListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPodListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPodListUnauthorized from json.
func (s *WatchCoreV1NamespacedPodListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPodListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPodTemplateListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPodTemplateListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPodTemplateListUnauthorized from json.
func (s *WatchCoreV1NamespacedPodTemplateListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPodTemplateListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPodTemplateUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPodTemplateUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPodTemplateUnauthorized from json.
func (s *WatchCoreV1NamespacedPodTemplateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPodTemplateUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedPodUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedPodUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedPodUnauthorized from json.
func (s *WatchCoreV1NamespacedPodUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedPodUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedReplicationControllerListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedReplicationControllerListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedReplicationControllerListUnauthorized from json.
func (s *WatchCoreV1NamespacedReplicationControllerListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedReplicationControllerListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedReplicationControllerUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedReplicationControllerUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedReplicationControllerUnauthorized from json.
func (s *WatchCoreV1NamespacedReplicationControllerUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedReplicationControllerUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedResourceQuotaListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedResourceQuotaListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedResourceQuotaListUnauthorized from json.
func (s *WatchCoreV1NamespacedResourceQuotaListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedResourceQuotaListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedResourceQuotaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedResourceQuotaUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedResourceQuotaUnauthorized from json.
func (s *WatchCoreV1NamespacedResourceQuotaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedResourceQuotaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedSecretListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedSecretListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedSecretListUnauthorized from json.
func (s *WatchCoreV1NamespacedSecretListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedSecretListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedSecretUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedSecretUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedSecretUnauthorized from json.
func (s *WatchCoreV1NamespacedSecretUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedSecretUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedServiceAccountListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedServiceAccountListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedServiceAccountListUnauthorized from json.
func (s *WatchCoreV1NamespacedServiceAccountListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedServiceAccountListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedServiceAccountUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedServiceAccountUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedServiceAccountUnauthorized from json.
func (s *WatchCoreV1NamespacedServiceAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedServiceAccountUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedServiceListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedServiceListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedServiceListUnauthorized from json.
func (s *WatchCoreV1NamespacedServiceListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedServiceListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NamespacedServiceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NamespacedServiceUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NamespacedServiceUnauthorized from json.
func (s *WatchCoreV1NamespacedServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NamespacedServiceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NodeListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NodeListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NodeListUnauthorized from json.
func (s *WatchCoreV1NodeListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NodeListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1NodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1NodeUnauthorized = [0]string{}

// Decode decodes WatchCoreV1NodeUnauthorized from json.
func (s *WatchCoreV1NodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1NodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1PersistentVolumeClaimListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1PersistentVolumeClaimListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1PersistentVolumeClaimListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1PersistentVolumeClaimListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1PersistentVolumeClaimListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1PersistentVolumeListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1PersistentVolumeListUnauthorized = [0]string{}

// Decode decodes WatchCoreV1PersistentVolumeListUnauthorized from json.
func (s *WatchCoreV1PersistentVolumeListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1PersistentVolumeListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1PersistentVolumeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1PersistentVolumeUnauthorized = [0]string{}

// Decode decodes WatchCoreV1PersistentVolumeUnauthorized from json.
func (s *WatchCoreV1PersistentVolumeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1PersistentVolumeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1PodListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1PodListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1PodListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1PodListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1PodListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1PodTemplateListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1PodTemplateListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1PodTemplateListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1PodTemplateListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1PodTemplateListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1ReplicationControllerListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1ReplicationControllerListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1ReplicationControllerListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1ReplicationControllerListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1ReplicationControllerListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1ResourceQuotaListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1ResourceQuotaListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1ResourceQuotaListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1ResourceQuotaListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1ResourceQuotaListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1SecretListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1SecretListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1SecretListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1SecretListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1SecretListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1ServiceAccountListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1ServiceAccountListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1ServiceAccountListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1ServiceAccountListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1ServiceAccountListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchCoreV1ServiceListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchCoreV1ServiceListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchCoreV1ServiceListForAllNamespacesUnauthorized from json.
func (s *WatchCoreV1ServiceListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchCoreV1ServiceListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1EndpointSliceListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1EndpointSliceListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1EndpointSliceListForAllNamespacesUnauthorized from json.
func (s *WatchDiscoveryV1EndpointSliceListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1EndpointSliceListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1NamespacedEndpointSliceListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1NamespacedEndpointSliceListUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1NamespacedEndpointSliceListUnauthorized from json.
func (s *WatchDiscoveryV1NamespacedEndpointSliceListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1NamespacedEndpointSliceListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1NamespacedEndpointSliceUnauthorized from json.
func (s *WatchDiscoveryV1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesUnauthorized from json.
func (s *WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1beta1NamespacedEndpointSliceListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1beta1NamespacedEndpointSliceListUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1beta1NamespacedEndpointSliceListUnauthorized from json.
func (s *WatchDiscoveryV1beta1NamespacedEndpointSliceListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1beta1NamespacedEndpointSliceListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchDiscoveryV1beta1NamespacedEndpointSliceUnauthorized = [0]string{}

// Decode decodes WatchDiscoveryV1beta1NamespacedEndpointSliceUnauthorized from json.
func (s *WatchDiscoveryV1beta1NamespacedEndpointSliceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchDiscoveryV1beta1NamespacedEndpointSliceUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1EventListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1EventListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchEventsV1EventListForAllNamespacesUnauthorized from json.
func (s *WatchEventsV1EventListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1EventListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1NamespacedEventListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1NamespacedEventListUnauthorized = [0]string{}

// Decode decodes WatchEventsV1NamespacedEventListUnauthorized from json.
func (s *WatchEventsV1NamespacedEventListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1NamespacedEventListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1NamespacedEventUnauthorized = [0]string{}

// Decode decodes WatchEventsV1NamespacedEventUnauthorized from json.
func (s *WatchEventsV1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1beta1EventListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1beta1EventListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchEventsV1beta1EventListForAllNamespacesUnauthorized from json.
func (s *WatchEventsV1beta1EventListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1beta1EventListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1beta1NamespacedEventListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1beta1NamespacedEventListUnauthorized = [0]string{}

// Decode decodes WatchEventsV1beta1NamespacedEventListUnauthorized from json.
func (s *WatchEventsV1beta1NamespacedEventListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1beta1NamespacedEventListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchEventsV1beta1NamespacedEventUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchEventsV1beta1NamespacedEventUnauthorized = [0]string{}

// Decode decodes WatchEventsV1beta1NamespacedEventUnauthorized from json.
func (s *WatchEventsV1beta1NamespacedEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchEventsV1beta1NamespacedEventUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta1FlowSchemaListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta1FlowSchemaListUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta1FlowSchemaListUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta1FlowSchemaListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta1FlowSchemaListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta1FlowSchemaUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta1FlowSchemaUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta1FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta1FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta2FlowSchemaListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta2FlowSchemaListUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta2FlowSchemaListUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta2FlowSchemaListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta2FlowSchemaListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta2FlowSchemaUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta2FlowSchemaUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta2FlowSchemaUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta2FlowSchemaUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized = [0]string{}

// Decode decodes WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized from json.
func (s *WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchInternalApiserverV1alpha1StorageVersionListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchInternalApiserverV1alpha1StorageVersionListUnauthorized = [0]string{}

// Decode decodes WatchInternalApiserverV1alpha1StorageVersionListUnauthorized from json.
func (s *WatchInternalApiserverV1alpha1StorageVersionListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchInternalApiserverV1alpha1StorageVersionListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchInternalApiserverV1alpha1StorageVersionUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchInternalApiserverV1alpha1StorageVersionUnauthorized = [0]string{}

// Decode decodes WatchInternalApiserverV1alpha1StorageVersionUnauthorized from json.
func (s *WatchInternalApiserverV1alpha1StorageVersionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchInternalApiserverV1alpha1StorageVersionUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1IngressClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1IngressClassListUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1IngressClassListUnauthorized from json.
func (s *WatchNetworkingV1IngressClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1IngressClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1IngressClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1IngressClassUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1IngressClassUnauthorized from json.
func (s *WatchNetworkingV1IngressClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1IngressClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1IngressListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1IngressListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1IngressListForAllNamespacesUnauthorized from json.
func (s *WatchNetworkingV1IngressListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1IngressListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1NamespacedIngressListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1NamespacedIngressListUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1NamespacedIngressListUnauthorized from json.
func (s *WatchNetworkingV1NamespacedIngressListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1NamespacedIngressListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1NamespacedIngressUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1NamespacedIngressUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1NamespacedIngressUnauthorized from json.
func (s *WatchNetworkingV1NamespacedIngressUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1NamespacedIngressUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1NamespacedNetworkPolicyListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1NamespacedNetworkPolicyListUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1NamespacedNetworkPolicyListUnauthorized from json.
func (s *WatchNetworkingV1NamespacedNetworkPolicyListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1NamespacedNetworkPolicyListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1NamespacedNetworkPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1NamespacedNetworkPolicyUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1NamespacedNetworkPolicyUnauthorized from json.
func (s *WatchNetworkingV1NamespacedNetworkPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1NamespacedNetworkPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNetworkingV1NetworkPolicyListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNetworkingV1NetworkPolicyListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchNetworkingV1NetworkPolicyListForAllNamespacesUnauthorized from json.
func (s *WatchNetworkingV1NetworkPolicyListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNetworkingV1NetworkPolicyListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1RuntimeClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1RuntimeClassListUnauthorized = [0]string{}

// Decode decodes WatchNodeV1RuntimeClassListUnauthorized from json.
func (s *WatchNodeV1RuntimeClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1RuntimeClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1RuntimeClassUnauthorized = [0]string{}

// Decode decodes WatchNodeV1RuntimeClassUnauthorized from json.
func (s *WatchNodeV1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1alpha1RuntimeClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1alpha1RuntimeClassListUnauthorized = [0]string{}

// Decode decodes WatchNodeV1alpha1RuntimeClassListUnauthorized from json.
func (s *WatchNodeV1alpha1RuntimeClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1alpha1RuntimeClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1alpha1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1alpha1RuntimeClassUnauthorized = [0]string{}

// Decode decodes WatchNodeV1alpha1RuntimeClassUnauthorized from json.
func (s *WatchNodeV1alpha1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1alpha1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1beta1RuntimeClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1beta1RuntimeClassListUnauthorized = [0]string{}

// Decode decodes WatchNodeV1beta1RuntimeClassListUnauthorized from json.
func (s *WatchNodeV1beta1RuntimeClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1beta1RuntimeClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchNodeV1beta1RuntimeClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchNodeV1beta1RuntimeClassUnauthorized = [0]string{}

// Decode decodes WatchNodeV1beta1RuntimeClassUnauthorized from json.
func (s *WatchNodeV1beta1RuntimeClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchNodeV1beta1RuntimeClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1NamespacedPodDisruptionBudgetListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1NamespacedPodDisruptionBudgetListUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1NamespacedPodDisruptionBudgetListUnauthorized from json.
func (s *WatchPolicyV1NamespacedPodDisruptionBudgetListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1NamespacedPodDisruptionBudgetListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *WatchPolicyV1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1PodDisruptionBudgetListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1PodDisruptionBudgetListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1PodDisruptionBudgetListForAllNamespacesUnauthorized from json.
func (s *WatchPolicyV1PodDisruptionBudgetListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1PodDisruptionBudgetListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1beta1NamespacedPodDisruptionBudgetListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1beta1NamespacedPodDisruptionBudgetListUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1beta1NamespacedPodDisruptionBudgetListUnauthorized from json.
func (s *WatchPolicyV1beta1NamespacedPodDisruptionBudgetListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1beta1NamespacedPodDisruptionBudgetListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized from json.
func (s *WatchPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1beta1NamespacedPodDisruptionBudgetUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesUnauthorized from json.
func (s *WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1beta1PodSecurityPolicyListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1beta1PodSecurityPolicyListUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1beta1PodSecurityPolicyListUnauthorized from json.
func (s *WatchPolicyV1beta1PodSecurityPolicyListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1beta1PodSecurityPolicyListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchPolicyV1beta1PodSecurityPolicyUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchPolicyV1beta1PodSecurityPolicyUnauthorized = [0]string{}

// Decode decodes WatchPolicyV1beta1PodSecurityPolicyUnauthorized from json.
func (s *WatchPolicyV1beta1PodSecurityPolicyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchPolicyV1beta1PodSecurityPolicyUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1ClusterRoleBindingListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1ClusterRoleBindingListUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1ClusterRoleBindingListUnauthorized from json.
func (s *WatchRbacAuthorizationV1ClusterRoleBindingListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1ClusterRoleBindingListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1ClusterRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1ClusterRoleBindingUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1ClusterRoleBindingUnauthorized from json.
func (s *WatchRbacAuthorizationV1ClusterRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1ClusterRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1ClusterRoleListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1ClusterRoleListUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1ClusterRoleListUnauthorized from json.
func (s *WatchRbacAuthorizationV1ClusterRoleListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1ClusterRoleListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1ClusterRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1ClusterRoleUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1ClusterRoleUnauthorized from json.
func (s *WatchRbacAuthorizationV1ClusterRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1ClusterRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1NamespacedRoleBindingListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1NamespacedRoleBindingListUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1NamespacedRoleBindingListUnauthorized from json.
func (s *WatchRbacAuthorizationV1NamespacedRoleBindingListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1NamespacedRoleBindingListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1NamespacedRoleBindingUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1NamespacedRoleBindingUnauthorized from json.
func (s *WatchRbacAuthorizationV1NamespacedRoleBindingUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1NamespacedRoleBindingUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1NamespacedRoleListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1NamespacedRoleListUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1NamespacedRoleListUnauthorized from json.
func (s *WatchRbacAuthorizationV1NamespacedRoleListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1NamespacedRoleListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1NamespacedRoleUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1NamespacedRoleUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1NamespacedRoleUnauthorized from json.
func (s *WatchRbacAuthorizationV1NamespacedRoleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1NamespacedRoleUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1RoleBindingListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1RoleBindingListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1RoleBindingListForAllNamespacesUnauthorized from json.
func (s *WatchRbacAuthorizationV1RoleBindingListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1RoleBindingListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchRbacAuthorizationV1RoleListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchRbacAuthorizationV1RoleListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchRbacAuthorizationV1RoleListForAllNamespacesUnauthorized from json.
func (s *WatchRbacAuthorizationV1RoleListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchRbacAuthorizationV1RoleListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchSchedulingV1PriorityClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchSchedulingV1PriorityClassListUnauthorized = [0]string{}

// Decode decodes WatchSchedulingV1PriorityClassListUnauthorized from json.
func (s *WatchSchedulingV1PriorityClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchSchedulingV1PriorityClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchSchedulingV1PriorityClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchSchedulingV1PriorityClassUnauthorized = [0]string{}

// Decode decodes WatchSchedulingV1PriorityClassUnauthorized from json.
func (s *WatchSchedulingV1PriorityClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchSchedulingV1PriorityClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1CSIDriverListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1CSIDriverListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1CSIDriverListUnauthorized from json.
func (s *WatchStorageV1CSIDriverListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1CSIDriverListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1CSIDriverUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1CSIDriverUnauthorized = [0]string{}

// Decode decodes WatchStorageV1CSIDriverUnauthorized from json.
func (s *WatchStorageV1CSIDriverUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1CSIDriverUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1CSINodeListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1CSINodeListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1CSINodeListUnauthorized from json.
func (s *WatchStorageV1CSINodeListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1CSINodeListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1CSINodeUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1CSINodeUnauthorized = [0]string{}

// Decode decodes WatchStorageV1CSINodeUnauthorized from json.
func (s *WatchStorageV1CSINodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1CSINodeUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1StorageClassListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1StorageClassListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1StorageClassListUnauthorized from json.
func (s *WatchStorageV1StorageClassListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1StorageClassListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1StorageClassUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1StorageClassUnauthorized = [0]string{}

// Decode decodes WatchStorageV1StorageClassUnauthorized from json.
func (s *WatchStorageV1StorageClassUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1StorageClassUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1VolumeAttachmentListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1VolumeAttachmentListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1VolumeAttachmentListUnauthorized from json.
func (s *WatchStorageV1VolumeAttachmentListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1VolumeAttachmentListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1VolumeAttachmentUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1VolumeAttachmentUnauthorized = [0]string{}

// Decode decodes WatchStorageV1VolumeAttachmentUnauthorized from json.
func (s *WatchStorageV1VolumeAttachmentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1VolumeAttachmentUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesUnauthorized from json.
func (s *WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1alpha1NamespacedCSIStorageCapacityListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1alpha1NamespacedCSIStorageCapacityListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1alpha1NamespacedCSIStorageCapacityListUnauthorized from json.
func (s *WatchStorageV1alpha1NamespacedCSIStorageCapacityListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1alpha1NamespacedCSIStorageCapacityListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes WatchStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *WatchStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1alpha1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesUnauthorized = [0]string{}

// Decode decodes WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesUnauthorized from json.
func (s *WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1beta1NamespacedCSIStorageCapacityListUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1beta1NamespacedCSIStorageCapacityListUnauthorized = [0]string{}

// Decode decodes WatchStorageV1beta1NamespacedCSIStorageCapacityListUnauthorized from json.
func (s *WatchStorageV1beta1NamespacedCSIStorageCapacityListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1beta1NamespacedCSIStorageCapacityListUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WatchStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfWatchStorageV1beta1NamespacedCSIStorageCapacityUnauthorized = [0]string{}

// Decode decodes WatchStorageV1beta1NamespacedCSIStorageCapacityUnauthorized from json.
func (s *WatchStorageV1beta1NamespacedCSIStorageCapacityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WatchStorageV1beta1NamespacedCSIStorageCapacityUnauthorized to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}
