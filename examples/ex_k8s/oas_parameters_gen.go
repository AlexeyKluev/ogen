// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
)

type ListAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params ListAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAdmissionregistrationV1MutatingWebhookConfigurationParams(args [0]string, r *http.Request) (params ListAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params ListAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [0]string, r *http.Request) (params ListAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListApiextensionsV1CustomResourceDefinitionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params ListApiextensionsV1CustomResourceDefinitionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListApiextensionsV1CustomResourceDefinitionParams(args [0]string, r *http.Request) (params ListApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListApiregistrationV1APIServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListApiregistrationV1APIServiceParams(packed map[string]any) (params ListApiregistrationV1APIServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListApiregistrationV1APIServiceParams(args [0]string, r *http.Request) (params ListApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1ControllerRevisionForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAppsV1ControllerRevisionForAllNamespacesParams(packed map[string]any) (params ListAppsV1ControllerRevisionForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1ControllerRevisionForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1ControllerRevisionForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1DaemonSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAppsV1DaemonSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1DaemonSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1DaemonSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1DaemonSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1DeploymentForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAppsV1DeploymentForAllNamespacesParams(packed map[string]any) (params ListAppsV1DeploymentForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1DeploymentForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1DeploymentForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1NamespacedControllerRevisionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params ListAppsV1NamespacedControllerRevisionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedControllerRevisionParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1NamespacedDaemonSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAppsV1NamespacedDaemonSetParams(packed map[string]any) (params ListAppsV1NamespacedDaemonSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedDaemonSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1NamespacedDeploymentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAppsV1NamespacedDeploymentParams(packed map[string]any) (params ListAppsV1NamespacedDeploymentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedDeploymentParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1NamespacedReplicaSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAppsV1NamespacedReplicaSetParams(packed map[string]any) (params ListAppsV1NamespacedReplicaSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedReplicaSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1NamespacedStatefulSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAppsV1NamespacedStatefulSetParams(packed map[string]any) (params ListAppsV1NamespacedStatefulSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedStatefulSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1ReplicaSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAppsV1ReplicaSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1ReplicaSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1ReplicaSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1ReplicaSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAppsV1StatefulSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAppsV1StatefulSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1StatefulSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1StatefulSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1StatefulSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1CronJobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListBatchV1CronJobForAllNamespacesParams(packed map[string]any) (params ListBatchV1CronJobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1CronJobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1CronJobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1JobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListBatchV1JobForAllNamespacesParams(packed map[string]any) (params ListBatchV1JobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1JobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1JobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListBatchV1NamespacedCronJobParams(packed map[string]any) (params ListBatchV1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1NamespacedCronJobParams(args [1]string, r *http.Request) (params ListBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1NamespacedJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListBatchV1NamespacedJobParams(packed map[string]any) (params ListBatchV1NamespacedJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1NamespacedJobParams(args [1]string, r *http.Request) (params ListBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1beta1CronJobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListBatchV1beta1CronJobForAllNamespacesParams(packed map[string]any) (params ListBatchV1beta1CronJobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1beta1CronJobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1beta1CronJobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListBatchV1beta1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params ListBatchV1beta1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1beta1NamespacedCronJobParams(args [1]string, r *http.Request) (params ListBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCertificatesV1CertificateSigningRequestParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params ListCertificatesV1CertificateSigningRequestParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCertificatesV1CertificateSigningRequestParams(args [0]string, r *http.Request) (params ListCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoordinationV1LeaseForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoordinationV1LeaseForAllNamespacesParams(packed map[string]any) (params ListCoordinationV1LeaseForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoordinationV1LeaseForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoordinationV1LeaseForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoordinationV1NamespacedLeaseParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoordinationV1NamespacedLeaseParams(packed map[string]any) (params ListCoordinationV1NamespacedLeaseParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoordinationV1NamespacedLeaseParams(args [1]string, r *http.Request) (params ListCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ComponentStatusParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ComponentStatusParams(packed map[string]any) (params ListCoreV1ComponentStatusParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ComponentStatusParams(args [0]string, r *http.Request) (params ListCoreV1ComponentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ConfigMapForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ConfigMapForAllNamespacesParams(packed map[string]any) (params ListCoreV1ConfigMapForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ConfigMapForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ConfigMapForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1EndpointsForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1EndpointsForAllNamespacesParams(packed map[string]any) (params ListCoreV1EndpointsForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1EndpointsForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1EndpointsForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1EventForAllNamespacesParams(packed map[string]any) (params ListCoreV1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1LimitRangeForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1LimitRangeForAllNamespacesParams(packed map[string]any) (params ListCoreV1LimitRangeForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1LimitRangeForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1LimitRangeForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespaceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespaceParams(packed map[string]any) (params ListCoreV1NamespaceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespaceParams(args [0]string, r *http.Request) (params ListCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedConfigMapParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedConfigMapParams(packed map[string]any) (params ListCoreV1NamespacedConfigMapParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedConfigMapParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedEndpointsParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedEndpointsParams(packed map[string]any) (params ListCoreV1NamespacedEndpointsParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedEndpointsParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedEventParams(packed map[string]any) (params ListCoreV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedEventParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedLimitRangeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedLimitRangeParams(packed map[string]any) (params ListCoreV1NamespacedLimitRangeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedLimitRangeParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedPersistentVolumeClaimParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params ListCoreV1NamespacedPersistentVolumeClaimParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPersistentVolumeClaimParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedPodParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedPodParams(packed map[string]any) (params ListCoreV1NamespacedPodParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPodParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedPodTemplateParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedPodTemplateParams(packed map[string]any) (params ListCoreV1NamespacedPodTemplateParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPodTemplateParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedReplicationControllerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params ListCoreV1NamespacedReplicationControllerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedReplicationControllerParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedResourceQuotaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params ListCoreV1NamespacedResourceQuotaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedResourceQuotaParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedSecretParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedSecretParams(packed map[string]any) (params ListCoreV1NamespacedSecretParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedSecretParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedServiceParams(packed map[string]any) (params ListCoreV1NamespacedServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedServiceParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NamespacedServiceAccountParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NamespacedServiceAccountParams(packed map[string]any) (params ListCoreV1NamespacedServiceAccountParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedServiceAccountParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1NodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1NodeParams(packed map[string]any) (params ListCoreV1NodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NodeParams(args [0]string, r *http.Request) (params ListCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1PersistentVolumeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListCoreV1PersistentVolumeParams(packed map[string]any) (params ListCoreV1PersistentVolumeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1PersistentVolumeParams(args [0]string, r *http.Request) (params ListCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1PersistentVolumeClaimForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1PersistentVolumeClaimForAllNamespacesParams(packed map[string]any) (params ListCoreV1PersistentVolumeClaimForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PersistentVolumeClaimForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PersistentVolumeClaimForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1PodForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1PodForAllNamespacesParams(packed map[string]any) (params ListCoreV1PodForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PodForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PodForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1PodTemplateForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1PodTemplateForAllNamespacesParams(packed map[string]any) (params ListCoreV1PodTemplateForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PodTemplateForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PodTemplateForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ReplicationControllerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ReplicationControllerForAllNamespacesParams(packed map[string]any) (params ListCoreV1ReplicationControllerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ReplicationControllerForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ReplicationControllerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ResourceQuotaForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ResourceQuotaForAllNamespacesParams(packed map[string]any) (params ListCoreV1ResourceQuotaForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ResourceQuotaForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ResourceQuotaForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1SecretForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1SecretForAllNamespacesParams(packed map[string]any) (params ListCoreV1SecretForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1SecretForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1SecretForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ServiceAccountForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ServiceAccountForAllNamespacesParams(packed map[string]any) (params ListCoreV1ServiceAccountForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ServiceAccountForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ServiceAccountForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListCoreV1ServiceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListCoreV1ServiceForAllNamespacesParams(packed map[string]any) (params ListCoreV1ServiceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ServiceForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ServiceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListDiscoveryV1EndpointSliceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListDiscoveryV1EndpointSliceForAllNamespacesParams(packed map[string]any) (params ListDiscoveryV1EndpointSliceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListDiscoveryV1EndpointSliceForAllNamespacesParams(args [0]string, r *http.Request) (params ListDiscoveryV1EndpointSliceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListDiscoveryV1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params ListDiscoveryV1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListDiscoveryV1NamespacedEndpointSliceParams(args [1]string, r *http.Request) (params ListDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(packed map[string]any) (params ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(args [0]string, r *http.Request) (params ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params ListDiscoveryV1beta1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListDiscoveryV1beta1NamespacedEndpointSliceParams(args [1]string, r *http.Request) (params ListDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListEventsV1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListEventsV1EventForAllNamespacesParams(packed map[string]any) (params ListEventsV1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListEventsV1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListEventsV1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListEventsV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListEventsV1NamespacedEventParams(packed map[string]any) (params ListEventsV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListEventsV1NamespacedEventParams(args [1]string, r *http.Request) (params ListEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListEventsV1beta1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListEventsV1beta1EventForAllNamespacesParams(packed map[string]any) (params ListEventsV1beta1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListEventsV1beta1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListEventsV1beta1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListEventsV1beta1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListEventsV1beta1NamespacedEventParams(packed map[string]any) (params ListEventsV1beta1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListEventsV1beta1NamespacedEventParams(args [1]string, r *http.Request) (params ListEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta1FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta1FlowSchemaParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta2FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta2FlowSchemaParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListInternalApiserverV1alpha1StorageVersionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params ListInternalApiserverV1alpha1StorageVersionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListInternalApiserverV1alpha1StorageVersionParams(args [0]string, r *http.Request) (params ListInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNetworkingV1IngressClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNetworkingV1IngressClassParams(packed map[string]any) (params ListNetworkingV1IngressClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1IngressClassParams(args [0]string, r *http.Request) (params ListNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNetworkingV1IngressForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListNetworkingV1IngressForAllNamespacesParams(packed map[string]any) (params ListNetworkingV1IngressForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListNetworkingV1IngressForAllNamespacesParams(args [0]string, r *http.Request) (params ListNetworkingV1IngressForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListNetworkingV1NamespacedIngressParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNetworkingV1NamespacedIngressParams(packed map[string]any) (params ListNetworkingV1NamespacedIngressParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1NamespacedIngressParams(args [1]string, r *http.Request) (params ListNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNetworkingV1NamespacedNetworkPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params ListNetworkingV1NamespacedNetworkPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1NamespacedNetworkPolicyParams(args [1]string, r *http.Request) (params ListNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNetworkingV1NetworkPolicyForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListNetworkingV1NetworkPolicyForAllNamespacesParams(packed map[string]any) (params ListNetworkingV1NetworkPolicyForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListNetworkingV1NetworkPolicyForAllNamespacesParams(args [0]string, r *http.Request) (params ListNetworkingV1NetworkPolicyForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListNodeV1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNodeV1RuntimeClassParams(packed map[string]any) (params ListNodeV1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNodeV1alpha1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNodeV1alpha1RuntimeClassParams(packed map[string]any) (params ListNodeV1alpha1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1alpha1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListNodeV1beta1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListNodeV1beta1RuntimeClassParams(packed map[string]any) (params ListNodeV1beta1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1beta1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ListPolicyV1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1NamespacedPodDisruptionBudgetParams(args [1]string, r *http.Request) (params ListPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListPolicyV1PodDisruptionBudgetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListPolicyV1PodDisruptionBudgetForAllNamespacesParams(packed map[string]any) (params ListPolicyV1PodDisruptionBudgetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListPolicyV1PodDisruptionBudgetForAllNamespacesParams(args [0]string, r *http.Request) (params ListPolicyV1PodDisruptionBudgetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ListPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [1]string, r *http.Request) (params ListPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(packed map[string]any) (params ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(args [0]string, r *http.Request) (params ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListPolicyV1beta1PodSecurityPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params ListPolicyV1beta1PodSecurityPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1beta1PodSecurityPolicyParams(args [0]string, r *http.Request) (params ListPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1ClusterRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params ListRbacAuthorizationV1ClusterRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1ClusterRoleParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1ClusterRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params ListRbacAuthorizationV1ClusterRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1ClusterRoleBindingParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1NamespacedRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params ListRbacAuthorizationV1NamespacedRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1NamespacedRoleParams(args [1]string, r *http.Request) (params ListRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params ListRbacAuthorizationV1NamespacedRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1NamespacedRoleBindingParams(args [1]string, r *http.Request) (params ListRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1RoleBindingForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListRbacAuthorizationV1RoleBindingForAllNamespacesParams(packed map[string]any) (params ListRbacAuthorizationV1RoleBindingForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListRbacAuthorizationV1RoleBindingForAllNamespacesParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1RoleBindingForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListRbacAuthorizationV1RoleForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListRbacAuthorizationV1RoleForAllNamespacesParams(packed map[string]any) (params ListRbacAuthorizationV1RoleForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListRbacAuthorizationV1RoleForAllNamespacesParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1RoleForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListSchedulingV1PriorityClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListSchedulingV1PriorityClassParams(packed map[string]any) (params ListSchedulingV1PriorityClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListSchedulingV1PriorityClassParams(args [0]string, r *http.Request) (params ListSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1CSIDriverParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1CSIDriverParams(packed map[string]any) (params ListStorageV1CSIDriverParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1CSIDriverParams(args [0]string, r *http.Request) (params ListStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1CSINodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1CSINodeParams(packed map[string]any) (params ListStorageV1CSINodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1CSINodeParams(args [0]string, r *http.Request) (params ListStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1StorageClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1StorageClassParams(packed map[string]any) (params ListStorageV1StorageClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1StorageClassParams(args [0]string, r *http.Request) (params ListStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1VolumeAttachmentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1VolumeAttachmentParams(packed map[string]any) (params ListStorageV1VolumeAttachmentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1VolumeAttachmentParams(args [0]string, r *http.Request) (params ListStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(packed map[string]any) (params ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(args [0]string, r *http.Request) (params ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ListStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1alpha1NamespacedCSIStorageCapacityParams(args [1]string, r *http.Request) (params ListStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(packed map[string]any) (params ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(args [0]string, r *http.Request) (params ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type ListStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackListStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ListStorageV1beta1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1beta1NamespacedCSIStorageCapacityParams(args [1]string, r *http.Request) (params ListStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type LogFileHandlerParams struct {
	// Path to the log.
	Logpath string
}

func unpackLogFileHandlerParams(packed map[string]any) (params LogFileHandlerParams) {
	params.Logpath = packed["logpath"].(string)
	return params
}

func decodeLogFileHandlerParams(args [1]string, r *http.Request) (params LogFileHandlerParams, _ error) {
	// Decode path: logpath.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "logpath",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Logpath = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: logpath: parse")
			}
		} else {
			return params, errors.New("path: logpath: not specified")
		}
	}
	return params, nil
}

type ReadAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// Name of the MutatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params ReadAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAdmissionregistrationV1MutatingWebhookConfigurationParams(args [1]string, r *http.Request) (params ReadAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// Name of the ValidatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [1]string, r *http.Request) (params ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadApiextensionsV1CustomResourceDefinitionParams struct {
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params ReadApiextensionsV1CustomResourceDefinitionParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiextensionsV1CustomResourceDefinitionParams(args [1]string, r *http.Request) (params ReadApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadApiextensionsV1CustomResourceDefinitionStatusParams struct {
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadApiextensionsV1CustomResourceDefinitionStatusParams(packed map[string]any) (params ReadApiextensionsV1CustomResourceDefinitionStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiextensionsV1CustomResourceDefinitionStatusParams(args [1]string, r *http.Request) (params ReadApiextensionsV1CustomResourceDefinitionStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadApiregistrationV1APIServiceParams struct {
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadApiregistrationV1APIServiceParams(packed map[string]any) (params ReadApiregistrationV1APIServiceParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiregistrationV1APIServiceParams(args [1]string, r *http.Request) (params ReadApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadApiregistrationV1APIServiceStatusParams struct {
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadApiregistrationV1APIServiceStatusParams(packed map[string]any) (params ReadApiregistrationV1APIServiceStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiregistrationV1APIServiceStatusParams(args [1]string, r *http.Request) (params ReadApiregistrationV1APIServiceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedControllerRevisionParams struct {
	// Name of the ControllerRevision.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params ReadAppsV1NamespacedControllerRevisionParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedControllerRevisionParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedDaemonSetParams struct {
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedDaemonSetParams(packed map[string]any) (params ReadAppsV1NamespacedDaemonSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDaemonSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedDaemonSetStatusParams struct {
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedDaemonSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedDaemonSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDaemonSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDaemonSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedDeploymentParams struct {
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedDeploymentParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedDeploymentScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedDeploymentScaleParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedDeploymentStatusParams struct {
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedDeploymentStatusParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedReplicaSetParams struct {
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedReplicaSetParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedReplicaSetScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedReplicaSetScaleParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedReplicaSetStatusParams struct {
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedReplicaSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedStatefulSetParams struct {
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedStatefulSetParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedStatefulSetScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedStatefulSetScaleParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAppsV1NamespacedStatefulSetStatusParams struct {
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAppsV1NamespacedStatefulSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1NamespacedCronJobParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1NamespacedCronJobParams(packed map[string]any) (params ReadBatchV1NamespacedCronJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedCronJobParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1NamespacedCronJobStatusParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1NamespacedCronJobStatusParams(packed map[string]any) (params ReadBatchV1NamespacedCronJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedCronJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedCronJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1NamespacedJobParams struct {
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1NamespacedJobParams(packed map[string]any) (params ReadBatchV1NamespacedJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedJobParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1NamespacedJobStatusParams struct {
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1NamespacedJobStatusParams(packed map[string]any) (params ReadBatchV1NamespacedJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1beta1NamespacedCronJobParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params ReadBatchV1beta1NamespacedCronJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1beta1NamespacedCronJobParams(args [2]string, r *http.Request) (params ReadBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadBatchV1beta1NamespacedCronJobStatusParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadBatchV1beta1NamespacedCronJobStatusParams(packed map[string]any) (params ReadBatchV1beta1NamespacedCronJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1beta1NamespacedCronJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1beta1NamespacedCronJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCertificatesV1CertificateSigningRequestParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCertificatesV1CertificateSigningRequestApprovalParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCertificatesV1CertificateSigningRequestApprovalParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestApprovalParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestApprovalParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestApprovalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCertificatesV1CertificateSigningRequestStatusParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCertificatesV1CertificateSigningRequestStatusParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestStatusParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoordinationV1NamespacedLeaseParams struct {
	// Name of the Lease.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoordinationV1NamespacedLeaseParams(packed map[string]any) (params ReadCoordinationV1NamespacedLeaseParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoordinationV1NamespacedLeaseParams(args [2]string, r *http.Request) (params ReadCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1ComponentStatusParams struct {
	// Name of the ComponentStatus.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1ComponentStatusParams(packed map[string]any) (params ReadCoreV1ComponentStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1ComponentStatusParams(args [1]string, r *http.Request) (params ReadCoreV1ComponentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespaceParams struct {
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespaceParams(packed map[string]any) (params ReadCoreV1NamespaceParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespaceParams(args [1]string, r *http.Request) (params ReadCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespaceStatusParams struct {
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespaceStatusParams(packed map[string]any) (params ReadCoreV1NamespaceStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespaceStatusParams(args [1]string, r *http.Request) (params ReadCoreV1NamespaceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedConfigMapParams struct {
	// Name of the ConfigMap.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedConfigMapParams(packed map[string]any) (params ReadCoreV1NamespacedConfigMapParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedConfigMapParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedEndpointsParams struct {
	// Name of the Endpoints.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedEndpointsParams(packed map[string]any) (params ReadCoreV1NamespacedEndpointsParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedEndpointsParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedEventParams(packed map[string]any) (params ReadCoreV1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedEventParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedLimitRangeParams struct {
	// Name of the LimitRange.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedLimitRangeParams(packed map[string]any) (params ReadCoreV1NamespacedLimitRangeParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedLimitRangeParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPersistentVolumeClaimParams struct {
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params ReadCoreV1NamespacedPersistentVolumeClaimParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPersistentVolumeClaimParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPersistentVolumeClaimStatusParams struct {
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPersistentVolumeClaimStatusParams(packed map[string]any) (params ReadCoreV1NamespacedPersistentVolumeClaimStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPersistentVolumeClaimStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPersistentVolumeClaimStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPodParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPodParams(packed map[string]any) (params ReadCoreV1NamespacedPodParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPodEphemeralcontainersParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPodEphemeralcontainersParams(packed map[string]any) (params ReadCoreV1NamespacedPodEphemeralcontainersParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodEphemeralcontainersParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodEphemeralcontainersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPodLogParams struct {
	// The container for which to stream logs. Defaults to only container if there is one container in
	// the pod.
	Container OptString
	// Follow the log stream of the pod. Defaults to false.
	Follow OptBool
	// InsecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
	// serving certificate of the backend it is connecting to.  This will make the HTTPS connection
	// between the apiserver and the backend insecure. This means the apiserver cannot verify the log
	// data it is receiving came from the real kubelet.  If the kubelet is configured to verify the
	// apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to
	// a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from
	// the real kubelet).
	InsecureSkipTLSVerifyBackend OptBool
	// If set, the number of bytes to read from the server before terminating the log output. This may
	// not display a complete final line of logging, and may return slightly more or slightly less than
	// the specified limit.
	LimitBytes OptInt
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// Return previous terminated container logs. Defaults to false.
	Previous OptBool
	// A relative time in seconds before the current time from which to show logs. If this value precedes
	// the time a pod was started, only logs since the pod start will be returned. If this value is in
	// the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
	SinceSeconds OptInt
	// If set, the number of lines from the end of the logs to show. If not specified, logs are shown
	// from the creation of the container or sinceSeconds or sinceTime.
	TailLines OptInt
	// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output.
	// Defaults to false.
	Timestamps OptBool
}

func unpackReadCoreV1NamespacedPodLogParams(packed map[string]any) (params ReadCoreV1NamespacedPodLogParams) {
	if v, ok := packed["container"]; ok {
		params.Container = v.(OptString)
	}
	if v, ok := packed["follow"]; ok {
		params.Follow = v.(OptBool)
	}
	if v, ok := packed["insecureSkipTLSVerifyBackend"]; ok {
		params.InsecureSkipTLSVerifyBackend = v.(OptBool)
	}
	if v, ok := packed["limitBytes"]; ok {
		params.LimitBytes = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["previous"]; ok {
		params.Previous = v.(OptBool)
	}
	if v, ok := packed["sinceSeconds"]; ok {
		params.SinceSeconds = v.(OptInt)
	}
	if v, ok := packed["tailLines"]; ok {
		params.TailLines = v.(OptInt)
	}
	if v, ok := packed["timestamps"]; ok {
		params.Timestamps = v.(OptBool)
	}
	return params
}

func decodeReadCoreV1NamespacedPodLogParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: container.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "container",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContainerVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContainerVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Container.SetTo(paramsDotContainerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: container: parse")
			}
		}
	}
	// Decode query: follow.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "follow",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFollowVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFollowVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Follow.SetTo(paramsDotFollowVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: follow: parse")
			}
		}
	}
	// Decode query: insecureSkipTLSVerifyBackend.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "insecureSkipTLSVerifyBackend",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotInsecureSkipTLSVerifyBackendVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotInsecureSkipTLSVerifyBackendVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.InsecureSkipTLSVerifyBackend.SetTo(paramsDotInsecureSkipTLSVerifyBackendVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: insecureSkipTLSVerifyBackend: parse")
			}
		}
	}
	// Decode query: limitBytes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limitBytes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitBytesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitBytesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LimitBytes.SetTo(paramsDotLimitBytesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limitBytes: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: previous.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "previous",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPreviousVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotPreviousVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Previous.SetTo(paramsDotPreviousVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: previous: parse")
			}
		}
	}
	// Decode query: sinceSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sinceSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SinceSeconds.SetTo(paramsDotSinceSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sinceSeconds: parse")
			}
		}
	}
	// Decode query: tailLines.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tailLines",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTailLinesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTailLinesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TailLines.SetTo(paramsDotTailLinesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tailLines: parse")
			}
		}
	}
	// Decode query: timestamps.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamps",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotTimestampsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamps.SetTo(paramsDotTimestampsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timestamps: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPodStatusParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPodStatusParams(packed map[string]any) (params ReadCoreV1NamespacedPodStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedPodTemplateParams struct {
	// Name of the PodTemplate.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedPodTemplateParams(packed map[string]any) (params ReadCoreV1NamespacedPodTemplateParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodTemplateParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedReplicationControllerParams struct {
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedReplicationControllerScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedReplicationControllerScaleParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerScaleParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedReplicationControllerStatusParams struct {
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedReplicationControllerStatusParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedResourceQuotaParams struct {
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params ReadCoreV1NamespacedResourceQuotaParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedResourceQuotaParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedResourceQuotaStatusParams struct {
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedResourceQuotaStatusParams(packed map[string]any) (params ReadCoreV1NamespacedResourceQuotaStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedResourceQuotaStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedResourceQuotaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedSecretParams struct {
	// Name of the Secret.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedSecretParams(packed map[string]any) (params ReadCoreV1NamespacedSecretParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedSecretParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedServiceParams struct {
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedServiceParams(packed map[string]any) (params ReadCoreV1NamespacedServiceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedServiceAccountParams struct {
	// Name of the ServiceAccount.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedServiceAccountParams(packed map[string]any) (params ReadCoreV1NamespacedServiceAccountParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceAccountParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NamespacedServiceStatusParams struct {
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NamespacedServiceStatusParams(packed map[string]any) (params ReadCoreV1NamespacedServiceStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NodeParams struct {
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NodeParams(packed map[string]any) (params ReadCoreV1NodeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NodeParams(args [1]string, r *http.Request) (params ReadCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1NodeStatusParams struct {
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1NodeStatusParams(packed map[string]any) (params ReadCoreV1NodeStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NodeStatusParams(args [1]string, r *http.Request) (params ReadCoreV1NodeStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1PersistentVolumeParams struct {
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1PersistentVolumeParams(packed map[string]any) (params ReadCoreV1PersistentVolumeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1PersistentVolumeParams(args [1]string, r *http.Request) (params ReadCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadCoreV1PersistentVolumeStatusParams struct {
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadCoreV1PersistentVolumeStatusParams(packed map[string]any) (params ReadCoreV1PersistentVolumeStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1PersistentVolumeStatusParams(args [1]string, r *http.Request) (params ReadCoreV1PersistentVolumeStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadDiscoveryV1NamespacedEndpointSliceParams struct {
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params ReadDiscoveryV1NamespacedEndpointSliceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadDiscoveryV1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params ReadDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params ReadDiscoveryV1beta1NamespacedEndpointSliceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadDiscoveryV1beta1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params ReadDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadEventsV1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadEventsV1NamespacedEventParams(packed map[string]any) (params ReadEventsV1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadEventsV1NamespacedEventParams(args [2]string, r *http.Request) (params ReadEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadEventsV1beta1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadEventsV1beta1NamespacedEventParams(packed map[string]any) (params ReadEventsV1beta1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadEventsV1beta1NamespacedEventParams(args [2]string, r *http.Request) (params ReadEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1FlowSchemaParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1FlowSchemaParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2FlowSchemaParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2FlowSchemaParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadInternalApiserverV1alpha1StorageVersionParams struct {
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params ReadInternalApiserverV1alpha1StorageVersionParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadInternalApiserverV1alpha1StorageVersionParams(args [1]string, r *http.Request) (params ReadInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadInternalApiserverV1alpha1StorageVersionStatusParams struct {
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadInternalApiserverV1alpha1StorageVersionStatusParams(packed map[string]any) (params ReadInternalApiserverV1alpha1StorageVersionStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadInternalApiserverV1alpha1StorageVersionStatusParams(args [1]string, r *http.Request) (params ReadInternalApiserverV1alpha1StorageVersionStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNetworkingV1IngressClassParams struct {
	// Name of the IngressClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNetworkingV1IngressClassParams(packed map[string]any) (params ReadNetworkingV1IngressClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1IngressClassParams(args [1]string, r *http.Request) (params ReadNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNetworkingV1NamespacedIngressParams struct {
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNetworkingV1NamespacedIngressParams(packed map[string]any) (params ReadNetworkingV1NamespacedIngressParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedIngressParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNetworkingV1NamespacedIngressStatusParams struct {
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNetworkingV1NamespacedIngressStatusParams(packed map[string]any) (params ReadNetworkingV1NamespacedIngressStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedIngressStatusParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedIngressStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNetworkingV1NamespacedNetworkPolicyParams struct {
	// Name of the NetworkPolicy.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params ReadNetworkingV1NamespacedNetworkPolicyParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedNetworkPolicyParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNodeV1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNodeV1RuntimeClassParams(packed map[string]any) (params ReadNodeV1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNodeV1alpha1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNodeV1alpha1RuntimeClassParams(packed map[string]any) (params ReadNodeV1alpha1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1alpha1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadNodeV1beta1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadNodeV1beta1RuntimeClassParams(packed map[string]any) (params ReadNodeV1beta1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1beta1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ReadPolicyV1NamespacedPodDisruptionBudgetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params ReadPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(packed map[string]any) (params ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(args [2]string, r *http.Request) (params ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(packed map[string]any) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(args [2]string, r *http.Request) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadPolicyV1beta1PodSecurityPolicyParams struct {
	// Name of the PodSecurityPolicy.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params ReadPolicyV1beta1PodSecurityPolicyParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1PodSecurityPolicyParams(args [1]string, r *http.Request) (params ReadPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadRbacAuthorizationV1ClusterRoleParams struct {
	// Name of the ClusterRole.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params ReadRbacAuthorizationV1ClusterRoleParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1ClusterRoleParams(args [1]string, r *http.Request) (params ReadRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadRbacAuthorizationV1ClusterRoleBindingParams struct {
	// Name of the ClusterRoleBinding.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params ReadRbacAuthorizationV1ClusterRoleBindingParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1ClusterRoleBindingParams(args [1]string, r *http.Request) (params ReadRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadRbacAuthorizationV1NamespacedRoleParams struct {
	// Name of the Role.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params ReadRbacAuthorizationV1NamespacedRoleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1NamespacedRoleParams(args [2]string, r *http.Request) (params ReadRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// Name of the RoleBinding.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params ReadRbacAuthorizationV1NamespacedRoleBindingParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1NamespacedRoleBindingParams(args [2]string, r *http.Request) (params ReadRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadSchedulingV1PriorityClassParams struct {
	// Name of the PriorityClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadSchedulingV1PriorityClassParams(packed map[string]any) (params ReadSchedulingV1PriorityClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadSchedulingV1PriorityClassParams(args [1]string, r *http.Request) (params ReadSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1CSIDriverParams struct {
	// Name of the CSIDriver.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1CSIDriverParams(packed map[string]any) (params ReadStorageV1CSIDriverParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1CSIDriverParams(args [1]string, r *http.Request) (params ReadStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1CSINodeParams struct {
	// Name of the CSINode.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1CSINodeParams(packed map[string]any) (params ReadStorageV1CSINodeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1CSINodeParams(args [1]string, r *http.Request) (params ReadStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1StorageClassParams struct {
	// Name of the StorageClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1StorageClassParams(packed map[string]any) (params ReadStorageV1StorageClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1StorageClassParams(args [1]string, r *http.Request) (params ReadStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1VolumeAttachmentParams struct {
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1VolumeAttachmentParams(packed map[string]any) (params ReadStorageV1VolumeAttachmentParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1VolumeAttachmentParams(args [1]string, r *http.Request) (params ReadStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1VolumeAttachmentStatusParams struct {
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1VolumeAttachmentStatusParams(packed map[string]any) (params ReadStorageV1VolumeAttachmentStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1VolumeAttachmentStatusParams(args [1]string, r *http.Request) (params ReadStorageV1VolumeAttachmentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ReadStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1alpha1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params ReadStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type ReadStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
}

func unpackReadStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ReadStorageV1beta1NamespacedCSIStorageCapacityParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1beta1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params ReadStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

type WatchAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the MutatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(args [1]string, r *http.Request) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(packed map[string]any) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(args [0]string, r *http.Request) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ValidatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [1]string, r *http.Request) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(packed map[string]any) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(args [0]string, r *http.Request) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchApiextensionsV1CustomResourceDefinitionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params WatchApiextensionsV1CustomResourceDefinitionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiextensionsV1CustomResourceDefinitionParams(args [1]string, r *http.Request) (params WatchApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchApiextensionsV1CustomResourceDefinitionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchApiextensionsV1CustomResourceDefinitionListParams(packed map[string]any) (params WatchApiextensionsV1CustomResourceDefinitionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiextensionsV1CustomResourceDefinitionListParams(args [0]string, r *http.Request) (params WatchApiextensionsV1CustomResourceDefinitionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchApiregistrationV1APIServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchApiregistrationV1APIServiceParams(packed map[string]any) (params WatchApiregistrationV1APIServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiregistrationV1APIServiceParams(args [1]string, r *http.Request) (params WatchApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchApiregistrationV1APIServiceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchApiregistrationV1APIServiceListParams(packed map[string]any) (params WatchApiregistrationV1APIServiceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiregistrationV1APIServiceListParams(args [0]string, r *http.Request) (params WatchApiregistrationV1APIServiceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1ControllerRevisionListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1ControllerRevisionListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1ControllerRevisionListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1ControllerRevisionListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1ControllerRevisionListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1DaemonSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1DaemonSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1DaemonSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1DaemonSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1DaemonSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1DeploymentListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1DeploymentListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1DeploymentListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1DeploymentListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1DeploymentListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedControllerRevisionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ControllerRevision.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params WatchAppsV1NamespacedControllerRevisionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedControllerRevisionParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedControllerRevisionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedControllerRevisionListParams(packed map[string]any) (params WatchAppsV1NamespacedControllerRevisionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedControllerRevisionListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedControllerRevisionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedDaemonSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedDaemonSetParams(packed map[string]any) (params WatchAppsV1NamespacedDaemonSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDaemonSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedDaemonSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedDaemonSetListParams(packed map[string]any) (params WatchAppsV1NamespacedDaemonSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDaemonSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedDaemonSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedDeploymentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedDeploymentParams(packed map[string]any) (params WatchAppsV1NamespacedDeploymentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDeploymentParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedDeploymentListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedDeploymentListParams(packed map[string]any) (params WatchAppsV1NamespacedDeploymentListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDeploymentListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedDeploymentListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedReplicaSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedReplicaSetParams(packed map[string]any) (params WatchAppsV1NamespacedReplicaSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedReplicaSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedReplicaSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedReplicaSetListParams(packed map[string]any) (params WatchAppsV1NamespacedReplicaSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedReplicaSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedReplicaSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedStatefulSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedStatefulSetParams(packed map[string]any) (params WatchAppsV1NamespacedStatefulSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedStatefulSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1NamespacedStatefulSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1NamespacedStatefulSetListParams(packed map[string]any) (params WatchAppsV1NamespacedStatefulSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedStatefulSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedStatefulSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1ReplicaSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1ReplicaSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1ReplicaSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1ReplicaSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1ReplicaSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAppsV1StatefulSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAppsV1StatefulSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1StatefulSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1StatefulSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1StatefulSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1CronJobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1CronJobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1CronJobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1CronJobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1CronJobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1JobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1JobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1JobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1JobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1JobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1NamespacedCronJobParams(packed map[string]any) (params WatchBatchV1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedCronJobParams(args [2]string, r *http.Request) (params WatchBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1NamespacedCronJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1NamespacedCronJobListParams(packed map[string]any) (params WatchBatchV1NamespacedCronJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedCronJobListParams(args [1]string, r *http.Request) (params WatchBatchV1NamespacedCronJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1NamespacedJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1NamespacedJobParams(packed map[string]any) (params WatchBatchV1NamespacedJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedJobParams(args [2]string, r *http.Request) (params WatchBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1NamespacedJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1NamespacedJobListParams(packed map[string]any) (params WatchBatchV1NamespacedJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedJobListParams(args [1]string, r *http.Request) (params WatchBatchV1NamespacedJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1beta1CronJobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1beta1CronJobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1beta1CronJobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1CronJobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1beta1CronJobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1beta1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params WatchBatchV1beta1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1NamespacedCronJobParams(args [2]string, r *http.Request) (params WatchBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchBatchV1beta1NamespacedCronJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchBatchV1beta1NamespacedCronJobListParams(packed map[string]any) (params WatchBatchV1beta1NamespacedCronJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1NamespacedCronJobListParams(args [1]string, r *http.Request) (params WatchBatchV1beta1NamespacedCronJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCertificatesV1CertificateSigningRequestParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params WatchCertificatesV1CertificateSigningRequestParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCertificatesV1CertificateSigningRequestParams(args [1]string, r *http.Request) (params WatchCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCertificatesV1CertificateSigningRequestListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCertificatesV1CertificateSigningRequestListParams(packed map[string]any) (params WatchCertificatesV1CertificateSigningRequestListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCertificatesV1CertificateSigningRequestListParams(args [0]string, r *http.Request) (params WatchCertificatesV1CertificateSigningRequestListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoordinationV1LeaseListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoordinationV1LeaseListForAllNamespacesParams(packed map[string]any) (params WatchCoordinationV1LeaseListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1LeaseListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoordinationV1LeaseListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoordinationV1NamespacedLeaseParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Lease.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoordinationV1NamespacedLeaseParams(packed map[string]any) (params WatchCoordinationV1NamespacedLeaseParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1NamespacedLeaseParams(args [2]string, r *http.Request) (params WatchCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoordinationV1NamespacedLeaseListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoordinationV1NamespacedLeaseListParams(packed map[string]any) (params WatchCoordinationV1NamespacedLeaseListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1NamespacedLeaseListParams(args [1]string, r *http.Request) (params WatchCoordinationV1NamespacedLeaseListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1ConfigMapListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1ConfigMapListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ConfigMapListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ConfigMapListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ConfigMapListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1EndpointsListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1EndpointsListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1EndpointsListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1EndpointsListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1EndpointsListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1EventListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1LimitRangeListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1LimitRangeListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1LimitRangeListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1LimitRangeListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1LimitRangeListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespaceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespaceParams(packed map[string]any) (params WatchCoreV1NamespaceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespaceParams(args [1]string, r *http.Request) (params WatchCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespaceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespaceListParams(packed map[string]any) (params WatchCoreV1NamespaceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespaceListParams(args [0]string, r *http.Request) (params WatchCoreV1NamespaceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedConfigMapParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ConfigMap.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedConfigMapParams(packed map[string]any) (params WatchCoreV1NamespacedConfigMapParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedConfigMapParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedConfigMapListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedConfigMapListParams(packed map[string]any) (params WatchCoreV1NamespacedConfigMapListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedConfigMapListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedConfigMapListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedEndpointsParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Endpoints.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedEndpointsParams(packed map[string]any) (params WatchCoreV1NamespacedEndpointsParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEndpointsParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedEndpointsListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedEndpointsListParams(packed map[string]any) (params WatchCoreV1NamespacedEndpointsListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEndpointsListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedEndpointsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedEventParams(packed map[string]any) (params WatchCoreV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEventParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedEventListParams(packed map[string]any) (params WatchCoreV1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedLimitRangeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the LimitRange.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedLimitRangeParams(packed map[string]any) (params WatchCoreV1NamespacedLimitRangeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedLimitRangeParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedLimitRangeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedLimitRangeListParams(packed map[string]any) (params WatchCoreV1NamespacedLimitRangeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedLimitRangeListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedLimitRangeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPersistentVolumeClaimParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params WatchCoreV1NamespacedPersistentVolumeClaimParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPersistentVolumeClaimParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPersistentVolumeClaimListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPersistentVolumeClaimListParams(packed map[string]any) (params WatchCoreV1NamespacedPersistentVolumeClaimListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPersistentVolumeClaimListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPersistentVolumeClaimListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPodParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPodParams(packed map[string]any) (params WatchCoreV1NamespacedPodParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPodListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPodListParams(packed map[string]any) (params WatchCoreV1NamespacedPodListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPodListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPodTemplateParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PodTemplate.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPodTemplateParams(packed map[string]any) (params WatchCoreV1NamespacedPodTemplateParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodTemplateParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedPodTemplateListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedPodTemplateListParams(packed map[string]any) (params WatchCoreV1NamespacedPodTemplateListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodTemplateListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPodTemplateListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedReplicationControllerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params WatchCoreV1NamespacedReplicationControllerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedReplicationControllerParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedReplicationControllerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedReplicationControllerListParams(packed map[string]any) (params WatchCoreV1NamespacedReplicationControllerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedReplicationControllerListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedReplicationControllerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedResourceQuotaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params WatchCoreV1NamespacedResourceQuotaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedResourceQuotaParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedResourceQuotaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedResourceQuotaListParams(packed map[string]any) (params WatchCoreV1NamespacedResourceQuotaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedResourceQuotaListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedResourceQuotaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedSecretParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Secret.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedSecretParams(packed map[string]any) (params WatchCoreV1NamespacedSecretParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedSecretParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedSecretListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedSecretListParams(packed map[string]any) (params WatchCoreV1NamespacedSecretListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedSecretListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedSecretListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedServiceParams(packed map[string]any) (params WatchCoreV1NamespacedServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedServiceAccountParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ServiceAccount.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedServiceAccountParams(packed map[string]any) (params WatchCoreV1NamespacedServiceAccountParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceAccountParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedServiceAccountListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedServiceAccountListParams(packed map[string]any) (params WatchCoreV1NamespacedServiceAccountListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceAccountListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedServiceAccountListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NamespacedServiceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NamespacedServiceListParams(packed map[string]any) (params WatchCoreV1NamespacedServiceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedServiceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NodeParams(packed map[string]any) (params WatchCoreV1NodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NodeParams(args [1]string, r *http.Request) (params WatchCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1NodeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1NodeListParams(packed map[string]any) (params WatchCoreV1NodeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NodeListParams(args [0]string, r *http.Request) (params WatchCoreV1NodeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1PersistentVolumeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1PersistentVolumeParams(packed map[string]any) (params WatchCoreV1PersistentVolumeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeParams(args [1]string, r *http.Request) (params WatchCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1PersistentVolumeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1PersistentVolumeListParams(packed map[string]any) (params WatchCoreV1PersistentVolumeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeListParams(args [0]string, r *http.Request) (params WatchCoreV1PersistentVolumeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1PodListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1PodListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PodListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PodListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PodListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1PodTemplateListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1PodTemplateListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PodTemplateListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PodTemplateListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PodTemplateListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1ReplicationControllerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1ReplicationControllerListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ReplicationControllerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ReplicationControllerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ReplicationControllerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1ResourceQuotaListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1ResourceQuotaListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ResourceQuotaListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ResourceQuotaListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ResourceQuotaListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1SecretListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1SecretListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1SecretListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1SecretListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1SecretListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1ServiceAccountListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1ServiceAccountListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ServiceAccountListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ServiceAccountListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ServiceAccountListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchCoreV1ServiceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchCoreV1ServiceListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ServiceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ServiceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ServiceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1EndpointSliceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(packed map[string]any) (params WatchDiscoveryV1EndpointSliceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchDiscoveryV1EndpointSliceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params WatchDiscoveryV1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params WatchDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1NamespacedEndpointSliceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1NamespacedEndpointSliceListParams(packed map[string]any) (params WatchDiscoveryV1NamespacedEndpointSliceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1NamespacedEndpointSliceListParams(args [1]string, r *http.Request) (params WatchDiscoveryV1NamespacedEndpointSliceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(packed map[string]any) (params WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params WatchDiscoveryV1beta1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params WatchDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchDiscoveryV1beta1NamespacedEndpointSliceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(packed map[string]any) (params WatchDiscoveryV1beta1NamespacedEndpointSliceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(args [1]string, r *http.Request) (params WatchDiscoveryV1beta1NamespacedEndpointSliceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1EventListForAllNamespacesParams(packed map[string]any) (params WatchEventsV1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchEventsV1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1NamespacedEventParams(packed map[string]any) (params WatchEventsV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1NamespacedEventParams(args [2]string, r *http.Request) (params WatchEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1NamespacedEventListParams(packed map[string]any) (params WatchEventsV1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchEventsV1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1beta1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1beta1EventListForAllNamespacesParams(packed map[string]any) (params WatchEventsV1beta1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchEventsV1beta1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1beta1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1beta1NamespacedEventParams(packed map[string]any) (params WatchEventsV1beta1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1NamespacedEventParams(args [2]string, r *http.Request) (params WatchEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchEventsV1beta1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchEventsV1beta1NamespacedEventListParams(packed map[string]any) (params WatchEventsV1beta1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchEventsV1beta1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1FlowSchemaParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta1FlowSchemaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1FlowSchemaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1FlowSchemaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2FlowSchemaParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta2FlowSchemaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2FlowSchemaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2FlowSchemaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchInternalApiserverV1alpha1StorageVersionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params WatchInternalApiserverV1alpha1StorageVersionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchInternalApiserverV1alpha1StorageVersionParams(args [1]string, r *http.Request) (params WatchInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchInternalApiserverV1alpha1StorageVersionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchInternalApiserverV1alpha1StorageVersionListParams(packed map[string]any) (params WatchInternalApiserverV1alpha1StorageVersionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchInternalApiserverV1alpha1StorageVersionListParams(args [0]string, r *http.Request) (params WatchInternalApiserverV1alpha1StorageVersionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1IngressClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the IngressClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1IngressClassParams(packed map[string]any) (params WatchNetworkingV1IngressClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressClassParams(args [1]string, r *http.Request) (params WatchNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1IngressClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1IngressClassListParams(packed map[string]any) (params WatchNetworkingV1IngressClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressClassListParams(args [0]string, r *http.Request) (params WatchNetworkingV1IngressClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1IngressListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1IngressListForAllNamespacesParams(packed map[string]any) (params WatchNetworkingV1IngressListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchNetworkingV1IngressListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1NamespacedIngressParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1NamespacedIngressParams(packed map[string]any) (params WatchNetworkingV1NamespacedIngressParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedIngressParams(args [2]string, r *http.Request) (params WatchNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1NamespacedIngressListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1NamespacedIngressListParams(packed map[string]any) (params WatchNetworkingV1NamespacedIngressListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedIngressListParams(args [1]string, r *http.Request) (params WatchNetworkingV1NamespacedIngressListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1NamespacedNetworkPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the NetworkPolicy.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params WatchNetworkingV1NamespacedNetworkPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedNetworkPolicyParams(args [2]string, r *http.Request) (params WatchNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1NamespacedNetworkPolicyListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1NamespacedNetworkPolicyListParams(packed map[string]any) (params WatchNetworkingV1NamespacedNetworkPolicyListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedNetworkPolicyListParams(args [1]string, r *http.Request) (params WatchNetworkingV1NamespacedNetworkPolicyListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNetworkingV1NetworkPolicyListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(packed map[string]any) (params WatchNetworkingV1NetworkPolicyListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchNetworkingV1NetworkPolicyListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1RuntimeClassParams(packed map[string]any) (params WatchNodeV1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1alpha1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1alpha1RuntimeClassParams(packed map[string]any) (params WatchNodeV1alpha1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1alpha1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1alpha1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1alpha1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1alpha1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1alpha1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1alpha1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1beta1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1beta1RuntimeClassParams(packed map[string]any) (params WatchNodeV1beta1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1beta1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchNodeV1beta1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchNodeV1beta1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1beta1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1beta1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1beta1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params WatchPolicyV1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params WatchPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1NamespacedPodDisruptionBudgetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1NamespacedPodDisruptionBudgetListParams(packed map[string]any) (params WatchPolicyV1NamespacedPodDisruptionBudgetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1NamespacedPodDisruptionBudgetListParams(args [1]string, r *http.Request) (params WatchPolicyV1NamespacedPodDisruptionBudgetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(packed map[string]any) (params WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(packed map[string]any) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(args [1]string, r *http.Request) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(packed map[string]any) (params WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1beta1PodSecurityPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PodSecurityPolicy.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params WatchPolicyV1beta1PodSecurityPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodSecurityPolicyParams(args [1]string, r *http.Request) (params WatchPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchPolicyV1beta1PodSecurityPolicyListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchPolicyV1beta1PodSecurityPolicyListParams(packed map[string]any) (params WatchPolicyV1beta1PodSecurityPolicyListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodSecurityPolicyListParams(args [0]string, r *http.Request) (params WatchPolicyV1beta1PodSecurityPolicyListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1ClusterRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ClusterRole.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1ClusterRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the ClusterRoleBinding.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleBindingParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1ClusterRoleBindingListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1ClusterRoleBindingListParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleBindingListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleBindingListParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleBindingListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1ClusterRoleListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1ClusterRoleListParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleListParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1NamespacedRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the Role.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleParams(args [2]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the RoleBinding.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleBindingParams(args [2]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1NamespacedRoleBindingListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1NamespacedRoleBindingListParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleBindingListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleBindingListParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleBindingListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1NamespacedRoleListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1NamespacedRoleListParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleListParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(packed map[string]any) (params WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchRbacAuthorizationV1RoleListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchRbacAuthorizationV1RoleListForAllNamespacesParams(packed map[string]any) (params WatchRbacAuthorizationV1RoleListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1RoleListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1RoleListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchSchedulingV1PriorityClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the PriorityClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchSchedulingV1PriorityClassParams(packed map[string]any) (params WatchSchedulingV1PriorityClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchSchedulingV1PriorityClassParams(args [1]string, r *http.Request) (params WatchSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchSchedulingV1PriorityClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchSchedulingV1PriorityClassListParams(packed map[string]any) (params WatchSchedulingV1PriorityClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchSchedulingV1PriorityClassListParams(args [0]string, r *http.Request) (params WatchSchedulingV1PriorityClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1CSIDriverParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CSIDriver.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1CSIDriverParams(packed map[string]any) (params WatchStorageV1CSIDriverParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSIDriverParams(args [1]string, r *http.Request) (params WatchStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1CSIDriverListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1CSIDriverListParams(packed map[string]any) (params WatchStorageV1CSIDriverListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSIDriverListParams(args [0]string, r *http.Request) (params WatchStorageV1CSIDriverListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1CSINodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CSINode.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1CSINodeParams(packed map[string]any) (params WatchStorageV1CSINodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSINodeParams(args [1]string, r *http.Request) (params WatchStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1CSINodeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1CSINodeListParams(packed map[string]any) (params WatchStorageV1CSINodeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSINodeListParams(args [0]string, r *http.Request) (params WatchStorageV1CSINodeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1StorageClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the StorageClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1StorageClassParams(packed map[string]any) (params WatchStorageV1StorageClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1StorageClassParams(args [1]string, r *http.Request) (params WatchStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1StorageClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1StorageClassListParams(packed map[string]any) (params WatchStorageV1StorageClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1StorageClassListParams(args [0]string, r *http.Request) (params WatchStorageV1StorageClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1VolumeAttachmentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1VolumeAttachmentParams(packed map[string]any) (params WatchStorageV1VolumeAttachmentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1VolumeAttachmentParams(args [1]string, r *http.Request) (params WatchStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1VolumeAttachmentListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1VolumeAttachmentListParams(packed map[string]any) (params WatchStorageV1VolumeAttachmentListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1VolumeAttachmentListParams(args [0]string, r *http.Request) (params WatchStorageV1VolumeAttachmentListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(packed map[string]any) (params WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(packed map[string]any) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(args [1]string, r *http.Request) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(packed map[string]any) (params WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params WatchStorageV1beta1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params WatchStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

type WatchStorageV1beta1NamespacedCSIStorageCapacityListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool
}

func unpackWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(packed map[string]any) (params WatchStorageV1beta1NamespacedCSIStorageCapacityListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(args [1]string, r *http.Request) (params WatchStorageV1beta1NamespacedCSIStorageCapacityListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}
