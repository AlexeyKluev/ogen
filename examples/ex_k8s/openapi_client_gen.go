// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/json"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
)

type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

type Client struct {
	serverURL string
	http      HTTPClient
}

func NewClient(serverURL string) *Client {
	return &Client{
		serverURL: serverURL,
		http: &http.Client{
			Timeout: time.Second * 15,
		},
	}
}

func (c *Client) GetServiceAccountIssuerOpenIDConfiguration(ctx context.Context) (_ GetServiceAccountIssuerOpenIDConfigurationResponse, rerr error) {
	path := c.serverURL
	path += "/.well-known"
	path += "/openid-configuration"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceAccountIssuerOpenIDConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCoreAPIVersions(ctx context.Context) (_ GetCoreAPIVersionsResponse, rerr error) {
	path := c.serverURL
	path += "/api"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCoreAPIVersionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCoreV1APIResources(ctx context.Context) (_ GetCoreV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCoreV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ComponentStatus(ctx context.Context) (_ ListCoreV1ComponentStatusResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/componentstatuses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ComponentStatusResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ConfigMapForAllNamespaces(ctx context.Context) (_ ListCoreV1ConfigMapForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/configmaps"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ConfigMapForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1EndpointsForAllNamespaces(ctx context.Context) (_ ListCoreV1EndpointsForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/endpoints"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1EndpointsForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1EventForAllNamespaces(ctx context.Context) (_ ListCoreV1EventForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1EventForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1LimitRangeForAllNamespaces(ctx context.Context) (_ ListCoreV1LimitRangeForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/limitranges"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1LimitRangeForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1Namespace(ctx context.Context, params ListCoreV1NamespaceParams) (_ ListCoreV1NamespaceResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/namespaces"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1NamespaceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateCoreV1Namespace(ctx context.Context, req IoK8sAPICoreV1Namespace, params CreateCoreV1NamespaceParams) (_ CreateCoreV1NamespaceResponse, rerr error) {
	body, contentType, err := encodeCreateCoreV1NamespaceRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/namespaces"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateCoreV1NamespaceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1Node(ctx context.Context, params ListCoreV1NodeParams) (_ ListCoreV1NodeResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/nodes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1NodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateCoreV1Node(ctx context.Context, req IoK8sAPICoreV1Node, params CreateCoreV1NodeParams) (_ CreateCoreV1NodeResponse, rerr error) {
	body, contentType, err := encodeCreateCoreV1NodeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/nodes"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateCoreV1NodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteCoreV1CollectionNode(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteCoreV1CollectionNodeParams) (_ DeleteCoreV1CollectionNodeResponse, rerr error) {
	body, contentType, err := encodeDeleteCoreV1CollectionNodeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/nodes"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCoreV1CollectionNodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx context.Context) (_ ListCoreV1PersistentVolumeClaimForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/persistentvolumeclaims"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1PersistentVolumeClaimForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1PersistentVolume(ctx context.Context, params ListCoreV1PersistentVolumeParams) (_ ListCoreV1PersistentVolumeResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/persistentvolumes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1PersistentVolumeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateCoreV1PersistentVolume(ctx context.Context, req IoK8sAPICoreV1PersistentVolume, params CreateCoreV1PersistentVolumeParams) (_ CreateCoreV1PersistentVolumeResponse, rerr error) {
	body, contentType, err := encodeCreateCoreV1PersistentVolumeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/persistentvolumes"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateCoreV1PersistentVolumeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteCoreV1CollectionPersistentVolume(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteCoreV1CollectionPersistentVolumeParams) (_ DeleteCoreV1CollectionPersistentVolumeResponse, rerr error) {
	body, contentType, err := encodeDeleteCoreV1CollectionPersistentVolumeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/persistentvolumes"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCoreV1CollectionPersistentVolumeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1PodForAllNamespaces(ctx context.Context) (_ ListCoreV1PodForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/pods"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1PodForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1PodTemplateForAllNamespaces(ctx context.Context) (_ ListCoreV1PodTemplateForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/podtemplates"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1PodTemplateForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ReplicationControllerForAllNamespaces(ctx context.Context) (_ ListCoreV1ReplicationControllerForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/replicationcontrollers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ReplicationControllerForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ResourceQuotaForAllNamespaces(ctx context.Context) (_ ListCoreV1ResourceQuotaForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/resourcequotas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ResourceQuotaForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1SecretForAllNamespaces(ctx context.Context) (_ ListCoreV1SecretForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1SecretForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ServiceAccountForAllNamespaces(ctx context.Context) (_ ListCoreV1ServiceAccountForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/serviceaccounts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ServiceAccountForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoreV1ServiceForAllNamespaces(ctx context.Context) (_ ListCoreV1ServiceForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/services"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoreV1ServiceForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1ConfigMapListForAllNamespaces(ctx context.Context) (_ WatchCoreV1ConfigMapListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/configmaps"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1ConfigMapListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1EndpointsListForAllNamespaces(ctx context.Context) (_ WatchCoreV1EndpointsListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/endpoints"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1EndpointsListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1EventListForAllNamespaces(ctx context.Context) (_ WatchCoreV1EventListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1EventListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1LimitRangeListForAllNamespaces(ctx context.Context) (_ WatchCoreV1LimitRangeListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/limitranges"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1LimitRangeListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1NamespaceList(ctx context.Context) (_ WatchCoreV1NamespaceListResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/namespaces"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1NamespaceListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1NodeList(ctx context.Context) (_ WatchCoreV1NodeListResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/nodes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1NodeListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx context.Context) (_ WatchCoreV1PersistentVolumeClaimListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/persistentvolumeclaims"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1PersistentVolumeList(ctx context.Context) (_ WatchCoreV1PersistentVolumeListResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/persistentvolumes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1PersistentVolumeListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1PodListForAllNamespaces(ctx context.Context) (_ WatchCoreV1PodListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/pods"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1PodListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1PodTemplateListForAllNamespaces(ctx context.Context) (_ WatchCoreV1PodTemplateListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/podtemplates"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1PodTemplateListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1ReplicationControllerListForAllNamespaces(ctx context.Context) (_ WatchCoreV1ReplicationControllerListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/replicationcontrollers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1ReplicationControllerListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1ResourceQuotaListForAllNamespaces(ctx context.Context) (_ WatchCoreV1ResourceQuotaListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/resourcequotas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1ResourceQuotaListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1SecretListForAllNamespaces(ctx context.Context) (_ WatchCoreV1SecretListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1SecretListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1ServiceAccountListForAllNamespaces(ctx context.Context) (_ WatchCoreV1ServiceAccountListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/serviceaccounts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1ServiceAccountListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoreV1ServiceListForAllNamespaces(ctx context.Context) (_ WatchCoreV1ServiceListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/api"
	path += "/v1"
	path += "/watch"
	path += "/services"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoreV1ServiceListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAPIVersions(ctx context.Context) (_ GetAPIVersionsResponse, rerr error) {
	path := c.serverURL
	path += "/apis"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAPIVersionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAdmissionregistrationAPIGroup(ctx context.Context) (_ GetAdmissionregistrationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAdmissionregistrationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAdmissionregistrationV1APIResources(ctx context.Context) (_ GetAdmissionregistrationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAdmissionregistrationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx context.Context, params ListAdmissionregistrationV1MutatingWebhookConfigurationParams) (_ ListAdmissionregistrationV1MutatingWebhookConfigurationResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/mutatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAdmissionregistrationV1MutatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAdmissionregistrationV1MutatingWebhookConfiguration(ctx context.Context, req IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration, params CreateAdmissionregistrationV1MutatingWebhookConfigurationParams) (_ CreateAdmissionregistrationV1MutatingWebhookConfigurationResponse, rerr error) {
	body, contentType, err := encodeCreateAdmissionregistrationV1MutatingWebhookConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/mutatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAdmissionregistrationV1MutatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationParams) (_ DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationResponse, rerr error) {
	body, contentType, err := encodeDeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/mutatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx context.Context, params ListAdmissionregistrationV1ValidatingWebhookConfigurationParams) (_ ListAdmissionregistrationV1ValidatingWebhookConfigurationResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/validatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAdmissionregistrationV1ValidatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAdmissionregistrationV1ValidatingWebhookConfiguration(ctx context.Context, req IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration, params CreateAdmissionregistrationV1ValidatingWebhookConfigurationParams) (_ CreateAdmissionregistrationV1ValidatingWebhookConfigurationResponse, rerr error) {
	body, contentType, err := encodeCreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/validatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAdmissionregistrationV1ValidatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationParams) (_ DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationResponse, rerr error) {
	body, contentType, err := encodeDeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/validatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx context.Context) (_ WatchAdmissionregistrationV1MutatingWebhookConfigurationListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/mutatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx context.Context) (_ WatchAdmissionregistrationV1ValidatingWebhookConfigurationListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/admissionregistration.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/validatingwebhookconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetApiextensionsAPIGroup(ctx context.Context) (_ GetApiextensionsAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetApiextensionsAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetApiextensionsV1APIResources(ctx context.Context) (_ GetApiextensionsV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetApiextensionsV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListApiextensionsV1CustomResourceDefinition(ctx context.Context, params ListApiextensionsV1CustomResourceDefinitionParams) (_ ListApiextensionsV1CustomResourceDefinitionResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"
	path += "/v1"
	path += "/customresourcedefinitions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListApiextensionsV1CustomResourceDefinitionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateApiextensionsV1CustomResourceDefinition(ctx context.Context, req IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition, params CreateApiextensionsV1CustomResourceDefinitionParams) (_ CreateApiextensionsV1CustomResourceDefinitionResponse, rerr error) {
	body, contentType, err := encodeCreateApiextensionsV1CustomResourceDefinitionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"
	path += "/v1"
	path += "/customresourcedefinitions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateApiextensionsV1CustomResourceDefinitionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteApiextensionsV1CollectionCustomResourceDefinition(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteApiextensionsV1CollectionCustomResourceDefinitionParams) (_ DeleteApiextensionsV1CollectionCustomResourceDefinitionResponse, rerr error) {
	body, contentType, err := encodeDeleteApiextensionsV1CollectionCustomResourceDefinitionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"
	path += "/v1"
	path += "/customresourcedefinitions"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteApiextensionsV1CollectionCustomResourceDefinitionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchApiextensionsV1CustomResourceDefinitionList(ctx context.Context) (_ WatchApiextensionsV1CustomResourceDefinitionListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiextensions.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/customresourcedefinitions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchApiextensionsV1CustomResourceDefinitionListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetApiregistrationAPIGroup(ctx context.Context) (_ GetApiregistrationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetApiregistrationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetApiregistrationV1APIResources(ctx context.Context) (_ GetApiregistrationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetApiregistrationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListApiregistrationV1APIService(ctx context.Context, params ListApiregistrationV1APIServiceParams) (_ ListApiregistrationV1APIServiceResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"
	path += "/v1"
	path += "/apiservices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListApiregistrationV1APIServiceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateApiregistrationV1APIService(ctx context.Context, req IoK8sKubeAggregatorPkgApisApiregistrationV1APIService, params CreateApiregistrationV1APIServiceParams) (_ CreateApiregistrationV1APIServiceResponse, rerr error) {
	body, contentType, err := encodeCreateApiregistrationV1APIServiceRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"
	path += "/v1"
	path += "/apiservices"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateApiregistrationV1APIServiceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteApiregistrationV1CollectionAPIService(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteApiregistrationV1CollectionAPIServiceParams) (_ DeleteApiregistrationV1CollectionAPIServiceResponse, rerr error) {
	body, contentType, err := encodeDeleteApiregistrationV1CollectionAPIServiceRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"
	path += "/v1"
	path += "/apiservices"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteApiregistrationV1CollectionAPIServiceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchApiregistrationV1APIServiceList(ctx context.Context) (_ WatchApiregistrationV1APIServiceListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apiregistration.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/apiservices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchApiregistrationV1APIServiceListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAppsAPIGroup(ctx context.Context) (_ GetAppsAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAppsAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAppsV1APIResources(ctx context.Context) (_ GetAppsV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAppsV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAppsV1ControllerRevisionForAllNamespaces(ctx context.Context) (_ ListAppsV1ControllerRevisionForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/controllerrevisions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAppsV1ControllerRevisionForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAppsV1DaemonSetForAllNamespaces(ctx context.Context) (_ ListAppsV1DaemonSetForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/daemonsets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAppsV1DaemonSetForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAppsV1DeploymentForAllNamespaces(ctx context.Context) (_ ListAppsV1DeploymentForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/deployments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAppsV1DeploymentForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAppsV1ReplicaSetForAllNamespaces(ctx context.Context) (_ ListAppsV1ReplicaSetForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/replicasets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAppsV1ReplicaSetForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAppsV1StatefulSetForAllNamespaces(ctx context.Context) (_ ListAppsV1StatefulSetForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/statefulsets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAppsV1StatefulSetForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAppsV1ControllerRevisionListForAllNamespaces(ctx context.Context) (_ WatchAppsV1ControllerRevisionListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/watch"
	path += "/controllerrevisions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAppsV1ControllerRevisionListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAppsV1DaemonSetListForAllNamespaces(ctx context.Context) (_ WatchAppsV1DaemonSetListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/watch"
	path += "/daemonsets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAppsV1DaemonSetListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAppsV1DeploymentListForAllNamespaces(ctx context.Context) (_ WatchAppsV1DeploymentListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/watch"
	path += "/deployments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAppsV1DeploymentListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAppsV1ReplicaSetListForAllNamespaces(ctx context.Context) (_ WatchAppsV1ReplicaSetListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/watch"
	path += "/replicasets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAppsV1ReplicaSetListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAppsV1StatefulSetListForAllNamespaces(ctx context.Context) (_ WatchAppsV1StatefulSetListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/apps"
	path += "/v1"
	path += "/watch"
	path += "/statefulsets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAppsV1StatefulSetListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAuthenticationAPIGroup(ctx context.Context) (_ GetAuthenticationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/authentication.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAuthenticationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAuthenticationV1APIResources(ctx context.Context) (_ GetAuthenticationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/authentication.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAuthenticationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAuthenticationV1TokenReview(ctx context.Context, req IoK8sAPIAuthenticationV1TokenReview) (_ CreateAuthenticationV1TokenReviewResponse, rerr error) {
	body, contentType, err := encodeCreateAuthenticationV1TokenReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/authentication.k8s.io"
	path += "/v1"
	path += "/tokenreviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAuthenticationV1TokenReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAuthorizationAPIGroup(ctx context.Context) (_ GetAuthorizationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/authorization.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAuthorizationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAuthorizationV1APIResources(ctx context.Context) (_ GetAuthorizationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/authorization.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAuthorizationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAuthorizationV1SelfSubjectAccessReview(ctx context.Context, req IoK8sAPIAuthorizationV1SelfSubjectAccessReview) (_ CreateAuthorizationV1SelfSubjectAccessReviewResponse, rerr error) {
	body, contentType, err := encodeCreateAuthorizationV1SelfSubjectAccessReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/authorization.k8s.io"
	path += "/v1"
	path += "/selfsubjectaccessreviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAuthorizationV1SelfSubjectAccessReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAuthorizationV1SelfSubjectRulesReview(ctx context.Context, req IoK8sAPIAuthorizationV1SelfSubjectRulesReview) (_ CreateAuthorizationV1SelfSubjectRulesReviewResponse, rerr error) {
	body, contentType, err := encodeCreateAuthorizationV1SelfSubjectRulesReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/authorization.k8s.io"
	path += "/v1"
	path += "/selfsubjectrulesreviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAuthorizationV1SelfSubjectRulesReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateAuthorizationV1SubjectAccessReview(ctx context.Context, req IoK8sAPIAuthorizationV1SubjectAccessReview) (_ CreateAuthorizationV1SubjectAccessReviewResponse, rerr error) {
	body, contentType, err := encodeCreateAuthorizationV1SubjectAccessReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/authorization.k8s.io"
	path += "/v1"
	path += "/subjectaccessreviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateAuthorizationV1SubjectAccessReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAutoscalingAPIGroup(ctx context.Context) (_ GetAutoscalingAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoscalingAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAutoscalingV1APIResources(ctx context.Context) (_ GetAutoscalingV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoscalingV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx context.Context) (_ ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v1"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx context.Context) (_ WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v1"
	path += "/watch"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAutoscalingV2beta1APIResources(ctx context.Context) (_ GetAutoscalingV2beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoscalingV2beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx context.Context) (_ ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta1"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx context.Context) (_ WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta1"
	path += "/watch"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetAutoscalingV2beta2APIResources(ctx context.Context) (_ GetAutoscalingV2beta2APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta2"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoscalingV2beta2APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx context.Context) (_ ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta2"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx context.Context) (_ WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/autoscaling"
	path += "/v2beta2"
	path += "/watch"
	path += "/horizontalpodautoscalers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetBatchAPIGroup(ctx context.Context) (_ GetBatchAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetBatchAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetBatchV1APIResources(ctx context.Context) (_ GetBatchV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetBatchV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListBatchV1CronJobForAllNamespaces(ctx context.Context) (_ ListBatchV1CronJobForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1"
	path += "/cronjobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListBatchV1CronJobForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListBatchV1JobForAllNamespaces(ctx context.Context) (_ ListBatchV1JobForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1"
	path += "/jobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListBatchV1JobForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchBatchV1CronJobListForAllNamespaces(ctx context.Context) (_ WatchBatchV1CronJobListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1"
	path += "/watch"
	path += "/cronjobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchBatchV1CronJobListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchBatchV1JobListForAllNamespaces(ctx context.Context) (_ WatchBatchV1JobListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1"
	path += "/watch"
	path += "/jobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchBatchV1JobListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetBatchV1beta1APIResources(ctx context.Context) (_ GetBatchV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetBatchV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListBatchV1beta1CronJobForAllNamespaces(ctx context.Context) (_ ListBatchV1beta1CronJobForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1beta1"
	path += "/cronjobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListBatchV1beta1CronJobForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchBatchV1beta1CronJobListForAllNamespaces(ctx context.Context) (_ WatchBatchV1beta1CronJobListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/batch"
	path += "/v1beta1"
	path += "/watch"
	path += "/cronjobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchBatchV1beta1CronJobListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCertificatesAPIGroup(ctx context.Context) (_ GetCertificatesAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCertificatesAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCertificatesV1APIResources(ctx context.Context) (_ GetCertificatesV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCertificatesV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCertificatesV1CertificateSigningRequest(ctx context.Context, params ListCertificatesV1CertificateSigningRequestParams) (_ ListCertificatesV1CertificateSigningRequestResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"
	path += "/v1"
	path += "/certificatesigningrequests"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCertificatesV1CertificateSigningRequestResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateCertificatesV1CertificateSigningRequest(ctx context.Context, req IoK8sAPICertificatesV1CertificateSigningRequest, params CreateCertificatesV1CertificateSigningRequestParams) (_ CreateCertificatesV1CertificateSigningRequestResponse, rerr error) {
	body, contentType, err := encodeCreateCertificatesV1CertificateSigningRequestRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"
	path += "/v1"
	path += "/certificatesigningrequests"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateCertificatesV1CertificateSigningRequestResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteCertificatesV1CollectionCertificateSigningRequest(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteCertificatesV1CollectionCertificateSigningRequestParams) (_ DeleteCertificatesV1CollectionCertificateSigningRequestResponse, rerr error) {
	body, contentType, err := encodeDeleteCertificatesV1CollectionCertificateSigningRequestRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"
	path += "/v1"
	path += "/certificatesigningrequests"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCertificatesV1CollectionCertificateSigningRequestResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCertificatesV1CertificateSigningRequestList(ctx context.Context) (_ WatchCertificatesV1CertificateSigningRequestListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/certificates.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/certificatesigningrequests"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCertificatesV1CertificateSigningRequestListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCoordinationAPIGroup(ctx context.Context) (_ GetCoordinationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/coordination.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCoordinationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCoordinationV1APIResources(ctx context.Context) (_ GetCoordinationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/coordination.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCoordinationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListCoordinationV1LeaseForAllNamespaces(ctx context.Context) (_ ListCoordinationV1LeaseForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/coordination.k8s.io"
	path += "/v1"
	path += "/leases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListCoordinationV1LeaseForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchCoordinationV1LeaseListForAllNamespaces(ctx context.Context) (_ WatchCoordinationV1LeaseListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/coordination.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/leases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchCoordinationV1LeaseListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetDiscoveryAPIGroup(ctx context.Context) (_ GetDiscoveryAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetDiscoveryAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetDiscoveryV1APIResources(ctx context.Context) (_ GetDiscoveryV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetDiscoveryV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListDiscoveryV1EndpointSliceForAllNamespaces(ctx context.Context) (_ ListDiscoveryV1EndpointSliceForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1"
	path += "/endpointslices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListDiscoveryV1EndpointSliceForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx context.Context) (_ WatchDiscoveryV1EndpointSliceListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/endpointslices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetDiscoveryV1beta1APIResources(ctx context.Context) (_ GetDiscoveryV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetDiscoveryV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx context.Context) (_ ListDiscoveryV1beta1EndpointSliceForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1beta1"
	path += "/endpointslices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx context.Context) (_ WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/discovery.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/endpointslices"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetEventsAPIGroup(ctx context.Context) (_ GetEventsAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetEventsAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetEventsV1APIResources(ctx context.Context) (_ GetEventsV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetEventsV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListEventsV1EventForAllNamespaces(ctx context.Context) (_ ListEventsV1EventForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListEventsV1EventForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchEventsV1EventListForAllNamespaces(ctx context.Context) (_ WatchEventsV1EventListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchEventsV1EventListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetEventsV1beta1APIResources(ctx context.Context) (_ GetEventsV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetEventsV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListEventsV1beta1EventForAllNamespaces(ctx context.Context) (_ ListEventsV1beta1EventForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1beta1"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListEventsV1beta1EventForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchEventsV1beta1EventListForAllNamespaces(ctx context.Context) (_ WatchEventsV1beta1EventListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/events.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchEventsV1beta1EventListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetFlowcontrolApiserverAPIGroup(ctx context.Context) (_ GetFlowcontrolApiserverAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetFlowcontrolApiserverAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetFlowcontrolApiserverV1beta1APIResources(ctx context.Context) (_ GetFlowcontrolApiserverV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetFlowcontrolApiserverV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListFlowcontrolApiserverV1beta1FlowSchema(ctx context.Context, params ListFlowcontrolApiserverV1beta1FlowSchemaParams) (_ ListFlowcontrolApiserverV1beta1FlowSchemaResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListFlowcontrolApiserverV1beta1FlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateFlowcontrolApiserverV1beta1FlowSchema(ctx context.Context, req IoK8sAPIFlowcontrolV1beta1FlowSchema, params CreateFlowcontrolApiserverV1beta1FlowSchemaParams) (_ CreateFlowcontrolApiserverV1beta1FlowSchemaResponse, rerr error) {
	body, contentType, err := encodeCreateFlowcontrolApiserverV1beta1FlowSchemaRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlowcontrolApiserverV1beta1FlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteFlowcontrolApiserverV1beta1CollectionFlowSchema(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteFlowcontrolApiserverV1beta1CollectionFlowSchemaParams) (_ DeleteFlowcontrolApiserverV1beta1CollectionFlowSchemaResponse, rerr error) {
	body, contentType, err := encodeDeleteFlowcontrolApiserverV1beta1CollectionFlowSchemaRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFlowcontrolApiserverV1beta1CollectionFlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx context.Context, params ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) (_ ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx context.Context, req IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration, params CreateFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) (_ CreateFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse, rerr error) {
	body, contentType, err := encodeCreateFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteFlowcontrolApiserverV1beta1CollectionPriorityLevelConfiguration(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteFlowcontrolApiserverV1beta1CollectionPriorityLevelConfigurationParams) (_ DeleteFlowcontrolApiserverV1beta1CollectionPriorityLevelConfigurationResponse, rerr error) {
	body, contentType, err := encodeDeleteFlowcontrolApiserverV1beta1CollectionPriorityLevelConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFlowcontrolApiserverV1beta1CollectionPriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx context.Context) (_ WatchFlowcontrolApiserverV1beta1FlowSchemaListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx context.Context) (_ WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetFlowcontrolApiserverV1beta2APIResources(ctx context.Context) (_ GetFlowcontrolApiserverV1beta2APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetFlowcontrolApiserverV1beta2APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListFlowcontrolApiserverV1beta2FlowSchema(ctx context.Context, params ListFlowcontrolApiserverV1beta2FlowSchemaParams) (_ ListFlowcontrolApiserverV1beta2FlowSchemaResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListFlowcontrolApiserverV1beta2FlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateFlowcontrolApiserverV1beta2FlowSchema(ctx context.Context, req IoK8sAPIFlowcontrolV1beta2FlowSchema, params CreateFlowcontrolApiserverV1beta2FlowSchemaParams) (_ CreateFlowcontrolApiserverV1beta2FlowSchemaResponse, rerr error) {
	body, contentType, err := encodeCreateFlowcontrolApiserverV1beta2FlowSchemaRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlowcontrolApiserverV1beta2FlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteFlowcontrolApiserverV1beta2CollectionFlowSchema(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteFlowcontrolApiserverV1beta2CollectionFlowSchemaParams) (_ DeleteFlowcontrolApiserverV1beta2CollectionFlowSchemaResponse, rerr error) {
	body, contentType, err := encodeDeleteFlowcontrolApiserverV1beta2CollectionFlowSchemaRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFlowcontrolApiserverV1beta2CollectionFlowSchemaResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx context.Context, params ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) (_ ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx context.Context, req IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration, params CreateFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) (_ CreateFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse, rerr error) {
	body, contentType, err := encodeCreateFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfiguration(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfigurationParams) (_ DeleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfigurationResponse, rerr error) {
	body, contentType, err := encodeDeleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfigurationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfigurationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx context.Context) (_ WatchFlowcontrolApiserverV1beta2FlowSchemaListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/watch"
	path += "/flowschemas"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx context.Context) (_ WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/flowcontrol.apiserver.k8s.io"
	path += "/v1beta2"
	path += "/watch"
	path += "/prioritylevelconfigurations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetInternalApiserverAPIGroup(ctx context.Context) (_ GetInternalApiserverAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetInternalApiserverAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetInternalApiserverV1alpha1APIResources(ctx context.Context) (_ GetInternalApiserverV1alpha1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"
	path += "/v1alpha1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetInternalApiserverV1alpha1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListInternalApiserverV1alpha1StorageVersion(ctx context.Context, params ListInternalApiserverV1alpha1StorageVersionParams) (_ ListInternalApiserverV1alpha1StorageVersionResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"
	path += "/v1alpha1"
	path += "/storageversions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListInternalApiserverV1alpha1StorageVersionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateInternalApiserverV1alpha1StorageVersion(ctx context.Context, req IoK8sAPIApiserverinternalV1alpha1StorageVersion, params CreateInternalApiserverV1alpha1StorageVersionParams) (_ CreateInternalApiserverV1alpha1StorageVersionResponse, rerr error) {
	body, contentType, err := encodeCreateInternalApiserverV1alpha1StorageVersionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"
	path += "/v1alpha1"
	path += "/storageversions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateInternalApiserverV1alpha1StorageVersionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteInternalApiserverV1alpha1CollectionStorageVersion(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteInternalApiserverV1alpha1CollectionStorageVersionParams) (_ DeleteInternalApiserverV1alpha1CollectionStorageVersionResponse, rerr error) {
	body, contentType, err := encodeDeleteInternalApiserverV1alpha1CollectionStorageVersionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"
	path += "/v1alpha1"
	path += "/storageversions"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteInternalApiserverV1alpha1CollectionStorageVersionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchInternalApiserverV1alpha1StorageVersionList(ctx context.Context) (_ WatchInternalApiserverV1alpha1StorageVersionListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/internal.apiserver.k8s.io"
	path += "/v1alpha1"
	path += "/watch"
	path += "/storageversions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchInternalApiserverV1alpha1StorageVersionListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNetworkingAPIGroup(ctx context.Context) (_ GetNetworkingAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkingAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNetworkingV1APIResources(ctx context.Context) (_ GetNetworkingV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkingV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNetworkingV1IngressClass(ctx context.Context, params ListNetworkingV1IngressClassParams) (_ ListNetworkingV1IngressClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/ingressclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNetworkingV1IngressClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateNetworkingV1IngressClass(ctx context.Context, req IoK8sAPINetworkingV1IngressClass, params CreateNetworkingV1IngressClassParams) (_ CreateNetworkingV1IngressClassResponse, rerr error) {
	body, contentType, err := encodeCreateNetworkingV1IngressClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/ingressclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateNetworkingV1IngressClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteNetworkingV1CollectionIngressClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteNetworkingV1CollectionIngressClassParams) (_ DeleteNetworkingV1CollectionIngressClassResponse, rerr error) {
	body, contentType, err := encodeDeleteNetworkingV1CollectionIngressClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/ingressclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNetworkingV1CollectionIngressClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNetworkingV1IngressForAllNamespaces(ctx context.Context) (_ ListNetworkingV1IngressForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/ingresses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNetworkingV1IngressForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNetworkingV1NetworkPolicyForAllNamespaces(ctx context.Context) (_ ListNetworkingV1NetworkPolicyForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/networkpolicies"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNetworkingV1NetworkPolicyForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNetworkingV1IngressClassList(ctx context.Context) (_ WatchNetworkingV1IngressClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/ingressclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNetworkingV1IngressClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNetworkingV1IngressListForAllNamespaces(ctx context.Context) (_ WatchNetworkingV1IngressListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/ingresses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNetworkingV1IngressListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx context.Context) (_ WatchNetworkingV1NetworkPolicyListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/networking.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/networkpolicies"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNodeAPIGroup(ctx context.Context) (_ GetNodeAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNodeAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNodeV1APIResources(ctx context.Context) (_ GetNodeV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNodeV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNodeV1RuntimeClass(ctx context.Context, params ListNodeV1RuntimeClassParams) (_ ListNodeV1RuntimeClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNodeV1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateNodeV1RuntimeClass(ctx context.Context, req IoK8sAPINodeV1RuntimeClass, params CreateNodeV1RuntimeClassParams) (_ CreateNodeV1RuntimeClassResponse, rerr error) {
	body, contentType, err := encodeCreateNodeV1RuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateNodeV1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteNodeV1CollectionRuntimeClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteNodeV1CollectionRuntimeClassParams) (_ DeleteNodeV1CollectionRuntimeClassResponse, rerr error) {
	body, contentType, err := encodeDeleteNodeV1CollectionRuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNodeV1CollectionRuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNodeV1RuntimeClassList(ctx context.Context) (_ WatchNodeV1RuntimeClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNodeV1RuntimeClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNodeV1alpha1APIResources(ctx context.Context) (_ GetNodeV1alpha1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1alpha1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNodeV1alpha1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNodeV1alpha1RuntimeClass(ctx context.Context, params ListNodeV1alpha1RuntimeClassParams) (_ ListNodeV1alpha1RuntimeClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1alpha1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNodeV1alpha1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateNodeV1alpha1RuntimeClass(ctx context.Context, req IoK8sAPINodeV1alpha1RuntimeClass, params CreateNodeV1alpha1RuntimeClassParams) (_ CreateNodeV1alpha1RuntimeClassResponse, rerr error) {
	body, contentType, err := encodeCreateNodeV1alpha1RuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1alpha1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateNodeV1alpha1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteNodeV1alpha1CollectionRuntimeClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteNodeV1alpha1CollectionRuntimeClassParams) (_ DeleteNodeV1alpha1CollectionRuntimeClassResponse, rerr error) {
	body, contentType, err := encodeDeleteNodeV1alpha1CollectionRuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1alpha1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNodeV1alpha1CollectionRuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNodeV1alpha1RuntimeClassList(ctx context.Context) (_ WatchNodeV1alpha1RuntimeClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1alpha1"
	path += "/watch"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNodeV1alpha1RuntimeClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetNodeV1beta1APIResources(ctx context.Context) (_ GetNodeV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetNodeV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListNodeV1beta1RuntimeClass(ctx context.Context, params ListNodeV1beta1RuntimeClassParams) (_ ListNodeV1beta1RuntimeClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1beta1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListNodeV1beta1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateNodeV1beta1RuntimeClass(ctx context.Context, req IoK8sAPINodeV1beta1RuntimeClass, params CreateNodeV1beta1RuntimeClassParams) (_ CreateNodeV1beta1RuntimeClassResponse, rerr error) {
	body, contentType, err := encodeCreateNodeV1beta1RuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1beta1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateNodeV1beta1RuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteNodeV1beta1CollectionRuntimeClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteNodeV1beta1CollectionRuntimeClassParams) (_ DeleteNodeV1beta1CollectionRuntimeClassResponse, rerr error) {
	body, contentType, err := encodeDeleteNodeV1beta1CollectionRuntimeClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1beta1"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNodeV1beta1CollectionRuntimeClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchNodeV1beta1RuntimeClassList(ctx context.Context) (_ WatchNodeV1beta1RuntimeClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/node.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/runtimeclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchNodeV1beta1RuntimeClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetPolicyAPIGroup(ctx context.Context) (_ GetPolicyAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetPolicyAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetPolicyV1APIResources(ctx context.Context) (_ GetPolicyV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetPolicyV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx context.Context) (_ ListPolicyV1PodDisruptionBudgetForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1"
	path += "/poddisruptionbudgets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListPolicyV1PodDisruptionBudgetForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx context.Context) (_ WatchPolicyV1PodDisruptionBudgetListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1"
	path += "/watch"
	path += "/poddisruptionbudgets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetPolicyV1beta1APIResources(ctx context.Context) (_ GetPolicyV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetPolicyV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx context.Context) (_ ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/poddisruptionbudgets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListPolicyV1beta1PodSecurityPolicy(ctx context.Context, params ListPolicyV1beta1PodSecurityPolicyParams) (_ ListPolicyV1beta1PodSecurityPolicyResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/podsecuritypolicies"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListPolicyV1beta1PodSecurityPolicyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreatePolicyV1beta1PodSecurityPolicy(ctx context.Context, req IoK8sAPIPolicyV1beta1PodSecurityPolicy, params CreatePolicyV1beta1PodSecurityPolicyParams) (_ CreatePolicyV1beta1PodSecurityPolicyResponse, rerr error) {
	body, contentType, err := encodeCreatePolicyV1beta1PodSecurityPolicyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/podsecuritypolicies"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreatePolicyV1beta1PodSecurityPolicyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeletePolicyV1beta1CollectionPodSecurityPolicy(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeletePolicyV1beta1CollectionPodSecurityPolicyParams) (_ DeletePolicyV1beta1CollectionPodSecurityPolicyResponse, rerr error) {
	body, contentType, err := encodeDeletePolicyV1beta1CollectionPodSecurityPolicyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/podsecuritypolicies"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeletePolicyV1beta1CollectionPodSecurityPolicyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx context.Context) (_ WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/watch"
	path += "/poddisruptionbudgets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchPolicyV1beta1PodSecurityPolicyList(ctx context.Context) (_ WatchPolicyV1beta1PodSecurityPolicyListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/policy"
	path += "/v1beta1"
	path += "/watch"
	path += "/podsecuritypolicies"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchPolicyV1beta1PodSecurityPolicyListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetRbacAuthorizationAPIGroup(ctx context.Context) (_ GetRbacAuthorizationAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetRbacAuthorizationAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetRbacAuthorizationV1APIResources(ctx context.Context) (_ GetRbacAuthorizationV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetRbacAuthorizationV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListRbacAuthorizationV1ClusterRoleBinding(ctx context.Context, params ListRbacAuthorizationV1ClusterRoleBindingParams) (_ ListRbacAuthorizationV1ClusterRoleBindingResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterrolebindings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListRbacAuthorizationV1ClusterRoleBindingResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateRbacAuthorizationV1ClusterRoleBinding(ctx context.Context, req IoK8sAPIRbacV1ClusterRoleBinding, params CreateRbacAuthorizationV1ClusterRoleBindingParams) (_ CreateRbacAuthorizationV1ClusterRoleBindingResponse, rerr error) {
	body, contentType, err := encodeCreateRbacAuthorizationV1ClusterRoleBindingRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterrolebindings"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateRbacAuthorizationV1ClusterRoleBindingResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteRbacAuthorizationV1CollectionClusterRoleBinding(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteRbacAuthorizationV1CollectionClusterRoleBindingParams) (_ DeleteRbacAuthorizationV1CollectionClusterRoleBindingResponse, rerr error) {
	body, contentType, err := encodeDeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterrolebindings"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRbacAuthorizationV1CollectionClusterRoleBindingResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListRbacAuthorizationV1ClusterRole(ctx context.Context, params ListRbacAuthorizationV1ClusterRoleParams) (_ ListRbacAuthorizationV1ClusterRoleResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterroles"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListRbacAuthorizationV1ClusterRoleResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateRbacAuthorizationV1ClusterRole(ctx context.Context, req IoK8sAPIRbacV1ClusterRole, params CreateRbacAuthorizationV1ClusterRoleParams) (_ CreateRbacAuthorizationV1ClusterRoleResponse, rerr error) {
	body, contentType, err := encodeCreateRbacAuthorizationV1ClusterRoleRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterroles"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateRbacAuthorizationV1ClusterRoleResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteRbacAuthorizationV1CollectionClusterRole(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteRbacAuthorizationV1CollectionClusterRoleParams) (_ DeleteRbacAuthorizationV1CollectionClusterRoleResponse, rerr error) {
	body, contentType, err := encodeDeleteRbacAuthorizationV1CollectionClusterRoleRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/clusterroles"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRbacAuthorizationV1CollectionClusterRoleResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx context.Context) (_ ListRbacAuthorizationV1RoleBindingForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/rolebindings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListRbacAuthorizationV1RoleBindingForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListRbacAuthorizationV1RoleForAllNamespaces(ctx context.Context) (_ ListRbacAuthorizationV1RoleForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/roles"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListRbacAuthorizationV1RoleForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchRbacAuthorizationV1ClusterRoleBindingList(ctx context.Context) (_ WatchRbacAuthorizationV1ClusterRoleBindingListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/clusterrolebindings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchRbacAuthorizationV1ClusterRoleList(ctx context.Context) (_ WatchRbacAuthorizationV1ClusterRoleListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/clusterroles"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchRbacAuthorizationV1ClusterRoleListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx context.Context) (_ WatchRbacAuthorizationV1RoleBindingListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/rolebindings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx context.Context) (_ WatchRbacAuthorizationV1RoleListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/rbac.authorization.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/roles"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchRbacAuthorizationV1RoleListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetSchedulingAPIGroup(ctx context.Context) (_ GetSchedulingAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetSchedulingAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetSchedulingV1APIResources(ctx context.Context) (_ GetSchedulingV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetSchedulingV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListSchedulingV1PriorityClass(ctx context.Context, params ListSchedulingV1PriorityClassParams) (_ ListSchedulingV1PriorityClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"
	path += "/v1"
	path += "/priorityclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListSchedulingV1PriorityClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateSchedulingV1PriorityClass(ctx context.Context, req IoK8sAPISchedulingV1PriorityClass, params CreateSchedulingV1PriorityClassParams) (_ CreateSchedulingV1PriorityClassResponse, rerr error) {
	body, contentType, err := encodeCreateSchedulingV1PriorityClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"
	path += "/v1"
	path += "/priorityclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateSchedulingV1PriorityClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteSchedulingV1CollectionPriorityClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteSchedulingV1CollectionPriorityClassParams) (_ DeleteSchedulingV1CollectionPriorityClassResponse, rerr error) {
	body, contentType, err := encodeDeleteSchedulingV1CollectionPriorityClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"
	path += "/v1"
	path += "/priorityclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSchedulingV1CollectionPriorityClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchSchedulingV1PriorityClassList(ctx context.Context) (_ WatchSchedulingV1PriorityClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/scheduling.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/priorityclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchSchedulingV1PriorityClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetStorageAPIGroup(ctx context.Context) (_ GetStorageAPIGroupResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetStorageAPIGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetStorageV1APIResources(ctx context.Context) (_ GetStorageV1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetStorageV1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1CSIDriver(ctx context.Context, params ListStorageV1CSIDriverParams) (_ ListStorageV1CSIDriverResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csidrivers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1CSIDriverResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateStorageV1CSIDriver(ctx context.Context, req IoK8sAPIStorageV1CSIDriver, params CreateStorageV1CSIDriverParams) (_ CreateStorageV1CSIDriverResponse, rerr error) {
	body, contentType, err := encodeCreateStorageV1CSIDriverRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csidrivers"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateStorageV1CSIDriverResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteStorageV1CollectionCSIDriver(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteStorageV1CollectionCSIDriverParams) (_ DeleteStorageV1CollectionCSIDriverResponse, rerr error) {
	body, contentType, err := encodeDeleteStorageV1CollectionCSIDriverRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csidrivers"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStorageV1CollectionCSIDriverResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1CSINode(ctx context.Context, params ListStorageV1CSINodeParams) (_ ListStorageV1CSINodeResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csinodes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1CSINodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateStorageV1CSINode(ctx context.Context, req IoK8sAPIStorageV1CSINode, params CreateStorageV1CSINodeParams) (_ CreateStorageV1CSINodeResponse, rerr error) {
	body, contentType, err := encodeCreateStorageV1CSINodeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csinodes"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateStorageV1CSINodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteStorageV1CollectionCSINode(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteStorageV1CollectionCSINodeParams) (_ DeleteStorageV1CollectionCSINodeResponse, rerr error) {
	body, contentType, err := encodeDeleteStorageV1CollectionCSINodeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/csinodes"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStorageV1CollectionCSINodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1StorageClass(ctx context.Context, params ListStorageV1StorageClassParams) (_ ListStorageV1StorageClassResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/storageclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1StorageClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateStorageV1StorageClass(ctx context.Context, req IoK8sAPIStorageV1StorageClass, params CreateStorageV1StorageClassParams) (_ CreateStorageV1StorageClassResponse, rerr error) {
	body, contentType, err := encodeCreateStorageV1StorageClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/storageclasses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateStorageV1StorageClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteStorageV1CollectionStorageClass(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteStorageV1CollectionStorageClassParams) (_ DeleteStorageV1CollectionStorageClassResponse, rerr error) {
	body, contentType, err := encodeDeleteStorageV1CollectionStorageClassRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/storageclasses"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStorageV1CollectionStorageClassResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1VolumeAttachment(ctx context.Context, params ListStorageV1VolumeAttachmentParams) (_ ListStorageV1VolumeAttachmentResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/volumeattachments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.AllowWatchBookmarks)
		q.Set("allowWatchBookmarks", s)
	}
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	{
		s := conv.BoolToString(params.Watch)
		q.Set("watch", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1VolumeAttachmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CreateStorageV1VolumeAttachment(ctx context.Context, req IoK8sAPIStorageV1VolumeAttachment, params CreateStorageV1VolumeAttachmentParams) (_ CreateStorageV1VolumeAttachmentResponse, rerr error) {
	body, contentType, err := encodeCreateStorageV1VolumeAttachmentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/volumeattachments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldManager)
		q.Set("fieldManager", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCreateStorageV1VolumeAttachmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) DeleteStorageV1CollectionVolumeAttachment(ctx context.Context, req *IoK8sApimachineryPkgApisMetaV1DeleteOptions, params DeleteStorageV1CollectionVolumeAttachmentParams) (_ DeleteStorageV1CollectionVolumeAttachmentResponse, rerr error) {
	body, contentType, err := encodeDeleteStorageV1CollectionVolumeAttachmentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/volumeattachments"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Continue)
		q.Set("continue", s)
	}
	{
		s := conv.StringToString(params.DryRun)
		q.Set("dryRun", s)
	}
	{
		s := conv.StringToString(params.FieldSelector)
		q.Set("fieldSelector", s)
	}
	{
		s := conv.IntToString(params.GracePeriodSeconds)
		q.Set("gracePeriodSeconds", s)
	}
	{
		s := conv.StringToString(params.LabelSelector)
		q.Set("labelSelector", s)
	}
	{
		s := conv.IntToString(params.Limit)
		q.Set("limit", s)
	}
	{
		s := conv.BoolToString(params.OrphanDependents)
		q.Set("orphanDependents", s)
	}
	{
		s := conv.StringToString(params.PropagationPolicy)
		q.Set("propagationPolicy", s)
	}
	{
		s := conv.StringToString(params.ResourceVersion)
		q.Set("resourceVersion", s)
	}
	{
		s := conv.StringToString(params.ResourceVersionMatch)
		q.Set("resourceVersionMatch", s)
	}
	{
		s := conv.IntToString(params.TimeoutSeconds)
		q.Set("timeoutSeconds", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStorageV1CollectionVolumeAttachmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1CSIDriverList(ctx context.Context) (_ WatchStorageV1CSIDriverListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/csidrivers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1CSIDriverListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1CSINodeList(ctx context.Context) (_ WatchStorageV1CSINodeListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/csinodes"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1CSINodeListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1StorageClassList(ctx context.Context) (_ WatchStorageV1StorageClassListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/storageclasses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1StorageClassListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1VolumeAttachmentList(ctx context.Context) (_ WatchStorageV1VolumeAttachmentListResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1"
	path += "/watch"
	path += "/volumeattachments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1VolumeAttachmentListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetStorageV1alpha1APIResources(ctx context.Context) (_ GetStorageV1alpha1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1alpha1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetStorageV1alpha1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx context.Context) (_ ListStorageV1alpha1CSIStorageCapacityForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1alpha1"
	path += "/csistoragecapacities"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx context.Context) (_ WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1alpha1"
	path += "/watch"
	path += "/csistoragecapacities"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetStorageV1beta1APIResources(ctx context.Context) (_ GetStorageV1beta1APIResourcesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1beta1"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetStorageV1beta1APIResourcesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx context.Context) (_ ListStorageV1beta1CSIStorageCapacityForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1beta1"
	path += "/csistoragecapacities"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx context.Context) (_ WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesResponse, rerr error) {
	path := c.serverURL
	path += "/apis"
	path += "/storage.k8s.io"
	path += "/v1beta1"
	path += "/watch"
	path += "/csistoragecapacities"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) LogFileListHandler(ctx context.Context) (_ LogFileListHandler, rerr error) {
	path := c.serverURL
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeLogFileListHandlerResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetServiceAccountIssuerOpenIDKeyset(ctx context.Context) (_ GetServiceAccountIssuerOpenIDKeysetResponse, rerr error) {
	path := c.serverURL
	path += "/openid"
	path += "/v1"
	path += "/jwks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceAccountIssuerOpenIDKeysetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GetCodeVersion(ctx context.Context) (_ GetCodeVersionResponse, rerr error) {
	path := c.serverURL
	path += "/version"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGetCodeVersionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}
