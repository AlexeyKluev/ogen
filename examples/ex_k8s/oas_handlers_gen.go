// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// HandleGetAPIVersionsRequest handles getAPIVersions operation.
//
// GET /apis/
func (s *Server) handleGetAPIVersionsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAPIVersions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAPIVersions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAPIVersions(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAPIVersionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAdmissionregistrationAPIGroupRequest handles getAdmissionregistrationAPIGroup operation.
//
// GET /apis/admissionregistration.k8s.io/
func (s *Server) handleGetAdmissionregistrationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAdmissionregistrationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAdmissionregistrationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAdmissionregistrationV1APIResourcesRequest handles getAdmissionregistrationV1APIResources operation.
//
// GET /apis/admissionregistration.k8s.io/v1/
func (s *Server) handleGetAdmissionregistrationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAdmissionregistrationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAdmissionregistrationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetApiextensionsAPIGroupRequest handles getApiextensionsAPIGroup operation.
//
// GET /apis/apiextensions.k8s.io/
func (s *Server) handleGetApiextensionsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetApiextensionsAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetApiextensionsAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetApiextensionsV1APIResourcesRequest handles getApiextensionsV1APIResources operation.
//
// GET /apis/apiextensions.k8s.io/v1/
func (s *Server) handleGetApiextensionsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetApiextensionsV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetApiextensionsV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetApiregistrationAPIGroupRequest handles getApiregistrationAPIGroup operation.
//
// GET /apis/apiregistration.k8s.io/
func (s *Server) handleGetApiregistrationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetApiregistrationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetApiregistrationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetApiregistrationV1APIResourcesRequest handles getApiregistrationV1APIResources operation.
//
// GET /apis/apiregistration.k8s.io/v1/
func (s *Server) handleGetApiregistrationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetApiregistrationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetApiregistrationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAppsAPIGroupRequest handles getAppsAPIGroup operation.
//
// GET /apis/apps/
func (s *Server) handleGetAppsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAppsAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAppsAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAppsV1APIResourcesRequest handles getAppsV1APIResources operation.
//
// GET /apis/apps/v1/
func (s *Server) handleGetAppsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAppsV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAppsV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAuthenticationAPIGroupRequest handles getAuthenticationAPIGroup operation.
//
// GET /apis/authentication.k8s.io/
func (s *Server) handleGetAuthenticationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAuthenticationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAuthenticationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAuthenticationV1APIResourcesRequest handles getAuthenticationV1APIResources operation.
//
// GET /apis/authentication.k8s.io/v1/
func (s *Server) handleGetAuthenticationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAuthenticationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAuthenticationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAuthorizationAPIGroupRequest handles getAuthorizationAPIGroup operation.
//
// GET /apis/authorization.k8s.io/
func (s *Server) handleGetAuthorizationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAuthorizationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAuthorizationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAuthorizationV1APIResourcesRequest handles getAuthorizationV1APIResources operation.
//
// GET /apis/authorization.k8s.io/v1/
func (s *Server) handleGetAuthorizationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAuthorizationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAutoscalingAPIGroupRequest handles getAutoscalingAPIGroup operation.
//
// GET /apis/autoscaling/
func (s *Server) handleGetAutoscalingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAutoscalingAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAutoscalingAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAutoscalingV1APIResourcesRequest handles getAutoscalingV1APIResources operation.
//
// GET /apis/autoscaling/v1/
func (s *Server) handleGetAutoscalingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAutoscalingV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAutoscalingV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAutoscalingV2beta1APIResourcesRequest handles getAutoscalingV2beta1APIResources operation.
//
// GET /apis/autoscaling/v2beta1/
func (s *Server) handleGetAutoscalingV2beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAutoscalingV2beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAutoscalingV2beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetAutoscalingV2beta2APIResourcesRequest handles getAutoscalingV2beta2APIResources operation.
//
// GET /apis/autoscaling/v2beta2/
func (s *Server) handleGetAutoscalingV2beta2APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta2APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetAutoscalingV2beta2APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetAutoscalingV2beta2APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetBatchAPIGroupRequest handles getBatchAPIGroup operation.
//
// GET /apis/batch/
func (s *Server) handleGetBatchAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetBatchAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetBatchAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetBatchV1APIResourcesRequest handles getBatchV1APIResources operation.
//
// GET /apis/batch/v1/
func (s *Server) handleGetBatchV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetBatchV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetBatchV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetBatchV1beta1APIResourcesRequest handles getBatchV1beta1APIResources operation.
//
// GET /apis/batch/v1beta1/
func (s *Server) handleGetBatchV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetBatchV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetBatchV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCertificatesAPIGroupRequest handles getCertificatesAPIGroup operation.
//
// GET /apis/certificates.k8s.io/
func (s *Server) handleGetCertificatesAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCertificatesAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCertificatesAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCertificatesV1APIResourcesRequest handles getCertificatesV1APIResources operation.
//
// GET /apis/certificates.k8s.io/v1/
func (s *Server) handleGetCertificatesV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCertificatesV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCertificatesV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCodeVersionRequest handles getCodeVersion operation.
//
// GET /version/
func (s *Server) handleGetCodeVersionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCodeVersion"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCodeVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCodeVersion(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCodeVersionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCoordinationAPIGroupRequest handles getCoordinationAPIGroup operation.
//
// GET /apis/coordination.k8s.io/
func (s *Server) handleGetCoordinationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCoordinationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCoordinationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCoordinationV1APIResourcesRequest handles getCoordinationV1APIResources operation.
//
// GET /apis/coordination.k8s.io/v1/
func (s *Server) handleGetCoordinationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCoordinationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCoordinationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCoreAPIVersionsRequest handles getCoreAPIVersions operation.
//
// GET /api/
func (s *Server) handleGetCoreAPIVersionsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreAPIVersions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreAPIVersions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCoreAPIVersions(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCoreAPIVersionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetCoreV1APIResourcesRequest handles getCoreV1APIResources operation.
//
// GET /api/v1/
func (s *Server) handleGetCoreV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetCoreV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetCoreV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetDiscoveryAPIGroupRequest handles getDiscoveryAPIGroup operation.
//
// GET /apis/discovery.k8s.io/
func (s *Server) handleGetDiscoveryAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetDiscoveryAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetDiscoveryAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetDiscoveryV1APIResourcesRequest handles getDiscoveryV1APIResources operation.
//
// GET /apis/discovery.k8s.io/v1/
func (s *Server) handleGetDiscoveryV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetDiscoveryV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetDiscoveryV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetDiscoveryV1beta1APIResourcesRequest handles getDiscoveryV1beta1APIResources operation.
//
// GET /apis/discovery.k8s.io/v1beta1/
func (s *Server) handleGetDiscoveryV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetDiscoveryV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetDiscoveryV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetEventsAPIGroupRequest handles getEventsAPIGroup operation.
//
// GET /apis/events.k8s.io/
func (s *Server) handleGetEventsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetEventsAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetEventsAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetEventsV1APIResourcesRequest handles getEventsV1APIResources operation.
//
// GET /apis/events.k8s.io/v1/
func (s *Server) handleGetEventsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetEventsV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetEventsV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetEventsV1beta1APIResourcesRequest handles getEventsV1beta1APIResources operation.
//
// GET /apis/events.k8s.io/v1beta1/
func (s *Server) handleGetEventsV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetEventsV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetEventsV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetFlowcontrolApiserverAPIGroupRequest handles getFlowcontrolApiserverAPIGroup operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/
func (s *Server) handleGetFlowcontrolApiserverAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetFlowcontrolApiserverAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetFlowcontrolApiserverV1beta1APIResourcesRequest handles getFlowcontrolApiserverV1beta1APIResources operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/
func (s *Server) handleGetFlowcontrolApiserverV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetFlowcontrolApiserverV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetFlowcontrolApiserverV1beta2APIResourcesRequest handles getFlowcontrolApiserverV1beta2APIResources operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/
func (s *Server) handleGetFlowcontrolApiserverV1beta2APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta2APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetFlowcontrolApiserverV1beta2APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta2APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetInternalApiserverAPIGroupRequest handles getInternalApiserverAPIGroup operation.
//
// GET /apis/internal.apiserver.k8s.io/
func (s *Server) handleGetInternalApiserverAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetInternalApiserverAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetInternalApiserverAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetInternalApiserverV1alpha1APIResourcesRequest handles getInternalApiserverV1alpha1APIResources operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/
func (s *Server) handleGetInternalApiserverV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverV1alpha1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetInternalApiserverV1alpha1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetInternalApiserverV1alpha1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNetworkingAPIGroupRequest handles getNetworkingAPIGroup operation.
//
// GET /apis/networking.k8s.io/
func (s *Server) handleGetNetworkingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNetworkingAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNetworkingAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNetworkingV1APIResourcesRequest handles getNetworkingV1APIResources operation.
//
// GET /apis/networking.k8s.io/v1/
func (s *Server) handleGetNetworkingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNetworkingV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNetworkingV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNodeAPIGroupRequest handles getNodeAPIGroup operation.
//
// GET /apis/node.k8s.io/
func (s *Server) handleGetNodeAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNodeAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNodeAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNodeV1APIResourcesRequest handles getNodeV1APIResources operation.
//
// GET /apis/node.k8s.io/v1/
func (s *Server) handleGetNodeV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNodeV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNodeV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNodeV1alpha1APIResourcesRequest handles getNodeV1alpha1APIResources operation.
//
// GET /apis/node.k8s.io/v1alpha1/
func (s *Server) handleGetNodeV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1alpha1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNodeV1alpha1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNodeV1alpha1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetNodeV1beta1APIResourcesRequest handles getNodeV1beta1APIResources operation.
//
// GET /apis/node.k8s.io/v1beta1/
func (s *Server) handleGetNodeV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetNodeV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetNodeV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetPolicyAPIGroupRequest handles getPolicyAPIGroup operation.
//
// GET /apis/policy/
func (s *Server) handleGetPolicyAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetPolicyAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetPolicyAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetPolicyV1APIResourcesRequest handles getPolicyV1APIResources operation.
//
// GET /apis/policy/v1/
func (s *Server) handleGetPolicyV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetPolicyV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetPolicyV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetPolicyV1beta1APIResourcesRequest handles getPolicyV1beta1APIResources operation.
//
// GET /apis/policy/v1beta1/
func (s *Server) handleGetPolicyV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetPolicyV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetPolicyV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetRbacAuthorizationAPIGroupRequest handles getRbacAuthorizationAPIGroup operation.
//
// GET /apis/rbac.authorization.k8s.io/
func (s *Server) handleGetRbacAuthorizationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetRbacAuthorizationAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetRbacAuthorizationAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetRbacAuthorizationV1APIResourcesRequest handles getRbacAuthorizationV1APIResources operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/
func (s *Server) handleGetRbacAuthorizationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetRbacAuthorizationV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetRbacAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetSchedulingAPIGroupRequest handles getSchedulingAPIGroup operation.
//
// GET /apis/scheduling.k8s.io/
func (s *Server) handleGetSchedulingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetSchedulingAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetSchedulingAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetSchedulingV1APIResourcesRequest handles getSchedulingV1APIResources operation.
//
// GET /apis/scheduling.k8s.io/v1/
func (s *Server) handleGetSchedulingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetSchedulingV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetSchedulingV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetServiceAccountIssuerOpenIDConfigurationRequest handles getServiceAccountIssuerOpenIDConfiguration operation.
//
// GET /.well-known/openid-configuration/
func (s *Server) handleGetServiceAccountIssuerOpenIDConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServiceAccountIssuerOpenIDConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetServiceAccountIssuerOpenIDConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetServiceAccountIssuerOpenIDConfiguration(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetServiceAccountIssuerOpenIDConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetStorageAPIGroupRequest handles getStorageAPIGroup operation.
//
// GET /apis/storage.k8s.io/
func (s *Server) handleGetStorageAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageAPIGroup"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetStorageAPIGroup(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetStorageAPIGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetStorageV1APIResourcesRequest handles getStorageV1APIResources operation.
//
// GET /apis/storage.k8s.io/v1/
func (s *Server) handleGetStorageV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetStorageV1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetStorageV1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetStorageV1alpha1APIResourcesRequest handles getStorageV1alpha1APIResources operation.
//
// GET /apis/storage.k8s.io/v1alpha1/
func (s *Server) handleGetStorageV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1alpha1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetStorageV1alpha1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetStorageV1alpha1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGetStorageV1beta1APIResourcesRequest handles getStorageV1beta1APIResources operation.
//
// GET /apis/storage.k8s.io/v1beta1/
func (s *Server) handleGetStorageV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1beta1APIResources"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.GetStorageV1beta1APIResources(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGetStorageV1beta1APIResourcesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAdmissionregistrationV1MutatingWebhookConfigurationRequest handles listAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1MutatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles listAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListApiextensionsV1CustomResourceDefinitionRequest handles listApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions
func (s *Server) handleListApiextensionsV1CustomResourceDefinitionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiextensionsV1CustomResourceDefinition"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListApiextensionsV1CustomResourceDefinition(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListApiregistrationV1APIServiceRequest handles listApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices
func (s *Server) handleListApiregistrationV1APIServiceRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiregistrationV1APIService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListApiregistrationV1APIService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1ControllerRevisionForAllNamespacesRequest handles listAppsV1ControllerRevisionForAllNamespaces operation.
//
// GET /apis/apps/v1/controllerrevisions
func (s *Server) handleListAppsV1ControllerRevisionForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ControllerRevisionForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ControllerRevisionForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1ControllerRevisionForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1ControllerRevisionForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1ControllerRevisionForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1DaemonSetForAllNamespacesRequest handles listAppsV1DaemonSetForAllNamespaces operation.
//
// GET /apis/apps/v1/daemonsets
func (s *Server) handleListAppsV1DaemonSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DaemonSetForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DaemonSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1DaemonSetForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1DaemonSetForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1DaemonSetForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1DeploymentForAllNamespacesRequest handles listAppsV1DeploymentForAllNamespaces operation.
//
// GET /apis/apps/v1/deployments
func (s *Server) handleListAppsV1DeploymentForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DeploymentForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DeploymentForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1DeploymentForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1DeploymentForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1DeploymentForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1NamespacedControllerRevisionRequest handles listAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions
func (s *Server) handleListAppsV1NamespacedControllerRevisionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedControllerRevision"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1NamespacedControllerRevision(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1NamespacedDaemonSetRequest handles listAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets
func (s *Server) handleListAppsV1NamespacedDaemonSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDaemonSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1NamespacedDaemonSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1NamespacedDeploymentRequest handles listAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments
func (s *Server) handleListAppsV1NamespacedDeploymentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDeployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1NamespacedDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1NamespacedReplicaSetRequest handles listAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets
func (s *Server) handleListAppsV1NamespacedReplicaSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedReplicaSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1NamespacedReplicaSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1NamespacedStatefulSetRequest handles listAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets
func (s *Server) handleListAppsV1NamespacedStatefulSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedStatefulSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1NamespacedStatefulSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1ReplicaSetForAllNamespacesRequest handles listAppsV1ReplicaSetForAllNamespaces operation.
//
// GET /apis/apps/v1/replicasets
func (s *Server) handleListAppsV1ReplicaSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ReplicaSetForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ReplicaSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1ReplicaSetForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1ReplicaSetForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1ReplicaSetForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAppsV1StatefulSetForAllNamespacesRequest handles listAppsV1StatefulSetForAllNamespaces operation.
//
// GET /apis/apps/v1/statefulsets
func (s *Server) handleListAppsV1StatefulSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1StatefulSetForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1StatefulSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAppsV1StatefulSetForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAppsV1StatefulSetForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAppsV1StatefulSetForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta2/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1CronJobForAllNamespacesRequest handles listBatchV1CronJobForAllNamespaces operation.
//
// GET /apis/batch/v1/cronjobs
func (s *Server) handleListBatchV1CronJobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1CronJobForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1CronJobForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1CronJobForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1JobForAllNamespacesRequest handles listBatchV1JobForAllNamespaces operation.
//
// GET /apis/batch/v1/jobs
func (s *Server) handleListBatchV1JobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1JobForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1JobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1JobForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1JobForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1JobForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1NamespacedCronJobRequest handles listBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1NamespacedCronJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1NamespacedJobRequest handles listBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs
func (s *Server) handleListBatchV1NamespacedJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1NamespacedJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1NamespacedJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1NamespacedJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1beta1CronJobForAllNamespacesRequest handles listBatchV1beta1CronJobForAllNamespaces operation.
//
// GET /apis/batch/v1beta1/cronjobs
func (s *Server) handleListBatchV1beta1CronJobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1CronJobForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1beta1CronJobForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1beta1CronJobForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1beta1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListBatchV1beta1NamespacedCronJobRequest handles listBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1beta1NamespacedCronJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListBatchV1beta1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCertificatesV1CertificateSigningRequestRequest handles listCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests
func (s *Server) handleListCertificatesV1CertificateSigningRequestRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCertificatesV1CertificateSigningRequest"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCertificatesV1CertificateSigningRequest(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoordinationV1LeaseForAllNamespacesRequest handles listCoordinationV1LeaseForAllNamespaces operation.
//
// GET /apis/coordination.k8s.io/v1/leases
func (s *Server) handleListCoordinationV1LeaseForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1LeaseForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1LeaseForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoordinationV1LeaseForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoordinationV1LeaseForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoordinationV1LeaseForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoordinationV1NamespacedLeaseRequest handles listCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases
func (s *Server) handleListCoordinationV1NamespacedLeaseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1NamespacedLease"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoordinationV1NamespacedLease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ComponentStatusRequest handles listCoreV1ComponentStatus operation.
//
// GET /api/v1/componentstatuses
func (s *Server) handleListCoreV1ComponentStatusRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ComponentStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ComponentStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ComponentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ComponentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ConfigMapForAllNamespacesRequest handles listCoreV1ConfigMapForAllNamespaces operation.
//
// GET /api/v1/configmaps
func (s *Server) handleListCoreV1ConfigMapForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ConfigMapForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ConfigMapForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ConfigMapForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ConfigMapForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ConfigMapForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1EndpointsForAllNamespacesRequest handles listCoreV1EndpointsForAllNamespaces operation.
//
// GET /api/v1/endpoints
func (s *Server) handleListCoreV1EndpointsForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EndpointsForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EndpointsForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1EndpointsForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1EndpointsForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1EndpointsForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1EventForAllNamespacesRequest handles listCoreV1EventForAllNamespaces operation.
//
// GET /api/v1/events
func (s *Server) handleListCoreV1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EventForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1EventForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1EventForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1EventForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1LimitRangeForAllNamespacesRequest handles listCoreV1LimitRangeForAllNamespaces operation.
//
// GET /api/v1/limitranges
func (s *Server) handleListCoreV1LimitRangeForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1LimitRangeForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1LimitRangeForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1LimitRangeForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1LimitRangeForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1LimitRangeForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespaceRequest handles listCoreV1Namespace operation.
//
// GET /api/v1/namespaces
func (s *Server) handleListCoreV1NamespaceRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Namespace"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespaceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1Namespace(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespaceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedConfigMapRequest handles listCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/namespaces/{namespace}/configmaps
func (s *Server) handleListCoreV1NamespacedConfigMapRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedConfigMap"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedConfigMap(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedEndpointsRequest handles listCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/namespaces/{namespace}/endpoints
func (s *Server) handleListCoreV1NamespacedEndpointsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEndpoints"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedEndpoints(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedEventRequest handles listCoreV1NamespacedEvent operation.
//
// GET /api/v1/namespaces/{namespace}/events
func (s *Server) handleListCoreV1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedLimitRangeRequest handles listCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/namespaces/{namespace}/limitranges
func (s *Server) handleListCoreV1NamespacedLimitRangeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedLimitRange"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedLimitRange(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedPersistentVolumeClaimRequest handles listCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleListCoreV1NamespacedPersistentVolumeClaimRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPersistentVolumeClaim"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedPodRequest handles listCoreV1NamespacedPod operation.
//
// GET /api/v1/namespaces/{namespace}/pods
func (s *Server) handleListCoreV1NamespacedPodRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPod"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedPodParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedPod(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedPodTemplateRequest handles listCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/namespaces/{namespace}/podtemplates
func (s *Server) handleListCoreV1NamespacedPodTemplateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPodTemplate"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedPodTemplate(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedReplicationControllerRequest handles listCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleListCoreV1NamespacedReplicationControllerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedReplicationController"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedReplicationController(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedResourceQuotaRequest handles listCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas
func (s *Server) handleListCoreV1NamespacedResourceQuotaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedResourceQuota"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedResourceQuota(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedSecretRequest handles listCoreV1NamespacedSecret operation.
//
// GET /api/v1/namespaces/{namespace}/secrets
func (s *Server) handleListCoreV1NamespacedSecretRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedSecret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedServiceRequest handles listCoreV1NamespacedService operation.
//
// GET /api/v1/namespaces/{namespace}/services
func (s *Server) handleListCoreV1NamespacedServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NamespacedServiceAccountRequest handles listCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts
func (s *Server) handleListCoreV1NamespacedServiceAccountRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedServiceAccount"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1NamespacedServiceAccount(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1NodeRequest handles listCoreV1Node operation.
//
// GET /api/v1/nodes
func (s *Server) handleListCoreV1NodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Node"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1NodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1Node(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1NodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1PersistentVolumeRequest handles listCoreV1PersistentVolume operation.
//
// GET /api/v1/persistentvolumes
func (s *Server) handleListCoreV1PersistentVolumeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolume"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1PersistentVolume(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1PersistentVolumeClaimForAllNamespacesRequest handles listCoreV1PersistentVolumeClaimForAllNamespaces operation.
//
// GET /api/v1/persistentvolumeclaims
func (s *Server) handleListCoreV1PersistentVolumeClaimForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolumeClaimForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolumeClaimForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1PersistentVolumeClaimForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeClaimForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1PodForAllNamespacesRequest handles listCoreV1PodForAllNamespaces operation.
//
// GET /api/v1/pods
func (s *Server) handleListCoreV1PodForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1PodForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1PodForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1PodForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1PodTemplateForAllNamespacesRequest handles listCoreV1PodTemplateForAllNamespaces operation.
//
// GET /api/v1/podtemplates
func (s *Server) handleListCoreV1PodTemplateForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodTemplateForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodTemplateForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1PodTemplateForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1PodTemplateForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1PodTemplateForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ReplicationControllerForAllNamespacesRequest handles listCoreV1ReplicationControllerForAllNamespaces operation.
//
// GET /api/v1/replicationcontrollers
func (s *Server) handleListCoreV1ReplicationControllerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ReplicationControllerForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ReplicationControllerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ReplicationControllerForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ReplicationControllerForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ReplicationControllerForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ResourceQuotaForAllNamespacesRequest handles listCoreV1ResourceQuotaForAllNamespaces operation.
//
// GET /api/v1/resourcequotas
func (s *Server) handleListCoreV1ResourceQuotaForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ResourceQuotaForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ResourceQuotaForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ResourceQuotaForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ResourceQuotaForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ResourceQuotaForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1SecretForAllNamespacesRequest handles listCoreV1SecretForAllNamespaces operation.
//
// GET /api/v1/secrets
func (s *Server) handleListCoreV1SecretForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1SecretForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1SecretForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1SecretForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1SecretForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1SecretForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ServiceAccountForAllNamespacesRequest handles listCoreV1ServiceAccountForAllNamespaces operation.
//
// GET /api/v1/serviceaccounts
func (s *Server) handleListCoreV1ServiceAccountForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceAccountForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceAccountForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ServiceAccountForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ServiceAccountForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ServiceAccountForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListCoreV1ServiceForAllNamespacesRequest handles listCoreV1ServiceForAllNamespaces operation.
//
// GET /api/v1/services
func (s *Server) handleListCoreV1ServiceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListCoreV1ServiceForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListCoreV1ServiceForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListCoreV1ServiceForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListDiscoveryV1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1EndpointSliceForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1/endpointslices
func (s *Server) handleListDiscoveryV1EndpointSliceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1EndpointSliceForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListDiscoveryV1EndpointSliceForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListDiscoveryV1EndpointSliceForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListDiscoveryV1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListDiscoveryV1NamespacedEndpointSliceRequest handles listDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1NamespacedEndpointSliceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListDiscoveryV1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1beta1EndpointSliceForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1beta1/endpointslices
func (s *Server) handleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1EndpointSliceForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListDiscoveryV1beta1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListDiscoveryV1beta1NamespacedEndpointSliceRequest handles listDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1beta1NamespacedEndpointSliceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListEventsV1EventForAllNamespacesRequest handles listEventsV1EventForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1/events
func (s *Server) handleListEventsV1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1EventForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListEventsV1EventForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListEventsV1EventForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListEventsV1EventForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListEventsV1NamespacedEventRequest handles listEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListEventsV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListEventsV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListEventsV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListEventsV1beta1EventForAllNamespacesRequest handles listEventsV1beta1EventForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1beta1/events
func (s *Server) handleListEventsV1beta1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1EventForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListEventsV1beta1EventForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListEventsV1beta1EventForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListEventsV1beta1EventForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListEventsV1beta1NamespacedEventRequest handles listEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1beta1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListEventsV1beta1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListFlowcontrolApiserverV1beta1FlowSchemaRequest handles listFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta1FlowSchemaRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListFlowcontrolApiserverV1beta2FlowSchemaRequest handles listFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta2FlowSchemaRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListInternalApiserverV1alpha1StorageVersionRequest handles listInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions
func (s *Server) handleListInternalApiserverV1alpha1StorageVersionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listInternalApiserverV1alpha1StorageVersion"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListInternalApiserverV1alpha1StorageVersion(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNetworkingV1IngressClassRequest handles listNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/ingressclasses
func (s *Server) handleListNetworkingV1IngressClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNetworkingV1IngressClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNetworkingV1IngressClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNetworkingV1IngressClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNetworkingV1IngressForAllNamespacesRequest handles listNetworkingV1IngressForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/ingresses
func (s *Server) handleListNetworkingV1IngressForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNetworkingV1IngressForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNetworkingV1IngressForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNetworkingV1IngressForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNetworkingV1NamespacedIngressRequest handles listNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses
func (s *Server) handleListNetworkingV1NamespacedIngressRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedIngress"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNetworkingV1NamespacedIngress(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNetworkingV1NamespacedNetworkPolicyRequest handles listNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies
func (s *Server) handleListNetworkingV1NamespacedNetworkPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedNetworkPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNetworkingV1NamespacedNetworkPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNetworkingV1NetworkPolicyForAllNamespacesRequest handles listNetworkingV1NetworkPolicyForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/networkpolicies
func (s *Server) handleListNetworkingV1NetworkPolicyForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NetworkPolicyForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NetworkPolicyForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNetworkingV1NetworkPolicyForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNetworkingV1NetworkPolicyForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNetworkingV1NetworkPolicyForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNodeV1RuntimeClassRequest handles listNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/runtimeclasses
func (s *Server) handleListNodeV1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNodeV1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNodeV1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNodeV1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNodeV1alpha1RuntimeClassRequest handles listNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses
func (s *Server) handleListNodeV1alpha1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1alpha1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNodeV1alpha1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListNodeV1beta1RuntimeClassRequest handles listNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses
func (s *Server) handleListNodeV1beta1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1beta1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListNodeV1beta1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListPolicyV1NamespacedPodDisruptionBudgetRequest handles listPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1NamespacedPodDisruptionBudgetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1PodDisruptionBudgetForAllNamespaces operation.
//
// GET /apis/policy/v1/poddisruptionbudgets
func (s *Server) handleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1PodDisruptionBudgetForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListPolicyV1PodDisruptionBudgetForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListPolicyV1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles listPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1beta1PodDisruptionBudgetForAllNamespaces operation.
//
// GET /apis/policy/v1beta1/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodDisruptionBudgetForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListPolicyV1beta1PodSecurityPolicyRequest handles listPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/podsecuritypolicies
func (s *Server) handleListPolicyV1beta1PodSecurityPolicyRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodSecurityPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListPolicyV1beta1PodSecurityPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1ClusterRoleRequest handles listRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles
func (s *Server) handleListRbacAuthorizationV1ClusterRoleRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1ClusterRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1ClusterRoleBindingRequest handles listRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings
func (s *Server) handleListRbacAuthorizationV1ClusterRoleBindingRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1NamespacedRoleRequest handles listRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1NamespacedRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1NamespacedRoleBindingRequest handles listRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest handles listRbacAuthorizationV1RoleBindingForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/rolebindings
func (s *Server) handleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleBindingForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1RoleBindingForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleBindingForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListRbacAuthorizationV1RoleForAllNamespacesRequest handles listRbacAuthorizationV1RoleForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/roles
func (s *Server) handleListRbacAuthorizationV1RoleForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListRbacAuthorizationV1RoleForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListRbacAuthorizationV1RoleForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListSchedulingV1PriorityClassRequest handles listSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses
func (s *Server) handleListSchedulingV1PriorityClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSchedulingV1PriorityClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListSchedulingV1PriorityClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1CSIDriverRequest handles listStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/csidrivers
func (s *Server) handleListStorageV1CSIDriverRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSIDriver"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1CSIDriverParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1CSIDriver(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1CSIDriverResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1CSINodeRequest handles listStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/csinodes
func (s *Server) handleListStorageV1CSINodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSINode"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1CSINodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1CSINode(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1CSINodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1StorageClassRequest handles listStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/storageclasses
func (s *Server) handleListStorageV1StorageClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1StorageClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1StorageClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1StorageClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1StorageClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1VolumeAttachmentRequest handles listStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments
func (s *Server) handleListStorageV1VolumeAttachmentRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1VolumeAttachment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1VolumeAttachment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1alpha1CSIStorageCapacityForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1alpha1/csistoragecapacities
func (s *Server) handleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1CSIStorageCapacityForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1alpha1NamespacedCSIStorageCapacityRequest handles listStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1beta1CSIStorageCapacityForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1beta1/csistoragecapacities
func (s *Server) handleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1CSIStorageCapacityForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1beta1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleListStorageV1beta1NamespacedCSIStorageCapacityRequest handles listStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1beta1NamespacedCSIStorageCapacityRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeListStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ListStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeListStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleLogFileHandlerRequest handles logFileHandler operation.
//
// GET /logs/{logpath}
func (s *Server) handleLogFileHandlerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileHandler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileHandler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeLogFileHandlerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.LogFileHandler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLogFileHandlerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleLogFileListHandlerRequest handles logFileListHandler operation.
//
// GET /logs/
func (s *Server) handleLogFileListHandlerRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileListHandler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileListHandler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	response, err := s.h.LogFileListHandler(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLogFileListHandlerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest handles readAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1MutatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles readAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadApiextensionsV1CustomResourceDefinitionRequest handles readApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinition"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadApiextensionsV1CustomResourceDefinition(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadApiextensionsV1CustomResourceDefinitionStatusRequest handles readApiextensionsV1CustomResourceDefinitionStatus operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinitionStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinitionStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadApiextensionsV1CustomResourceDefinitionStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadApiregistrationV1APIServiceRequest handles readApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}
func (s *Server) handleReadApiregistrationV1APIServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadApiregistrationV1APIService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadApiregistrationV1APIServiceStatusRequest handles readApiregistrationV1APIServiceStatus operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}/status
func (s *Server) handleReadApiregistrationV1APIServiceStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIServiceStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIServiceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadApiregistrationV1APIServiceStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadApiregistrationV1APIServiceStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedControllerRevisionRequest handles readAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleReadAppsV1NamespacedControllerRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedControllerRevision"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedControllerRevision(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedDaemonSetRequest handles readAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleReadAppsV1NamespacedDaemonSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedDaemonSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedDaemonSetStatusRequest handles readAppsV1NamespacedDaemonSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedDaemonSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSetStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedDaemonSetStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedDaemonSetStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedDeploymentRequest handles readAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
func (s *Server) handleReadAppsV1NamespacedDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedDeploymentScaleRequest handles readAppsV1NamespacedDeploymentScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale
func (s *Server) handleReadAppsV1NamespacedDeploymentScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentScale"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedDeploymentScaleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedDeploymentScale(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentScaleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedDeploymentStatusRequest handles readAppsV1NamespacedDeploymentStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/status
func (s *Server) handleReadAppsV1NamespacedDeploymentStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedDeploymentStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedDeploymentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedReplicaSetRequest handles readAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleReadAppsV1NamespacedReplicaSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedReplicaSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedReplicaSetScaleRequest handles readAppsV1NamespacedReplicaSetScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedReplicaSetScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetScale"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedReplicaSetScaleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedReplicaSetScale(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetScaleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedReplicaSetStatusRequest handles readAppsV1NamespacedReplicaSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status
func (s *Server) handleReadAppsV1NamespacedReplicaSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedReplicaSetStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedReplicaSetStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedStatefulSetRequest handles readAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleReadAppsV1NamespacedStatefulSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedStatefulSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedStatefulSetScaleRequest handles readAppsV1NamespacedStatefulSetScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedStatefulSetScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetScale"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedStatefulSetScaleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedStatefulSetScale(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetScaleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAppsV1NamespacedStatefulSetStatusRequest handles readAppsV1NamespacedStatefulSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedStatefulSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAppsV1NamespacedStatefulSetStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAppsV1NamespacedStatefulSetStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1NamespacedCronJobRequest handles readBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1NamespacedCronJobStatusRequest handles readBatchV1NamespacedCronJobStatus operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedCronJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJobStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1NamespacedCronJobStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1NamespacedCronJobStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1NamespacedJobRequest handles readBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}
func (s *Server) handleReadBatchV1NamespacedJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1NamespacedJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1NamespacedJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1NamespacedJobStatusRequest handles readBatchV1NamespacedJobStatus operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJobStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1NamespacedJobStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1NamespacedJobStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1beta1NamespacedCronJobRequest handles readBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1beta1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1beta1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadBatchV1beta1NamespacedCronJobStatusRequest handles readBatchV1beta1NamespacedCronJobStatus operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1beta1NamespacedCronJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJobStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadBatchV1beta1NamespacedCronJobStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadBatchV1beta1NamespacedCronJobStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCertificatesV1CertificateSigningRequestRequest handles readCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}
func (s *Server) handleReadCertificatesV1CertificateSigningRequestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequest"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCertificatesV1CertificateSigningRequest(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCertificatesV1CertificateSigningRequestApprovalRequest handles readCertificatesV1CertificateSigningRequestApproval operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval
func (s *Server) handleReadCertificatesV1CertificateSigningRequestApprovalRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestApproval"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestApproval",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCertificatesV1CertificateSigningRequestApprovalParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCertificatesV1CertificateSigningRequestApproval(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestApprovalResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCertificatesV1CertificateSigningRequestStatusRequest handles readCertificatesV1CertificateSigningRequestStatus operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status
func (s *Server) handleReadCertificatesV1CertificateSigningRequestStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCertificatesV1CertificateSigningRequestStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCertificatesV1CertificateSigningRequestStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoordinationV1NamespacedLeaseRequest handles readCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}
func (s *Server) handleReadCoordinationV1NamespacedLeaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoordinationV1NamespacedLease"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoordinationV1NamespacedLease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1ComponentStatusRequest handles readCoreV1ComponentStatus operation.
//
// GET /api/v1/componentstatuses/{name}
func (s *Server) handleReadCoreV1ComponentStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1ComponentStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1ComponentStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1ComponentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1ComponentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespaceRequest handles readCoreV1Namespace operation.
//
// GET /api/v1/namespaces/{name}
func (s *Server) handleReadCoreV1NamespaceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Namespace"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespaceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1Namespace(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespaceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespaceStatusRequest handles readCoreV1NamespaceStatus operation.
//
// GET /api/v1/namespaces/{name}/status
func (s *Server) handleReadCoreV1NamespaceStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespaceStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespaceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespaceStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespaceStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespaceStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedConfigMapRequest handles readCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleReadCoreV1NamespacedConfigMapRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedConfigMap"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedConfigMap(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedEndpointsRequest handles readCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleReadCoreV1NamespacedEndpointsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEndpoints"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedEndpoints(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedEventRequest handles readCoreV1NamespacedEvent operation.
//
// GET /api/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadCoreV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedLimitRangeRequest handles readCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleReadCoreV1NamespacedLimitRangeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedLimitRange"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedLimitRange(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPersistentVolumeClaimRequest handles readCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaim"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest handles readCoreV1NamespacedPersistentVolumeClaimStatus operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaimStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPersistentVolumeClaimStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPodRequest handles readCoreV1NamespacedPod operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}
func (s *Server) handleReadCoreV1NamespacedPodRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPod"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPodParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPod(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPodEphemeralcontainersRequest handles readCoreV1NamespacedPodEphemeralcontainers operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers
func (s *Server) handleReadCoreV1NamespacedPodEphemeralcontainersRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodEphemeralcontainers"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodEphemeralcontainers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPodEphemeralcontainersParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPodEphemeralcontainers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodEphemeralcontainersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPodLogRequest handles readCoreV1NamespacedPodLog operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/log
func (s *Server) handleReadCoreV1NamespacedPodLogRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodLog"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPodLogParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPodLog(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodLogResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPodStatusRequest handles readCoreV1NamespacedPodStatus operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/status
func (s *Server) handleReadCoreV1NamespacedPodStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPodStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPodStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedPodTemplateRequest handles readCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleReadCoreV1NamespacedPodTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodTemplate"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedPodTemplate(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedReplicationControllerRequest handles readCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleReadCoreV1NamespacedReplicationControllerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationController"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedReplicationController(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedReplicationControllerScaleRequest handles readCoreV1NamespacedReplicationControllerScale operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale
func (s *Server) handleReadCoreV1NamespacedReplicationControllerScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerScale"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedReplicationControllerScaleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedReplicationControllerScale(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerScaleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedReplicationControllerStatusRequest handles readCoreV1NamespacedReplicationControllerStatus operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status
func (s *Server) handleReadCoreV1NamespacedReplicationControllerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedReplicationControllerStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedReplicationControllerStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedResourceQuotaRequest handles readCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleReadCoreV1NamespacedResourceQuotaRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuota"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedResourceQuota(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedResourceQuotaStatusRequest handles readCoreV1NamespacedResourceQuotaStatus operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status
func (s *Server) handleReadCoreV1NamespacedResourceQuotaStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuotaStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuotaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedResourceQuotaStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedResourceQuotaStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedSecretRequest handles readCoreV1NamespacedSecret operation.
//
// GET /api/v1/namespaces/{namespace}/secrets/{name}
func (s *Server) handleReadCoreV1NamespacedSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedSecret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedServiceRequest handles readCoreV1NamespacedService operation.
//
// GET /api/v1/namespaces/{namespace}/services/{name}
func (s *Server) handleReadCoreV1NamespacedServiceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedServiceAccountRequest handles readCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleReadCoreV1NamespacedServiceAccountRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceAccount"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedServiceAccount(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NamespacedServiceStatusRequest handles readCoreV1NamespacedServiceStatus operation.
//
// GET /api/v1/namespaces/{namespace}/services/{name}/status
func (s *Server) handleReadCoreV1NamespacedServiceStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NamespacedServiceStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NamespacedServiceStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NodeRequest handles readCoreV1Node operation.
//
// GET /api/v1/nodes/{name}
func (s *Server) handleReadCoreV1NodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Node"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1Node(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1NodeStatusRequest handles readCoreV1NodeStatus operation.
//
// GET /api/v1/nodes/{name}/status
func (s *Server) handleReadCoreV1NodeStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NodeStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NodeStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1NodeStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1NodeStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1NodeStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1PersistentVolumeRequest handles readCoreV1PersistentVolume operation.
//
// GET /api/v1/persistentvolumes/{name}
func (s *Server) handleReadCoreV1PersistentVolumeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolume"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1PersistentVolume(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadCoreV1PersistentVolumeStatusRequest handles readCoreV1PersistentVolumeStatus operation.
//
// GET /api/v1/persistentvolumes/{name}/status
func (s *Server) handleReadCoreV1PersistentVolumeStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolumeStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolumeStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadCoreV1PersistentVolumeStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadCoreV1PersistentVolumeStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadDiscoveryV1NamespacedEndpointSliceRequest handles readDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadDiscoveryV1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadDiscoveryV1beta1NamespacedEndpointSliceRequest handles readDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1beta1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadEventsV1NamespacedEventRequest handles readEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadEventsV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadEventsV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadEventsV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadEventsV1beta1NamespacedEventRequest handles readEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1beta1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1beta1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadEventsV1beta1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta1FlowSchemaRequest handles readFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta1FlowSchemaStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchemaStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta1FlowSchemaStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta2FlowSchemaRequest handles readFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta2FlowSchemaStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchemaStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta2FlowSchemaStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadInternalApiserverV1alpha1StorageVersionRequest handles readInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersion"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadInternalApiserverV1alpha1StorageVersion(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadInternalApiserverV1alpha1StorageVersionStatusRequest handles readInternalApiserverV1alpha1StorageVersionStatus operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersionStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersionStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadInternalApiserverV1alpha1StorageVersionStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNetworkingV1IngressClassRequest handles readNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/ingressclasses/{name}
func (s *Server) handleReadNetworkingV1IngressClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1IngressClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNetworkingV1IngressClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNetworkingV1IngressClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNetworkingV1IngressClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNetworkingV1NamespacedIngressRequest handles readNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleReadNetworkingV1NamespacedIngressRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngress"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNetworkingV1NamespacedIngress(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNetworkingV1NamespacedIngressStatusRequest handles readNetworkingV1NamespacedIngressStatus operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status
func (s *Server) handleReadNetworkingV1NamespacedIngressStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngressStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngressStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNetworkingV1NamespacedIngressStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNetworkingV1NamespacedIngressStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNetworkingV1NamespacedNetworkPolicyRequest handles readNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleReadNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedNetworkPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNetworkingV1NamespacedNetworkPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNodeV1RuntimeClassRequest handles readNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNodeV1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNodeV1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNodeV1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNodeV1alpha1RuntimeClassRequest handles readNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1alpha1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1alpha1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNodeV1alpha1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadNodeV1beta1RuntimeClassRequest handles readNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1beta1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1beta1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadNodeV1beta1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadPolicyV1NamespacedPodDisruptionBudgetRequest handles readPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1NamespacedPodDisruptionBudgetStatus operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudgetStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadPolicyV1NamespacedPodDisruptionBudgetStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles readPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1beta1NamespacedPodDisruptionBudgetStatus operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudgetStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadPolicyV1beta1PodSecurityPolicyRequest handles readPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/podsecuritypolicies/{name}
func (s *Server) handleReadPolicyV1beta1PodSecurityPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1PodSecurityPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadPolicyV1beta1PodSecurityPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadRbacAuthorizationV1ClusterRoleRequest handles readRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadRbacAuthorizationV1ClusterRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadRbacAuthorizationV1ClusterRoleBindingRequest handles readRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadRbacAuthorizationV1NamespacedRoleRequest handles readRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadRbacAuthorizationV1NamespacedRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadRbacAuthorizationV1NamespacedRoleBindingRequest handles readRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadSchedulingV1PriorityClassRequest handles readSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses/{name}
func (s *Server) handleReadSchedulingV1PriorityClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readSchedulingV1PriorityClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadSchedulingV1PriorityClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1CSIDriverRequest handles readStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/csidrivers/{name}
func (s *Server) handleReadStorageV1CSIDriverRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSIDriver"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1CSIDriverParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1CSIDriver(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1CSIDriverResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1CSINodeRequest handles readStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/csinodes/{name}
func (s *Server) handleReadStorageV1CSINodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSINode"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1CSINodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1CSINode(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1CSINodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1StorageClassRequest handles readStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/storageclasses/{name}
func (s *Server) handleReadStorageV1StorageClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1StorageClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1StorageClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1StorageClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1StorageClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1VolumeAttachmentRequest handles readStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}
func (s *Server) handleReadStorageV1VolumeAttachmentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1VolumeAttachment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1VolumeAttachmentStatusRequest handles readStorageV1VolumeAttachmentStatus operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}/status
func (s *Server) handleReadStorageV1VolumeAttachmentStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachmentStatus"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachmentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1VolumeAttachmentStatusParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1VolumeAttachmentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest handles readStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1alpha1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReadStorageV1beta1NamespacedCSIStorageCapacityRequest handles readStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1beta1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeReadStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReadStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReadStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest handles watchAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1MutatingWebhookConfigurationList operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfigurationList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles watchAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1ValidatingWebhookConfigurationList operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfigurationList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchApiextensionsV1CustomResourceDefinitionRequest handles watchApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinition"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchApiextensionsV1CustomResourceDefinition(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchApiextensionsV1CustomResourceDefinitionListRequest handles watchApiextensionsV1CustomResourceDefinitionList operation.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinitionList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinitionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchApiextensionsV1CustomResourceDefinitionList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchApiregistrationV1APIServiceRequest handles watchApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices/{name}
func (s *Server) handleWatchApiregistrationV1APIServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchApiregistrationV1APIService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchApiregistrationV1APIServiceListRequest handles watchApiregistrationV1APIServiceList operation.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices
func (s *Server) handleWatchApiregistrationV1APIServiceListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIServiceList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIServiceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchApiregistrationV1APIServiceListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchApiregistrationV1APIServiceList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1ControllerRevisionListForAllNamespacesRequest handles watchAppsV1ControllerRevisionListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/controllerrevisions
func (s *Server) handleWatchAppsV1ControllerRevisionListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ControllerRevisionListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ControllerRevisionListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1ControllerRevisionListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1ControllerRevisionListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1ControllerRevisionListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1DaemonSetListForAllNamespacesRequest handles watchAppsV1DaemonSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/daemonsets
func (s *Server) handleWatchAppsV1DaemonSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DaemonSetListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DaemonSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1DaemonSetListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1DaemonSetListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1DaemonSetListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1DeploymentListForAllNamespacesRequest handles watchAppsV1DeploymentListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/deployments
func (s *Server) handleWatchAppsV1DeploymentListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DeploymentListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DeploymentListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1DeploymentListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1DeploymentListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1DeploymentListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedControllerRevisionRequest handles watchAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevision"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedControllerRevision(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedControllerRevisionListRequest handles watchAppsV1NamespacedControllerRevisionList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevisionList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevisionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedControllerRevisionListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedControllerRevisionList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedDaemonSetRequest handles watchAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleWatchAppsV1NamespacedDaemonSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedDaemonSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedDaemonSetListRequest handles watchAppsV1NamespacedDaemonSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets
func (s *Server) handleWatchAppsV1NamespacedDaemonSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSetList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedDaemonSetListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedDaemonSetList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedDeploymentRequest handles watchAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}
func (s *Server) handleWatchAppsV1NamespacedDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedDeploymentListRequest handles watchAppsV1NamespacedDeploymentList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments
func (s *Server) handleWatchAppsV1NamespacedDeploymentListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeploymentList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeploymentList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedDeploymentListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedDeploymentList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedReplicaSetRequest handles watchAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleWatchAppsV1NamespacedReplicaSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedReplicaSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedReplicaSetListRequest handles watchAppsV1NamespacedReplicaSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets
func (s *Server) handleWatchAppsV1NamespacedReplicaSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSetList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedReplicaSetListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedReplicaSetList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedStatefulSetRequest handles watchAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleWatchAppsV1NamespacedStatefulSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSet"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedStatefulSet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1NamespacedStatefulSetListRequest handles watchAppsV1NamespacedStatefulSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets
func (s *Server) handleWatchAppsV1NamespacedStatefulSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSetList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1NamespacedStatefulSetListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1NamespacedStatefulSetList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1ReplicaSetListForAllNamespacesRequest handles watchAppsV1ReplicaSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/replicasets
func (s *Server) handleWatchAppsV1ReplicaSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ReplicaSetListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ReplicaSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1ReplicaSetListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1ReplicaSetListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1ReplicaSetListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAppsV1StatefulSetListForAllNamespacesRequest handles watchAppsV1StatefulSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/statefulsets
func (s *Server) handleWatchAppsV1StatefulSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1StatefulSetListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1StatefulSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAppsV1StatefulSetListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAppsV1StatefulSetListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAppsV1StatefulSetListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscalerList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta2/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1CronJobListForAllNamespacesRequest handles watchBatchV1CronJobListForAllNamespaces operation.
//
// GET /apis/batch/v1/watch/cronjobs
func (s *Server) handleWatchBatchV1CronJobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1CronJobListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1CronJobListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1CronJobListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1JobListForAllNamespacesRequest handles watchBatchV1JobListForAllNamespaces operation.
//
// GET /apis/batch/v1/watch/jobs
func (s *Server) handleWatchBatchV1JobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1JobListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1JobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1JobListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1JobListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1JobListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1NamespacedCronJobRequest handles watchBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1NamespacedCronJobListRequest handles watchBatchV1NamespacedCronJobList operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1NamespacedCronJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJobList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1NamespacedCronJobListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1NamespacedCronJobList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1NamespacedJobRequest handles watchBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}
func (s *Server) handleWatchBatchV1NamespacedJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1NamespacedJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1NamespacedJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1NamespacedJobListRequest handles watchBatchV1NamespacedJobList operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs
func (s *Server) handleWatchBatchV1NamespacedJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJobList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1NamespacedJobListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1NamespacedJobList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1beta1CronJobListForAllNamespacesRequest handles watchBatchV1beta1CronJobListForAllNamespaces operation.
//
// GET /apis/batch/v1beta1/watch/cronjobs
func (s *Server) handleWatchBatchV1beta1CronJobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1CronJobListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1beta1CronJobListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1beta1CronJobListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1beta1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1beta1NamespacedCronJobRequest handles watchBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1beta1NamespacedCronJob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchBatchV1beta1NamespacedCronJobListRequest handles watchBatchV1beta1NamespacedCronJobList operation.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJobList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchBatchV1beta1NamespacedCronJobListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchBatchV1beta1NamespacedCronJobList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCertificatesV1CertificateSigningRequestRequest handles watchCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequest"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCertificatesV1CertificateSigningRequest(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCertificatesV1CertificateSigningRequestListRequest handles watchCertificatesV1CertificateSigningRequestList operation.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequestList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequestList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCertificatesV1CertificateSigningRequestListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCertificatesV1CertificateSigningRequestList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoordinationV1LeaseListForAllNamespacesRequest handles watchCoordinationV1LeaseListForAllNamespaces operation.
//
// GET /apis/coordination.k8s.io/v1/watch/leases
func (s *Server) handleWatchCoordinationV1LeaseListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1LeaseListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1LeaseListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoordinationV1LeaseListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoordinationV1LeaseListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoordinationV1LeaseListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoordinationV1NamespacedLeaseRequest handles watchCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}
func (s *Server) handleWatchCoordinationV1NamespacedLeaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLease"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoordinationV1NamespacedLease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoordinationV1NamespacedLeaseListRequest handles watchCoordinationV1NamespacedLeaseList operation.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases
func (s *Server) handleWatchCoordinationV1NamespacedLeaseListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLeaseList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLeaseList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoordinationV1NamespacedLeaseListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoordinationV1NamespacedLeaseList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1ConfigMapListForAllNamespacesRequest handles watchCoreV1ConfigMapListForAllNamespaces operation.
//
// GET /api/v1/watch/configmaps
func (s *Server) handleWatchCoreV1ConfigMapListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ConfigMapListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ConfigMapListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1ConfigMapListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1ConfigMapListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1ConfigMapListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1EndpointsListForAllNamespacesRequest handles watchCoreV1EndpointsListForAllNamespaces operation.
//
// GET /api/v1/watch/endpoints
func (s *Server) handleWatchCoreV1EndpointsListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EndpointsListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EndpointsListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1EndpointsListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1EndpointsListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1EndpointsListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1EventListForAllNamespacesRequest handles watchCoreV1EventListForAllNamespaces operation.
//
// GET /api/v1/watch/events
func (s *Server) handleWatchCoreV1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EventListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1EventListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1EventListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1LimitRangeListForAllNamespacesRequest handles watchCoreV1LimitRangeListForAllNamespaces operation.
//
// GET /api/v1/watch/limitranges
func (s *Server) handleWatchCoreV1LimitRangeListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1LimitRangeListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1LimitRangeListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1LimitRangeListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1LimitRangeListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1LimitRangeListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespaceRequest handles watchCoreV1Namespace operation.
//
// GET /api/v1/watch/namespaces/{name}
func (s *Server) handleWatchCoreV1NamespaceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Namespace"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespaceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1Namespace(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespaceListRequest handles watchCoreV1NamespaceList operation.
//
// GET /api/v1/watch/namespaces
func (s *Server) handleWatchCoreV1NamespaceListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespaceList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespaceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespaceListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespaceList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedConfigMapRequest handles watchCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleWatchCoreV1NamespacedConfigMapRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMap"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedConfigMap(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedConfigMapListRequest handles watchCoreV1NamespacedConfigMapList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps
func (s *Server) handleWatchCoreV1NamespacedConfigMapListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMapList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMapList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedConfigMapListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedConfigMapList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedEndpointsRequest handles watchCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleWatchCoreV1NamespacedEndpointsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpoints"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedEndpoints(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedEndpointsListRequest handles watchCoreV1NamespacedEndpointsList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints
func (s *Server) handleWatchCoreV1NamespacedEndpointsListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpointsList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpointsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedEndpointsListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedEndpointsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedEventRequest handles watchCoreV1NamespacedEvent operation.
//
// GET /api/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchCoreV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedEventListRequest handles watchCoreV1NamespacedEventList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchCoreV1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEventList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedEventListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedEventList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedLimitRangeRequest handles watchCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleWatchCoreV1NamespacedLimitRangeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRange"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedLimitRange(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedLimitRangeListRequest handles watchCoreV1NamespacedLimitRangeList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges
func (s *Server) handleWatchCoreV1NamespacedLimitRangeListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRangeList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRangeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedLimitRangeListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedLimitRangeList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPersistentVolumeClaimRequest handles watchCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaim"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPersistentVolumeClaimListRequest handles watchCoreV1NamespacedPersistentVolumeClaimList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaimList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaimList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPersistentVolumeClaimList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPodRequest handles watchCoreV1NamespacedPod operation.
//
// GET /api/v1/watch/namespaces/{namespace}/pods/{name}
func (s *Server) handleWatchCoreV1NamespacedPodRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPod"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPodParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPod(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPodListRequest handles watchCoreV1NamespacedPodList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/pods
func (s *Server) handleWatchCoreV1NamespacedPodListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPodListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPodList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPodTemplateRequest handles watchCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleWatchCoreV1NamespacedPodTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplate"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPodTemplate(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedPodTemplateListRequest handles watchCoreV1NamespacedPodTemplateList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates
func (s *Server) handleWatchCoreV1NamespacedPodTemplateListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplateList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplateList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedPodTemplateListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedPodTemplateList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedReplicationControllerRequest handles watchCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationController"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedReplicationController(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedReplicationControllerListRequest handles watchCoreV1NamespacedReplicationControllerList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationControllerList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationControllerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedReplicationControllerListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedReplicationControllerList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedResourceQuotaRequest handles watchCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuota"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedResourceQuota(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedResourceQuotaListRequest handles watchCoreV1NamespacedResourceQuotaList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuotaList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuotaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedResourceQuotaListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedResourceQuotaList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedSecretRequest handles watchCoreV1NamespacedSecret operation.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets/{name}
func (s *Server) handleWatchCoreV1NamespacedSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedSecretListRequest handles watchCoreV1NamespacedSecretList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets
func (s *Server) handleWatchCoreV1NamespacedSecretListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecretList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecretList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedSecretListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedSecretList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedServiceRequest handles watchCoreV1NamespacedService operation.
//
// GET /api/v1/watch/namespaces/{namespace}/services/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedService"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedService(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedServiceAccountRequest handles watchCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceAccountRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccount"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedServiceAccount(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedServiceAccountListRequest handles watchCoreV1NamespacedServiceAccountList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts
func (s *Server) handleWatchCoreV1NamespacedServiceAccountListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccountList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccountList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedServiceAccountListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedServiceAccountList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NamespacedServiceListRequest handles watchCoreV1NamespacedServiceList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/services
func (s *Server) handleWatchCoreV1NamespacedServiceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NamespacedServiceListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NamespacedServiceList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NodeRequest handles watchCoreV1Node operation.
//
// GET /api/v1/watch/nodes/{name}
func (s *Server) handleWatchCoreV1NodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Node"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1Node(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1NodeListRequest handles watchCoreV1NodeList operation.
//
// GET /api/v1/watch/nodes
func (s *Server) handleWatchCoreV1NodeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NodeList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NodeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1NodeListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1NodeList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1NodeListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1PersistentVolumeRequest handles watchCoreV1PersistentVolume operation.
//
// GET /api/v1/watch/persistentvolumes/{name}
func (s *Server) handleWatchCoreV1PersistentVolumeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolume"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1PersistentVolume(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest handles watchCoreV1PersistentVolumeClaimListForAllNamespaces operation.
//
// GET /api/v1/watch/persistentvolumeclaims
func (s *Server) handleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeClaimListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1PersistentVolumeListRequest handles watchCoreV1PersistentVolumeList operation.
//
// GET /api/v1/watch/persistentvolumes
func (s *Server) handleWatchCoreV1PersistentVolumeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1PersistentVolumeListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1PersistentVolumeList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1PodListForAllNamespacesRequest handles watchCoreV1PodListForAllNamespaces operation.
//
// GET /api/v1/watch/pods
func (s *Server) handleWatchCoreV1PodListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1PodListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1PodListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1PodListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1PodTemplateListForAllNamespacesRequest handles watchCoreV1PodTemplateListForAllNamespaces operation.
//
// GET /api/v1/watch/podtemplates
func (s *Server) handleWatchCoreV1PodTemplateListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodTemplateListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodTemplateListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1PodTemplateListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1PodTemplateListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1PodTemplateListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1ReplicationControllerListForAllNamespacesRequest handles watchCoreV1ReplicationControllerListForAllNamespaces operation.
//
// GET /api/v1/watch/replicationcontrollers
func (s *Server) handleWatchCoreV1ReplicationControllerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ReplicationControllerListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ReplicationControllerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1ReplicationControllerListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1ReplicationControllerListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1ReplicationControllerListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1ResourceQuotaListForAllNamespacesRequest handles watchCoreV1ResourceQuotaListForAllNamespaces operation.
//
// GET /api/v1/watch/resourcequotas
func (s *Server) handleWatchCoreV1ResourceQuotaListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ResourceQuotaListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ResourceQuotaListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1ResourceQuotaListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1ResourceQuotaListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1ResourceQuotaListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1SecretListForAllNamespacesRequest handles watchCoreV1SecretListForAllNamespaces operation.
//
// GET /api/v1/watch/secrets
func (s *Server) handleWatchCoreV1SecretListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1SecretListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1SecretListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1SecretListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1SecretListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1SecretListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1ServiceAccountListForAllNamespacesRequest handles watchCoreV1ServiceAccountListForAllNamespaces operation.
//
// GET /api/v1/watch/serviceaccounts
func (s *Server) handleWatchCoreV1ServiceAccountListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceAccountListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceAccountListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1ServiceAccountListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1ServiceAccountListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1ServiceAccountListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchCoreV1ServiceListForAllNamespacesRequest handles watchCoreV1ServiceListForAllNamespaces operation.
//
// GET /api/v1/watch/services
func (s *Server) handleWatchCoreV1ServiceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchCoreV1ServiceListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchCoreV1ServiceListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchCoreV1ServiceListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1EndpointSliceListForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1EndpointSliceListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1NamespacedEndpointSliceRequest handles watchDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1NamespacedEndpointSliceListRequest handles watchDiscoveryV1NamespacedEndpointSliceList operation.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSliceList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1NamespacedEndpointSliceList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1beta1EndpointSliceListForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1EndpointSliceListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest handles watchDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSlice"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest handles watchDiscoveryV1beta1NamespacedEndpointSliceList operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSliceList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchDiscoveryV1beta1NamespacedEndpointSliceList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1EventListForAllNamespacesRequest handles watchEventsV1EventListForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1/watch/events
func (s *Server) handleWatchEventsV1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1EventListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1EventListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1EventListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1NamespacedEventRequest handles watchEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1NamespacedEventListRequest handles watchEventsV1NamespacedEventList operation.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEventList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1NamespacedEventListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1NamespacedEventList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1beta1EventListForAllNamespacesRequest handles watchEventsV1beta1EventListForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/events
func (s *Server) handleWatchEventsV1beta1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1EventListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1beta1EventListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1beta1EventListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1beta1EventListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1beta1NamespacedEventRequest handles watchEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1beta1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEvent"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1beta1NamespacedEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchEventsV1beta1NamespacedEventListRequest handles watchEventsV1beta1NamespacedEventList operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1beta1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEventList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchEventsV1beta1NamespacedEventListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchEventsV1beta1NamespacedEventList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest handles watchFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta1FlowSchemaList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchemaList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest handles watchFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchema"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta2FlowSchemaList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchemaList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchInternalApiserverV1alpha1StorageVersionRequest handles watchInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersion"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchInternalApiserverV1alpha1StorageVersion(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchInternalApiserverV1alpha1StorageVersionListRequest handles watchInternalApiserverV1alpha1StorageVersionList operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersionList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchInternalApiserverV1alpha1StorageVersionList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1IngressClassRequest handles watchNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses/{name}
func (s *Server) handleWatchNetworkingV1IngressClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1IngressClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1IngressClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1IngressClassListRequest handles watchNetworkingV1IngressClassList operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses
func (s *Server) handleWatchNetworkingV1IngressClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1IngressClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1IngressClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1IngressListForAllNamespacesRequest handles watchNetworkingV1IngressListForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingresses
func (s *Server) handleWatchNetworkingV1IngressListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1IngressListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1IngressListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1NamespacedIngressRequest handles watchNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleWatchNetworkingV1NamespacedIngressRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngress"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1NamespacedIngress(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1NamespacedIngressListRequest handles watchNetworkingV1NamespacedIngressList operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses
func (s *Server) handleWatchNetworkingV1NamespacedIngressListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngressList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngressList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1NamespacedIngressListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1NamespacedIngressList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1NamespacedNetworkPolicyRequest handles watchNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1NamespacedNetworkPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1NamespacedNetworkPolicyListRequest handles watchNetworkingV1NamespacedNetworkPolicyList operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicyList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicyList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1NamespacedNetworkPolicyList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest handles watchNetworkingV1NetworkPolicyListForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/watch/networkpolicies
func (s *Server) handleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NetworkPolicyListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNetworkingV1NetworkPolicyListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1RuntimeClassRequest handles watchNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1RuntimeClassListRequest handles watchNodeV1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1RuntimeClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1RuntimeClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1alpha1RuntimeClassRequest handles watchNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1alpha1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1alpha1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1alpha1RuntimeClassListRequest handles watchNodeV1alpha1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1alpha1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1alpha1RuntimeClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1alpha1RuntimeClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1beta1RuntimeClassRequest handles watchNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1beta1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1beta1RuntimeClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchNodeV1beta1RuntimeClassListRequest handles watchNodeV1beta1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1beta1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchNodeV1beta1RuntimeClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchNodeV1beta1RuntimeClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1NamespacedPodDisruptionBudgetList operation.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudgetList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1NamespacedPodDisruptionBudgetList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1PodDisruptionBudgetListForAllNamespaces operation.
//
// GET /apis/policy/v1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1PodDisruptionBudgetListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudget"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudgetList operation.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudgetList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudgetList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces operation.
//
// GET /apis/policy/v1beta1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1beta1PodSecurityPolicyRequest handles watchPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies/{name}
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1beta1PodSecurityPolicy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchPolicyV1beta1PodSecurityPolicyListRequest handles watchPolicyV1beta1PodSecurityPolicyList operation.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicyList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicyList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchPolicyV1beta1PodSecurityPolicyList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1ClusterRoleRequest handles watchRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1ClusterRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1ClusterRoleBindingRequest handles watchRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1ClusterRoleBindingListRequest handles watchRbacAuthorizationV1ClusterRoleBindingList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBindingList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1ClusterRoleBindingList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1ClusterRoleListRequest handles watchRbacAuthorizationV1ClusterRoleList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1ClusterRoleList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1NamespacedRoleRequest handles watchRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRole"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1NamespacedRole(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1NamespacedRoleBindingRequest handles watchRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBinding"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest handles watchRbacAuthorizationV1NamespacedRoleBindingList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBindingList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1NamespacedRoleBindingList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1NamespacedRoleListRequest handles watchRbacAuthorizationV1NamespacedRoleList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1NamespacedRoleList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleBindingListForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleBindingListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleListForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/roles
func (s *Server) handleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchRbacAuthorizationV1RoleListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchSchedulingV1PriorityClassRequest handles watchSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}
func (s *Server) handleWatchSchedulingV1PriorityClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchSchedulingV1PriorityClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchSchedulingV1PriorityClassListRequest handles watchSchedulingV1PriorityClassList operation.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses
func (s *Server) handleWatchSchedulingV1PriorityClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchSchedulingV1PriorityClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchSchedulingV1PriorityClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1CSIDriverRequest handles watchStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers/{name}
func (s *Server) handleWatchStorageV1CSIDriverRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriver"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1CSIDriverParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1CSIDriver(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1CSIDriverListRequest handles watchStorageV1CSIDriverList operation.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers
func (s *Server) handleWatchStorageV1CSIDriverListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriverList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriverList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1CSIDriverListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1CSIDriverList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1CSINodeRequest handles watchStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes/{name}
func (s *Server) handleWatchStorageV1CSINodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINode"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1CSINodeParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1CSINode(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1CSINodeListRequest handles watchStorageV1CSINodeList operation.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes
func (s *Server) handleWatchStorageV1CSINodeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINodeList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINodeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1CSINodeListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1CSINodeList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1StorageClassRequest handles watchStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses/{name}
func (s *Server) handleWatchStorageV1StorageClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClass"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1StorageClassParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1StorageClass(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1StorageClassListRequest handles watchStorageV1StorageClassList operation.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses
func (s *Server) handleWatchStorageV1StorageClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClassList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1StorageClassListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1StorageClassList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1VolumeAttachmentRequest handles watchStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments/{name}
func (s *Server) handleWatchStorageV1VolumeAttachmentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1VolumeAttachment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1VolumeAttachmentListRequest handles watchStorageV1VolumeAttachmentList operation.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments
func (s *Server) handleWatchStorageV1VolumeAttachmentListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachmentList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachmentList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1VolumeAttachmentListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1VolumeAttachmentList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacityList operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacityList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacityList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1beta1CSIStorageCapacityListForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1CSIStorageCapacityListForAllNamespaces"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest handles watchStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacity"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest handles watchStorageV1beta1NamespacedCSIStorageCapacityList operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacityList"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(args, r)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "BadRequest")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.WatchStorageV1beta1NamespacedCSIStorageCapacityList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	span.SetStatus(codes.Ok, "Ok")
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

func respondError(w http.ResponseWriter, code int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	data, writeErr := json.Marshal(struct {
		ErrorMessage string `json:"error_message"`
	}{
		ErrorMessage: err.Error(),
	})
	if writeErr == nil {
		w.Write(data)
	}
}
