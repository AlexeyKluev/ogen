// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

func (s *Server) notFound(w http.ResponseWriter, r *http.Request) {
	http.NotFound(w, r)
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	p := []byte(r.URL.Path)
	if len(p) == 0 {
		s.notFound(w, r)
		return
	}

	var (
		idx  int               // index of next slash
		elem []byte            // current element, without slashes
		args map[string]string // lazily initialized
	)

	// Static code generated router with unwrapped path search.
	switch r.Method {
	case "GET":
		// Root edge.
		if len(p) > 1 && p[0] == '/' {
			p = p[1:]
		}
		if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
			elem, p = p, p[:0] // slash not found, using full path
		} else {
			elem = p[:idx] // slash found, element is path until slash
			p = p[idx:]
		}
		switch string(elem) {
		case "apis": // -> 1
			// Edge: 1, path: "apis".
			if len(p) > 1 && p[0] == '/' {
				p = p[1:]
			}
			if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
				elem, p = p, p[:0] // slash not found, using full path
			} else {
				elem = p[:idx] // slash found, element is path until slash
				p = p[idx:]
			}
			switch string(elem) {
			case "admissionregistration.k8s.io": // -> 2
				// Edge: 2, path: "admissionregistration.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 3
					// Edge: 3, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "mutatingwebhookconfigurations": // -> 58
						// Edge: 58, path: "mutatingwebhookconfigurations".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}.
							s.handleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest(args, w, r)
							return
						}
					case "validatingwebhookconfigurations": // -> 59
						// Edge: 59, path: "validatingwebhookconfigurations".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}.
							s.handleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args, w, r)
							return
						}
					case "watch": // -> 291
						// Edge: 291, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "mutatingwebhookconfigurations": // -> 292
							// Edge: 292, path: "mutatingwebhookconfigurations".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}.
								s.handleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest(args, w, r)
								return
							}
						case "validatingwebhookconfigurations": // -> 294
							// Edge: 294, path: "validatingwebhookconfigurations".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}.
								s.handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/admissionregistration.k8s.io/v1/.
						s.handleGetAdmissionregistrationV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/admissionregistration.k8s.io/.
					s.handleGetAdmissionregistrationAPIGroupRequest(args, w, r)
					return
				}
			case "apiextensions.k8s.io": // -> 4
				// Edge: 4, path: "apiextensions.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 5
					// Edge: 5, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "customresourcedefinitions": // -> 60
						// Edge: 60, path: "customresourcedefinitions".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 195, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 196
								// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status.
								s.handleReadApiextensionsV1CustomResourceDefinitionStatusRequest(args, w, r)
								return
							default:
								// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}.
								s.handleReadApiextensionsV1CustomResourceDefinitionRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 296
						// Edge: 296, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "customresourcedefinitions": // -> 297
							// Edge: 297, path: "customresourcedefinitions".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}.
								s.handleWatchApiextensionsV1CustomResourceDefinitionRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/apiextensions.k8s.io/v1/.
						s.handleGetApiextensionsV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/apiextensions.k8s.io/.
					s.handleGetApiextensionsAPIGroupRequest(args, w, r)
					return
				}
			case "apiregistration.k8s.io": // -> 6
				// Edge: 6, path: "apiregistration.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 7
					// Edge: 7, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "apiservices": // -> 61
						// Edge: 61, path: "apiservices".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 197, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 198
								// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}/status.
								s.handleReadApiregistrationV1APIServiceStatusRequest(args, w, r)
								return
							default:
								// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}.
								s.handleReadApiregistrationV1APIServiceRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 299
						// Edge: 299, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "apiservices": // -> 300
							// Edge: 300, path: "apiservices".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/apiregistration.k8s.io/v1/watch/apiservices/{name}.
								s.handleWatchApiregistrationV1APIServiceRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/apiregistration.k8s.io/v1/.
						s.handleGetApiregistrationV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/apiregistration.k8s.io/.
					s.handleGetApiregistrationAPIGroupRequest(args, w, r)
					return
				}
			case "apps": // -> 8
				// Edge: 8, path: "apps".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 9
					// Edge: 9, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "controllerrevisions": // -> 62
						// GET /apis/apps/v1/controllerrevisions.
						s.handleListAppsV1ControllerRevisionForAllNamespacesRequest(args, w, r)
						return
					case "daemonsets": // -> 63
						// GET /apis/apps/v1/daemonsets.
						s.handleListAppsV1DaemonSetForAllNamespacesRequest(args, w, r)
						return
					case "deployments": // -> 64
						// GET /apis/apps/v1/deployments.
						s.handleListAppsV1DeploymentForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 65
						// Edge: 65, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 66, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "controllerrevisions": // -> 67
								// Edge: 67, path: "controllerrevisions".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}.
									s.handleReadAppsV1NamespacedControllerRevisionRequest(args, w, r)
									return
								}
							case "daemonsets": // -> 68
								// Edge: 68, path: "daemonsets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 200, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 201
										// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status.
										s.handleReadAppsV1NamespacedDaemonSetStatusRequest(args, w, r)
										return
									default:
										// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}.
										s.handleReadAppsV1NamespacedDaemonSetRequest(args, w, r)
										return
									}
								}
							case "deployments": // -> 69
								// Edge: 69, path: "deployments".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 202, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "scale": // -> 203
										// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale.
										s.handleReadAppsV1NamespacedDeploymentScaleRequest(args, w, r)
										return
									case "status": // -> 204
										// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/status.
										s.handleReadAppsV1NamespacedDeploymentStatusRequest(args, w, r)
										return
									default:
										// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}.
										s.handleReadAppsV1NamespacedDeploymentRequest(args, w, r)
										return
									}
								}
							case "replicasets": // -> 70
								// Edge: 70, path: "replicasets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 205, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "scale": // -> 206
										// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale.
										s.handleReadAppsV1NamespacedReplicaSetScaleRequest(args, w, r)
										return
									case "status": // -> 207
										// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status.
										s.handleReadAppsV1NamespacedReplicaSetStatusRequest(args, w, r)
										return
									default:
										// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}.
										s.handleReadAppsV1NamespacedReplicaSetRequest(args, w, r)
										return
									}
								}
							case "statefulsets": // -> 71
								// Edge: 71, path: "statefulsets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 208, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "scale": // -> 209
										// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale.
										s.handleReadAppsV1NamespacedStatefulSetScaleRequest(args, w, r)
										return
									case "status": // -> 210
										// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status.
										s.handleReadAppsV1NamespacedStatefulSetStatusRequest(args, w, r)
										return
									default:
										// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}.
										s.handleReadAppsV1NamespacedStatefulSetRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "replicasets": // -> 72
						// GET /apis/apps/v1/replicasets.
						s.handleListAppsV1ReplicaSetForAllNamespacesRequest(args, w, r)
						return
					case "statefulsets": // -> 73
						// GET /apis/apps/v1/statefulsets.
						s.handleListAppsV1StatefulSetForAllNamespacesRequest(args, w, r)
						return
					case "watch": // -> 302
						// Edge: 302, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "controllerrevisions": // -> 303
							// GET /apis/apps/v1/watch/controllerrevisions.
							s.handleWatchAppsV1ControllerRevisionListForAllNamespacesRequest(args, w, r)
							return
						case "daemonsets": // -> 304
							// GET /apis/apps/v1/watch/daemonsets.
							s.handleWatchAppsV1DaemonSetListForAllNamespacesRequest(args, w, r)
							return
						case "deployments": // -> 305
							// GET /apis/apps/v1/watch/deployments.
							s.handleWatchAppsV1DeploymentListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 306
							// Edge: 306, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 307, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "controllerrevisions": // -> 308
									// Edge: 308, path: "controllerrevisions".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}.
										s.handleWatchAppsV1NamespacedControllerRevisionRequest(args, w, r)
										return
									}
								case "daemonsets": // -> 310
									// Edge: 310, path: "daemonsets".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}.
										s.handleWatchAppsV1NamespacedDaemonSetRequest(args, w, r)
										return
									}
								case "deployments": // -> 312
									// Edge: 312, path: "deployments".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}.
										s.handleWatchAppsV1NamespacedDeploymentRequest(args, w, r)
										return
									}
								case "replicasets": // -> 314
									// Edge: 314, path: "replicasets".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}.
										s.handleWatchAppsV1NamespacedReplicaSetRequest(args, w, r)
										return
									}
								case "statefulsets": // -> 316
									// Edge: 316, path: "statefulsets".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}.
										s.handleWatchAppsV1NamespacedStatefulSetRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						case "replicasets": // -> 318
							// GET /apis/apps/v1/watch/replicasets.
							s.handleWatchAppsV1ReplicaSetListForAllNamespacesRequest(args, w, r)
							return
						case "statefulsets": // -> 319
							// GET /apis/apps/v1/watch/statefulsets.
							s.handleWatchAppsV1StatefulSetListForAllNamespacesRequest(args, w, r)
							return
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/apps/v1/.
						s.handleGetAppsV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/apps/.
					s.handleGetAppsAPIGroupRequest(args, w, r)
					return
				}
			case "authentication.k8s.io": // -> 10
				// Edge: 10, path: "authentication.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 11
					// GET /apis/authentication.k8s.io/v1/.
					s.handleGetAuthenticationV1APIResourcesRequest(args, w, r)
					return
				default:
					// GET /apis/authentication.k8s.io/.
					s.handleGetAuthenticationAPIGroupRequest(args, w, r)
					return
				}
			case "authorization.k8s.io": // -> 12
				// Edge: 12, path: "authorization.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 13
					// GET /apis/authorization.k8s.io/v1/.
					s.handleGetAuthorizationV1APIResourcesRequest(args, w, r)
					return
				default:
					// GET /apis/authorization.k8s.io/.
					s.handleGetAuthorizationAPIGroupRequest(args, w, r)
					return
				}
			case "autoscaling": // -> 14
				// Edge: 14, path: "autoscaling".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 15
					// Edge: 15, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "horizontalpodautoscalers": // -> 74
						// GET /apis/autoscaling/v1/horizontalpodautoscalers.
						s.handleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 75
						// Edge: 75, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 76, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "horizontalpodautoscalers": // -> 77
								// Edge: 77, path: "horizontalpodautoscalers".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 211, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 212
										// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status.
										s.handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest(args, w, r)
										return
									default:
										// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 320
						// Edge: 320, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "horizontalpodautoscalers": // -> 321
							// GET /apis/autoscaling/v1/watch/horizontalpodautoscalers.
							s.handleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 322
							// Edge: 322, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 323, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "horizontalpodautoscalers": // -> 324
									// Edge: 324, path: "horizontalpodautoscalers".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/autoscaling/v1/.
						s.handleGetAutoscalingV1APIResourcesRequest(args, w, r)
						return
					}
				case "v2beta1": // -> 16
					// Edge: 16, path: "v2beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "horizontalpodautoscalers": // -> 78
						// GET /apis/autoscaling/v2beta1/horizontalpodautoscalers.
						s.handleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 79
						// Edge: 79, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 80, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "horizontalpodautoscalers": // -> 81
								// Edge: 81, path: "horizontalpodautoscalers".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 213, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 214
										// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status.
										s.handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest(args, w, r)
										return
									default:
										// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 326
						// Edge: 326, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "horizontalpodautoscalers": // -> 327
							// GET /apis/autoscaling/v2beta1/watch/horizontalpodautoscalers.
							s.handleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 328
							// Edge: 328, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 329, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "horizontalpodautoscalers": // -> 330
									// Edge: 330, path: "horizontalpodautoscalers".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/autoscaling/v2beta1/.
						s.handleGetAutoscalingV2beta1APIResourcesRequest(args, w, r)
						return
					}
				case "v2beta2": // -> 17
					// Edge: 17, path: "v2beta2".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "horizontalpodautoscalers": // -> 82
						// GET /apis/autoscaling/v2beta2/horizontalpodautoscalers.
						s.handleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 83
						// Edge: 83, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 84, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "horizontalpodautoscalers": // -> 85
								// Edge: 85, path: "horizontalpodautoscalers".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 215, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 216
										// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status.
										s.handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest(args, w, r)
										return
									default:
										// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 332
						// Edge: 332, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "horizontalpodautoscalers": // -> 333
							// GET /apis/autoscaling/v2beta2/watch/horizontalpodautoscalers.
							s.handleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 334
							// Edge: 334, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 335, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "horizontalpodautoscalers": // -> 336
									// Edge: 336, path: "horizontalpodautoscalers".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}.
										s.handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/autoscaling/v2beta2/.
						s.handleGetAutoscalingV2beta2APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/autoscaling/.
					s.handleGetAutoscalingAPIGroupRequest(args, w, r)
					return
				}
			case "batch": // -> 18
				// Edge: 18, path: "batch".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 19
					// Edge: 19, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "cronjobs": // -> 86
						// GET /apis/batch/v1/cronjobs.
						s.handleListBatchV1CronJobForAllNamespacesRequest(args, w, r)
						return
					case "jobs": // -> 87
						// GET /apis/batch/v1/jobs.
						s.handleListBatchV1JobForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 88
						// Edge: 88, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 89, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "cronjobs": // -> 90
								// Edge: 90, path: "cronjobs".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 217, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 218
										// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status.
										s.handleReadBatchV1NamespacedCronJobStatusRequest(args, w, r)
										return
									default:
										// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}.
										s.handleReadBatchV1NamespacedCronJobRequest(args, w, r)
										return
									}
								}
							case "jobs": // -> 91
								// Edge: 91, path: "jobs".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 219, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 220
										// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}/status.
										s.handleReadBatchV1NamespacedJobStatusRequest(args, w, r)
										return
									default:
										// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}.
										s.handleReadBatchV1NamespacedJobRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 338
						// Edge: 338, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "cronjobs": // -> 339
							// GET /apis/batch/v1/watch/cronjobs.
							s.handleWatchBatchV1CronJobListForAllNamespacesRequest(args, w, r)
							return
						case "jobs": // -> 340
							// GET /apis/batch/v1/watch/jobs.
							s.handleWatchBatchV1JobListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 341
							// Edge: 341, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 342, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "cronjobs": // -> 343
									// Edge: 343, path: "cronjobs".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}.
										s.handleWatchBatchV1NamespacedCronJobRequest(args, w, r)
										return
									}
								case "jobs": // -> 345
									// Edge: 345, path: "jobs".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}.
										s.handleWatchBatchV1NamespacedJobRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/batch/v1/.
						s.handleGetBatchV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 20
					// Edge: 20, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "cronjobs": // -> 92
						// GET /apis/batch/v1beta1/cronjobs.
						s.handleListBatchV1beta1CronJobForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 93
						// Edge: 93, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 94, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "cronjobs": // -> 95
								// Edge: 95, path: "cronjobs".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 221, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 222
										// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status.
										s.handleReadBatchV1beta1NamespacedCronJobStatusRequest(args, w, r)
										return
									default:
										// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}.
										s.handleReadBatchV1beta1NamespacedCronJobRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 347
						// Edge: 347, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "cronjobs": // -> 348
							// GET /apis/batch/v1beta1/watch/cronjobs.
							s.handleWatchBatchV1beta1CronJobListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 349
							// Edge: 349, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 350, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "cronjobs": // -> 351
									// Edge: 351, path: "cronjobs".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}.
										s.handleWatchBatchV1beta1NamespacedCronJobRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/batch/v1beta1/.
						s.handleGetBatchV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/batch/.
					s.handleGetBatchAPIGroupRequest(args, w, r)
					return
				}
			case "certificates.k8s.io": // -> 21
				// Edge: 21, path: "certificates.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 22
					// Edge: 22, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "certificatesigningrequests": // -> 96
						// Edge: 96, path: "certificatesigningrequests".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 223, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "approval": // -> 224
								// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval.
								s.handleReadCertificatesV1CertificateSigningRequestApprovalRequest(args, w, r)
								return
							case "status": // -> 225
								// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status.
								s.handleReadCertificatesV1CertificateSigningRequestStatusRequest(args, w, r)
								return
							default:
								// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}.
								s.handleReadCertificatesV1CertificateSigningRequestRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 353
						// Edge: 353, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "certificatesigningrequests": // -> 354
							// Edge: 354, path: "certificatesigningrequests".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}.
								s.handleWatchCertificatesV1CertificateSigningRequestRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/certificates.k8s.io/v1/.
						s.handleGetCertificatesV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/certificates.k8s.io/.
					s.handleGetCertificatesAPIGroupRequest(args, w, r)
					return
				}
			case "coordination.k8s.io": // -> 24
				// Edge: 24, path: "coordination.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 25
					// Edge: 25, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "leases": // -> 97
						// GET /apis/coordination.k8s.io/v1/leases.
						s.handleListCoordinationV1LeaseForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 98
						// Edge: 98, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 99, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "leases": // -> 100
								// Edge: 100, path: "leases".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}.
									s.handleReadCoordinationV1NamespacedLeaseRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 356
						// Edge: 356, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "leases": // -> 357
							// GET /apis/coordination.k8s.io/v1/watch/leases.
							s.handleWatchCoordinationV1LeaseListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 358
							// Edge: 358, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 359, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "leases": // -> 360
									// Edge: 360, path: "leases".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}.
										s.handleWatchCoordinationV1NamespacedLeaseRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/coordination.k8s.io/v1/.
						s.handleGetCoordinationV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/coordination.k8s.io/.
					s.handleGetCoordinationAPIGroupRequest(args, w, r)
					return
				}
			case "discovery.k8s.io": // -> 28
				// Edge: 28, path: "discovery.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 29
					// Edge: 29, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "endpointslices": // -> 130
						// GET /apis/discovery.k8s.io/v1/endpointslices.
						s.handleListDiscoveryV1EndpointSliceForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 131
						// Edge: 131, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 132, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "endpointslices": // -> 133
								// Edge: 133, path: "endpointslices".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}.
									s.handleReadDiscoveryV1NamespacedEndpointSliceRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 405
						// Edge: 405, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "endpointslices": // -> 406
							// GET /apis/discovery.k8s.io/v1/watch/endpointslices.
							s.handleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 407
							// Edge: 407, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 408, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "endpointslices": // -> 409
									// Edge: 409, path: "endpointslices".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}.
										s.handleWatchDiscoveryV1NamespacedEndpointSliceRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/discovery.k8s.io/v1/.
						s.handleGetDiscoveryV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 30
					// Edge: 30, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "endpointslices": // -> 134
						// GET /apis/discovery.k8s.io/v1beta1/endpointslices.
						s.handleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 135
						// Edge: 135, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 136, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "endpointslices": // -> 137
								// Edge: 137, path: "endpointslices".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}.
									s.handleReadDiscoveryV1beta1NamespacedEndpointSliceRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 411
						// Edge: 411, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "endpointslices": // -> 412
							// GET /apis/discovery.k8s.io/v1beta1/watch/endpointslices.
							s.handleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 413
							// Edge: 413, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 414, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "endpointslices": // -> 415
									// Edge: 415, path: "endpointslices".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices/{name}.
										s.handleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/discovery.k8s.io/v1beta1/.
						s.handleGetDiscoveryV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/discovery.k8s.io/.
					s.handleGetDiscoveryAPIGroupRequest(args, w, r)
					return
				}
			case "events.k8s.io": // -> 31
				// Edge: 31, path: "events.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 32
					// Edge: 32, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "events": // -> 138
						// GET /apis/events.k8s.io/v1/events.
						s.handleListEventsV1EventForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 139
						// Edge: 139, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 140, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "events": // -> 141
								// Edge: 141, path: "events".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}.
									s.handleReadEventsV1NamespacedEventRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 417
						// Edge: 417, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "events": // -> 418
							// GET /apis/events.k8s.io/v1/watch/events.
							s.handleWatchEventsV1EventListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 419
							// Edge: 419, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 420, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "events": // -> 421
									// Edge: 421, path: "events".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}.
										s.handleWatchEventsV1NamespacedEventRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/events.k8s.io/v1/.
						s.handleGetEventsV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 33
					// Edge: 33, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "events": // -> 142
						// GET /apis/events.k8s.io/v1beta1/events.
						s.handleListEventsV1beta1EventForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 143
						// Edge: 143, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 144, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "events": // -> 145
								// Edge: 145, path: "events".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}.
									s.handleReadEventsV1beta1NamespacedEventRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 423
						// Edge: 423, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "events": // -> 424
							// GET /apis/events.k8s.io/v1beta1/watch/events.
							s.handleWatchEventsV1beta1EventListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 425
							// Edge: 425, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 426, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "events": // -> 427
									// Edge: 427, path: "events".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}.
										s.handleWatchEventsV1beta1NamespacedEventRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/events.k8s.io/v1beta1/.
						s.handleGetEventsV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/events.k8s.io/.
					s.handleGetEventsAPIGroupRequest(args, w, r)
					return
				}
			case "flowcontrol.apiserver.k8s.io": // -> 34
				// Edge: 34, path: "flowcontrol.apiserver.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1beta1": // -> 35
					// Edge: 35, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "flowschemas": // -> 146
						// Edge: 146, path: "flowschemas".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 257, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 258
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status.
								s.handleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest(args, w, r)
								return
							default:
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}.
								s.handleReadFlowcontrolApiserverV1beta1FlowSchemaRequest(args, w, r)
								return
							}
						}
					case "prioritylevelconfigurations": // -> 147
						// Edge: 147, path: "prioritylevelconfigurations".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 259, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 260
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status.
								s.handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest(args, w, r)
								return
							default:
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}.
								s.handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 429
						// Edge: 429, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "flowschemas": // -> 430
							// Edge: 430, path: "flowschemas".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas/{name}.
								s.handleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest(args, w, r)
								return
							}
						case "prioritylevelconfigurations": // -> 432
							// Edge: 432, path: "prioritylevelconfigurations".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations/{name}.
								s.handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/.
						s.handleGetFlowcontrolApiserverV1beta1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta2": // -> 36
					// Edge: 36, path: "v1beta2".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "flowschemas": // -> 148
						// Edge: 148, path: "flowschemas".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 261, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 262
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status.
								s.handleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest(args, w, r)
								return
							default:
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}.
								s.handleReadFlowcontrolApiserverV1beta2FlowSchemaRequest(args, w, r)
								return
							}
						}
					case "prioritylevelconfigurations": // -> 149
						// Edge: 149, path: "prioritylevelconfigurations".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 263, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 264
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status.
								s.handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest(args, w, r)
								return
							default:
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}.
								s.handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 434
						// Edge: 434, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "flowschemas": // -> 435
							// Edge: 435, path: "flowschemas".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}.
								s.handleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest(args, w, r)
								return
							}
						case "prioritylevelconfigurations": // -> 437
							// Edge: 437, path: "prioritylevelconfigurations".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}.
								s.handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/.
						s.handleGetFlowcontrolApiserverV1beta2APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/flowcontrol.apiserver.k8s.io/.
					s.handleGetFlowcontrolApiserverAPIGroupRequest(args, w, r)
					return
				}
			case "internal.apiserver.k8s.io": // -> 37
				// Edge: 37, path: "internal.apiserver.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1alpha1": // -> 38
					// Edge: 38, path: "v1alpha1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "storageversions": // -> 150
						// Edge: 150, path: "storageversions".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 265, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 266
								// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status.
								s.handleReadInternalApiserverV1alpha1StorageVersionStatusRequest(args, w, r)
								return
							default:
								// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}.
								s.handleReadInternalApiserverV1alpha1StorageVersionRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 439
						// Edge: 439, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "storageversions": // -> 440
							// Edge: 440, path: "storageversions".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}.
								s.handleWatchInternalApiserverV1alpha1StorageVersionRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/internal.apiserver.k8s.io/v1alpha1/.
						s.handleGetInternalApiserverV1alpha1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/internal.apiserver.k8s.io/.
					s.handleGetInternalApiserverAPIGroupRequest(args, w, r)
					return
				}
			case "networking.k8s.io": // -> 39
				// Edge: 39, path: "networking.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 40
					// Edge: 40, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "ingressclasses": // -> 151
						// Edge: 151, path: "ingressclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/networking.k8s.io/v1/ingressclasses/{name}.
							s.handleReadNetworkingV1IngressClassRequest(args, w, r)
							return
						}
					case "ingresses": // -> 152
						// GET /apis/networking.k8s.io/v1/ingresses.
						s.handleListNetworkingV1IngressForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 153
						// Edge: 153, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 154, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "ingresses": // -> 155
								// Edge: 155, path: "ingresses".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 268, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 269
										// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status.
										s.handleReadNetworkingV1NamespacedIngressStatusRequest(args, w, r)
										return
									default:
										// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}.
										s.handleReadNetworkingV1NamespacedIngressRequest(args, w, r)
										return
									}
								}
							case "networkpolicies": // -> 156
								// Edge: 156, path: "networkpolicies".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}.
									s.handleReadNetworkingV1NamespacedNetworkPolicyRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "networkpolicies": // -> 157
						// GET /apis/networking.k8s.io/v1/networkpolicies.
						s.handleListNetworkingV1NetworkPolicyForAllNamespacesRequest(args, w, r)
						return
					case "watch": // -> 442
						// Edge: 442, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "ingressclasses": // -> 443
							// Edge: 443, path: "ingressclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/networking.k8s.io/v1/watch/ingressclasses/{name}.
								s.handleWatchNetworkingV1IngressClassRequest(args, w, r)
								return
							}
						case "ingresses": // -> 445
							// GET /apis/networking.k8s.io/v1/watch/ingresses.
							s.handleWatchNetworkingV1IngressListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 446
							// Edge: 446, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 447, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "ingresses": // -> 448
									// Edge: 448, path: "ingresses".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}.
										s.handleWatchNetworkingV1NamespacedIngressRequest(args, w, r)
										return
									}
								case "networkpolicies": // -> 450
									// Edge: 450, path: "networkpolicies".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}.
										s.handleWatchNetworkingV1NamespacedNetworkPolicyRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						case "networkpolicies": // -> 452
							// GET /apis/networking.k8s.io/v1/watch/networkpolicies.
							s.handleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest(args, w, r)
							return
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/networking.k8s.io/v1/.
						s.handleGetNetworkingV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/networking.k8s.io/.
					s.handleGetNetworkingAPIGroupRequest(args, w, r)
					return
				}
			case "node.k8s.io": // -> 41
				// Edge: 41, path: "node.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 42
					// Edge: 42, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "runtimeclasses": // -> 158
						// Edge: 158, path: "runtimeclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/node.k8s.io/v1/runtimeclasses/{name}.
							s.handleReadNodeV1RuntimeClassRequest(args, w, r)
							return
						}
					case "watch": // -> 453
						// Edge: 453, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "runtimeclasses": // -> 454
							// Edge: 454, path: "runtimeclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/node.k8s.io/v1/watch/runtimeclasses/{name}.
								s.handleWatchNodeV1RuntimeClassRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/node.k8s.io/v1/.
						s.handleGetNodeV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1alpha1": // -> 43
					// Edge: 43, path: "v1alpha1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "runtimeclasses": // -> 159
						// Edge: 159, path: "runtimeclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/node.k8s.io/v1alpha1/runtimeclasses/{name}.
							s.handleReadNodeV1alpha1RuntimeClassRequest(args, w, r)
							return
						}
					case "watch": // -> 456
						// Edge: 456, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "runtimeclasses": // -> 457
							// Edge: 457, path: "runtimeclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses/{name}.
								s.handleWatchNodeV1alpha1RuntimeClassRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/node.k8s.io/v1alpha1/.
						s.handleGetNodeV1alpha1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 44
					// Edge: 44, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "runtimeclasses": // -> 160
						// Edge: 160, path: "runtimeclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/node.k8s.io/v1beta1/runtimeclasses/{name}.
							s.handleReadNodeV1beta1RuntimeClassRequest(args, w, r)
							return
						}
					case "watch": // -> 459
						// Edge: 459, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "runtimeclasses": // -> 460
							// Edge: 460, path: "runtimeclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses/{name}.
								s.handleWatchNodeV1beta1RuntimeClassRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/node.k8s.io/v1beta1/.
						s.handleGetNodeV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/node.k8s.io/.
					s.handleGetNodeAPIGroupRequest(args, w, r)
					return
				}
			case "policy": // -> 45
				// Edge: 45, path: "policy".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 46
					// Edge: 46, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "namespaces": // -> 161
						// Edge: 161, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 162, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "poddisruptionbudgets": // -> 163
								// Edge: 163, path: "poddisruptionbudgets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 274, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 275
										// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status.
										s.handleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest(args, w, r)
										return
									default:
										// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}.
										s.handleReadPolicyV1NamespacedPodDisruptionBudgetRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "poddisruptionbudgets": // -> 164
						// GET /apis/policy/v1/poddisruptionbudgets.
						s.handleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest(args, w, r)
						return
					case "watch": // -> 462
						// Edge: 462, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "namespaces": // -> 463
							// Edge: 463, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 464, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "poddisruptionbudgets": // -> 465
									// Edge: 465, path: "poddisruptionbudgets".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}.
										s.handleWatchPolicyV1NamespacedPodDisruptionBudgetRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						case "poddisruptionbudgets": // -> 467
							// GET /apis/policy/v1/watch/poddisruptionbudgets.
							s.handleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest(args, w, r)
							return
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/policy/v1/.
						s.handleGetPolicyV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 47
					// Edge: 47, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "namespaces": // -> 165
						// Edge: 165, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 166, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "poddisruptionbudgets": // -> 167
								// Edge: 167, path: "poddisruptionbudgets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// Edge: 276, path: "".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									case "status": // -> 277
										// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status.
										s.handleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest(args, w, r)
										return
									default:
										// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}.
										s.handleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args, w, r)
										return
									}
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "poddisruptionbudgets": // -> 168
						// GET /apis/policy/v1beta1/poddisruptionbudgets.
						s.handleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest(args, w, r)
						return
					case "podsecuritypolicies": // -> 169
						// Edge: 169, path: "podsecuritypolicies".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/policy/v1beta1/podsecuritypolicies/{name}.
							s.handleReadPolicyV1beta1PodSecurityPolicyRequest(args, w, r)
							return
						}
					case "watch": // -> 468
						// Edge: 468, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "namespaces": // -> 469
							// Edge: 469, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 470, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "poddisruptionbudgets": // -> 471
									// Edge: 471, path: "poddisruptionbudgets".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}.
										s.handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						case "poddisruptionbudgets": // -> 473
							// GET /apis/policy/v1beta1/watch/poddisruptionbudgets.
							s.handleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest(args, w, r)
							return
						case "podsecuritypolicies": // -> 474
							// Edge: 474, path: "podsecuritypolicies".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/policy/v1beta1/watch/podsecuritypolicies/{name}.
								s.handleWatchPolicyV1beta1PodSecurityPolicyRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/policy/v1beta1/.
						s.handleGetPolicyV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/policy/.
					s.handleGetPolicyAPIGroupRequest(args, w, r)
					return
				}
			case "rbac.authorization.k8s.io": // -> 48
				// Edge: 48, path: "rbac.authorization.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 49
					// Edge: 49, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "clusterroles": // -> 170
						// Edge: 170, path: "clusterroles".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/rbac.authorization.k8s.io/v1/clusterroles/{name}.
							s.handleReadRbacAuthorizationV1ClusterRoleRequest(args, w, r)
							return
						}
					case "clusterrolebindings": // -> 171
						// Edge: 171, path: "clusterrolebindings".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}.
							s.handleReadRbacAuthorizationV1ClusterRoleBindingRequest(args, w, r)
							return
						}
					case "namespaces": // -> 172
						// Edge: 172, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 173, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "roles": // -> 174
								// Edge: 174, path: "roles".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}.
									s.handleReadRbacAuthorizationV1NamespacedRoleRequest(args, w, r)
									return
								}
							case "rolebindings": // -> 175
								// Edge: 175, path: "rolebindings".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}.
									s.handleReadRbacAuthorizationV1NamespacedRoleBindingRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "rolebindings": // -> 176
						// GET /apis/rbac.authorization.k8s.io/v1/rolebindings.
						s.handleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest(args, w, r)
						return
					case "roles": // -> 177
						// GET /apis/rbac.authorization.k8s.io/v1/roles.
						s.handleListRbacAuthorizationV1RoleForAllNamespacesRequest(args, w, r)
						return
					case "watch": // -> 476
						// Edge: 476, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "clusterroles": // -> 477
							// Edge: 477, path: "clusterroles".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}.
								s.handleWatchRbacAuthorizationV1ClusterRoleRequest(args, w, r)
								return
							}
						case "clusterrolebindings": // -> 479
							// Edge: 479, path: "clusterrolebindings".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}.
								s.handleWatchRbacAuthorizationV1ClusterRoleBindingRequest(args, w, r)
								return
							}
						case "namespaces": // -> 481
							// Edge: 481, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 482, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "roles": // -> 483
									// Edge: 483, path: "roles".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}.
										s.handleWatchRbacAuthorizationV1NamespacedRoleRequest(args, w, r)
										return
									}
								case "rolebindings": // -> 485
									// Edge: 485, path: "rolebindings".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}.
										s.handleWatchRbacAuthorizationV1NamespacedRoleBindingRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						case "rolebindings": // -> 487
							// GET /apis/rbac.authorization.k8s.io/v1/watch/rolebindings.
							s.handleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest(args, w, r)
							return
						case "roles": // -> 488
							// GET /apis/rbac.authorization.k8s.io/v1/watch/roles.
							s.handleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest(args, w, r)
							return
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/rbac.authorization.k8s.io/v1/.
						s.handleGetRbacAuthorizationV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/rbac.authorization.k8s.io/.
					s.handleGetRbacAuthorizationAPIGroupRequest(args, w, r)
					return
				}
			case "scheduling.k8s.io": // -> 50
				// Edge: 50, path: "scheduling.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 51
					// Edge: 51, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "priorityclasses": // -> 178
						// Edge: 178, path: "priorityclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/scheduling.k8s.io/v1/priorityclasses/{name}.
							s.handleReadSchedulingV1PriorityClassRequest(args, w, r)
							return
						}
					case "watch": // -> 489
						// Edge: 489, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "priorityclasses": // -> 490
							// Edge: 490, path: "priorityclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}.
								s.handleWatchSchedulingV1PriorityClassRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/scheduling.k8s.io/v1/.
						s.handleGetSchedulingV1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/scheduling.k8s.io/.
					s.handleGetSchedulingAPIGroupRequest(args, w, r)
					return
				}
			case "storage.k8s.io": // -> 54
				// Edge: 54, path: "storage.k8s.io".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "v1": // -> 55
					// Edge: 55, path: "v1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "csidrivers": // -> 179
						// Edge: 179, path: "csidrivers".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/storage.k8s.io/v1/csidrivers/{name}.
							s.handleReadStorageV1CSIDriverRequest(args, w, r)
							return
						}
					case "csinodes": // -> 180
						// Edge: 180, path: "csinodes".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/storage.k8s.io/v1/csinodes/{name}.
							s.handleReadStorageV1CSINodeRequest(args, w, r)
							return
						}
					case "storageclasses": // -> 181
						// Edge: 181, path: "storageclasses".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /apis/storage.k8s.io/v1/storageclasses/{name}.
							s.handleReadStorageV1StorageClassRequest(args, w, r)
							return
						}
					case "volumeattachments": // -> 182
						// Edge: 182, path: "volumeattachments".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 287, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "status": // -> 288
								// GET /apis/storage.k8s.io/v1/volumeattachments/{name}/status.
								s.handleReadStorageV1VolumeAttachmentStatusRequest(args, w, r)
								return
							default:
								// GET /apis/storage.k8s.io/v1/volumeattachments/{name}.
								s.handleReadStorageV1VolumeAttachmentRequest(args, w, r)
								return
							}
						}
					case "watch": // -> 492
						// Edge: 492, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "csidrivers": // -> 493
							// Edge: 493, path: "csidrivers".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/storage.k8s.io/v1/watch/csidrivers/{name}.
								s.handleWatchStorageV1CSIDriverRequest(args, w, r)
								return
							}
						case "csinodes": // -> 495
							// Edge: 495, path: "csinodes".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/storage.k8s.io/v1/watch/csinodes/{name}.
								s.handleWatchStorageV1CSINodeRequest(args, w, r)
								return
							}
						case "storageclasses": // -> 497
							// Edge: 497, path: "storageclasses".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/storage.k8s.io/v1/watch/storageclasses/{name}.
								s.handleWatchStorageV1StorageClassRequest(args, w, r)
								return
							}
						case "volumeattachments": // -> 499
							// Edge: 499, path: "volumeattachments".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /apis/storage.k8s.io/v1/watch/volumeattachments/{name}.
								s.handleWatchStorageV1VolumeAttachmentRequest(args, w, r)
								return
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/storage.k8s.io/v1/.
						s.handleGetStorageV1APIResourcesRequest(args, w, r)
						return
					}
				case "v1alpha1": // -> 56
					// Edge: 56, path: "v1alpha1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "csistoragecapacities": // -> 183
						// GET /apis/storage.k8s.io/v1alpha1/csistoragecapacities.
						s.handleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 184
						// Edge: 184, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 185, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "csistoragecapacities": // -> 186
								// Edge: 186, path: "csistoragecapacities".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities/{name}.
									s.handleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 501
						// Edge: 501, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "csistoragecapacities": // -> 502
							// GET /apis/storage.k8s.io/v1alpha1/watch/csistoragecapacities.
							s.handleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 503
							// Edge: 503, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 504, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "csistoragecapacities": // -> 505
									// Edge: 505, path: "csistoragecapacities".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities/{name}.
										s.handleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/storage.k8s.io/v1alpha1/.
						s.handleGetStorageV1alpha1APIResourcesRequest(args, w, r)
						return
					}
				case "v1beta1": // -> 57
					// Edge: 57, path: "v1beta1".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "csistoragecapacities": // -> 187
						// GET /apis/storage.k8s.io/v1beta1/csistoragecapacities.
						s.handleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 188
						// Edge: 188, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["namespace"] = string(elem)
							// Edge: 189, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "csistoragecapacities": // -> 190
								// Edge: 190, path: "csistoragecapacities".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}.
									s.handleReadStorageV1beta1NamespacedCSIStorageCapacityRequest(args, w, r)
									return
								}
							default:
								s.notFound(w, r)
								return
							}
						}
					case "watch": // -> 507
						// Edge: 507, path: "watch".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "csistoragecapacities": // -> 508
							// GET /apis/storage.k8s.io/v1beta1/watch/csistoragecapacities.
							s.handleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest(args, w, r)
							return
						case "namespaces": // -> 509
							// Edge: 509, path: "namespaces".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["namespace"] = string(elem)
								// Edge: 510, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "csistoragecapacities": // -> 511
									// Edge: 511, path: "csistoragecapacities".
									if len(p) > 1 && p[0] == '/' {
										p = p[1:]
									}
									if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
										elem, p = p, p[:0] // slash not found, using full path
									} else {
										elem = p[:idx] // slash found, element is path until slash
										p = p[idx:]
									}
									switch string(elem) {
									default:
										if args == nil {
											args = make(map[string]string)
										}
										args["name"] = string(elem)
										// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}.
										s.handleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest(args, w, r)
										return
									}
								default:
									s.notFound(w, r)
									return
								}
							}
						default:
							s.notFound(w, r)
							return
						}
					default:
						// GET /apis/storage.k8s.io/v1beta1/.
						s.handleGetStorageV1beta1APIResourcesRequest(args, w, r)
						return
					}
				default:
					// GET /apis/storage.k8s.io/.
					s.handleGetStorageAPIGroupRequest(args, w, r)
					return
				}
			default:
				// GET /apis/.
				s.handleGetAPIVersionsRequest(args, w, r)
				return
			}
		case "version": // -> 23
			// GET /version/.
			s.handleGetCodeVersionRequest(args, w, r)
			return
		case "api": // -> 26
			// Edge: 26, path: "api".
			if len(p) > 1 && p[0] == '/' {
				p = p[1:]
			}
			if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
				elem, p = p, p[:0] // slash not found, using full path
			} else {
				elem = p[:idx] // slash found, element is path until slash
				p = p[idx:]
			}
			switch string(elem) {
			case "v1": // -> 27
				// Edge: 27, path: "v1".
				if len(p) > 1 && p[0] == '/' {
					p = p[1:]
				}
				if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
					elem, p = p, p[:0] // slash not found, using full path
				} else {
					elem = p[:idx] // slash found, element is path until slash
					p = p[idx:]
				}
				switch string(elem) {
				case "componentstatuses": // -> 101
					// Edge: 101, path: "componentstatuses".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					default:
						if args == nil {
							args = make(map[string]string)
						}
						args["name"] = string(elem)
						// GET /api/v1/componentstatuses/{name}.
						s.handleReadCoreV1ComponentStatusRequest(args, w, r)
						return
					}
				case "configmaps": // -> 102
					// GET /api/v1/configmaps.
					s.handleListCoreV1ConfigMapForAllNamespacesRequest(args, w, r)
					return
				case "endpoints": // -> 103
					// GET /api/v1/endpoints.
					s.handleListCoreV1EndpointsForAllNamespacesRequest(args, w, r)
					return
				case "events": // -> 104
					// GET /api/v1/events.
					s.handleListCoreV1EventForAllNamespacesRequest(args, w, r)
					return
				case "limitranges": // -> 105
					// GET /api/v1/limitranges.
					s.handleListCoreV1LimitRangeForAllNamespacesRequest(args, w, r)
					return
				case "namespaces": // -> 106
					// Edge: 106, path: "namespaces".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					default:
						if args == nil {
							args = make(map[string]string)
						}
						args["namespace"] = string(elem)
						// Edge: 107, path: "".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "configmaps": // -> 108
							// Edge: 108, path: "configmaps".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/configmaps/{name}.
								s.handleReadCoreV1NamespacedConfigMapRequest(args, w, r)
								return
							}
						case "endpoints": // -> 109
							// Edge: 109, path: "endpoints".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/endpoints/{name}.
								s.handleReadCoreV1NamespacedEndpointsRequest(args, w, r)
								return
							}
						case "events": // -> 110
							// Edge: 110, path: "events".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/events/{name}.
								s.handleReadCoreV1NamespacedEventRequest(args, w, r)
								return
							}
						case "limitranges": // -> 111
							// Edge: 111, path: "limitranges".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/limitranges/{name}.
								s.handleReadCoreV1NamespacedLimitRangeRequest(args, w, r)
								return
							}
						case "persistentvolumeclaims": // -> 112
							// Edge: 112, path: "persistentvolumeclaims".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// Edge: 233, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "status": // -> 234
									// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status.
									s.handleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest(args, w, r)
									return
								default:
									// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}.
									s.handleReadCoreV1NamespacedPersistentVolumeClaimRequest(args, w, r)
									return
								}
							}
						case "pods": // -> 113
							// Edge: 113, path: "pods".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// Edge: 235, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "ephemeralcontainers": // -> 236
									// GET /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers.
									s.handleReadCoreV1NamespacedPodEphemeralcontainersRequest(args, w, r)
									return
								case "log": // -> 237
									// GET /api/v1/namespaces/{namespace}/pods/{name}/log.
									s.handleReadCoreV1NamespacedPodLogRequest(args, w, r)
									return
								case "status": // -> 238
									// GET /api/v1/namespaces/{namespace}/pods/{name}/status.
									s.handleReadCoreV1NamespacedPodStatusRequest(args, w, r)
									return
								default:
									// GET /api/v1/namespaces/{namespace}/pods/{name}.
									s.handleReadCoreV1NamespacedPodRequest(args, w, r)
									return
								}
							}
						case "podtemplates": // -> 114
							// Edge: 114, path: "podtemplates".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/podtemplates/{name}.
								s.handleReadCoreV1NamespacedPodTemplateRequest(args, w, r)
								return
							}
						case "replicationcontrollers": // -> 115
							// Edge: 115, path: "replicationcontrollers".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// Edge: 240, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "scale": // -> 241
									// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale.
									s.handleReadCoreV1NamespacedReplicationControllerScaleRequest(args, w, r)
									return
								case "status": // -> 242
									// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status.
									s.handleReadCoreV1NamespacedReplicationControllerStatusRequest(args, w, r)
									return
								default:
									// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}.
									s.handleReadCoreV1NamespacedReplicationControllerRequest(args, w, r)
									return
								}
							}
						case "resourcequotas": // -> 116
							// Edge: 116, path: "resourcequotas".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// Edge: 243, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "status": // -> 244
									// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status.
									s.handleReadCoreV1NamespacedResourceQuotaStatusRequest(args, w, r)
									return
								default:
									// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}.
									s.handleReadCoreV1NamespacedResourceQuotaRequest(args, w, r)
									return
								}
							}
						case "secrets": // -> 117
							// Edge: 117, path: "secrets".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/secrets/{name}.
								s.handleReadCoreV1NamespacedSecretRequest(args, w, r)
								return
							}
						case "services": // -> 118
							// Edge: 118, path: "services".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// Edge: 246, path: "".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								case "status": // -> 248
									// GET /api/v1/namespaces/{namespace}/services/{name}/status.
									s.handleReadCoreV1NamespacedServiceStatusRequest(args, w, r)
									return
								default:
									// GET /api/v1/namespaces/{namespace}/services/{name}.
									s.handleReadCoreV1NamespacedServiceRequest(args, w, r)
									return
								}
							}
						case "serviceaccounts": // -> 119
							// Edge: 119, path: "serviceaccounts".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							default:
								if args == nil {
									args = make(map[string]string)
								}
								args["name"] = string(elem)
								// GET /api/v1/namespaces/{namespace}/serviceaccounts/{name}.
								s.handleReadCoreV1NamespacedServiceAccountRequest(args, w, r)
								return
							}
						case "status": // -> 228
							// GET /api/v1/namespaces/{name}/status.
							s.handleReadCoreV1NamespaceStatusRequest(args, w, r)
							return
						default:
							// GET /api/v1/namespaces/{name}.
							s.handleReadCoreV1NamespaceRequest(args, w, r)
							return
						}
					}
				case "nodes": // -> 120
					// Edge: 120, path: "nodes".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					default:
						if args == nil {
							args = make(map[string]string)
						}
						args["name"] = string(elem)
						// Edge: 249, path: "".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "status": // -> 250
							// GET /api/v1/nodes/{name}/status.
							s.handleReadCoreV1NodeStatusRequest(args, w, r)
							return
						default:
							// GET /api/v1/nodes/{name}.
							s.handleReadCoreV1NodeRequest(args, w, r)
							return
						}
					}
				case "persistentvolumes": // -> 121
					// Edge: 121, path: "persistentvolumes".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					default:
						if args == nil {
							args = make(map[string]string)
						}
						args["name"] = string(elem)
						// Edge: 251, path: "".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						case "status": // -> 252
							// GET /api/v1/persistentvolumes/{name}/status.
							s.handleReadCoreV1PersistentVolumeStatusRequest(args, w, r)
							return
						default:
							// GET /api/v1/persistentvolumes/{name}.
							s.handleReadCoreV1PersistentVolumeRequest(args, w, r)
							return
						}
					}
				case "persistentvolumeclaims": // -> 122
					// GET /api/v1/persistentvolumeclaims.
					s.handleListCoreV1PersistentVolumeClaimForAllNamespacesRequest(args, w, r)
					return
				case "pods": // -> 123
					// GET /api/v1/pods.
					s.handleListCoreV1PodForAllNamespacesRequest(args, w, r)
					return
				case "podtemplates": // -> 124
					// GET /api/v1/podtemplates.
					s.handleListCoreV1PodTemplateForAllNamespacesRequest(args, w, r)
					return
				case "replicationcontrollers": // -> 125
					// GET /api/v1/replicationcontrollers.
					s.handleListCoreV1ReplicationControllerForAllNamespacesRequest(args, w, r)
					return
				case "resourcequotas": // -> 126
					// GET /api/v1/resourcequotas.
					s.handleListCoreV1ResourceQuotaForAllNamespacesRequest(args, w, r)
					return
				case "secrets": // -> 127
					// GET /api/v1/secrets.
					s.handleListCoreV1SecretForAllNamespacesRequest(args, w, r)
					return
				case "serviceaccounts": // -> 128
					// GET /api/v1/serviceaccounts.
					s.handleListCoreV1ServiceAccountForAllNamespacesRequest(args, w, r)
					return
				case "services": // -> 129
					// GET /api/v1/services.
					s.handleListCoreV1ServiceForAllNamespacesRequest(args, w, r)
					return
				case "watch": // -> 362
					// Edge: 362, path: "watch".
					if len(p) > 1 && p[0] == '/' {
						p = p[1:]
					}
					if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
						elem, p = p, p[:0] // slash not found, using full path
					} else {
						elem = p[:idx] // slash found, element is path until slash
						p = p[idx:]
					}
					switch string(elem) {
					case "configmaps": // -> 363
						// GET /api/v1/watch/configmaps.
						s.handleWatchCoreV1ConfigMapListForAllNamespacesRequest(args, w, r)
						return
					case "endpoints": // -> 364
						// GET /api/v1/watch/endpoints.
						s.handleWatchCoreV1EndpointsListForAllNamespacesRequest(args, w, r)
						return
					case "events": // -> 365
						// GET /api/v1/watch/events.
						s.handleWatchCoreV1EventListForAllNamespacesRequest(args, w, r)
						return
					case "limitranges": // -> 366
						// GET /api/v1/watch/limitranges.
						s.handleWatchCoreV1LimitRangeListForAllNamespacesRequest(args, w, r)
						return
					case "namespaces": // -> 367
						// Edge: 367, path: "namespaces".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// Edge: 368, path: "".
							if len(p) > 1 && p[0] == '/' {
								p = p[1:]
							}
							if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
								elem, p = p, p[:0] // slash not found, using full path
							} else {
								elem = p[:idx] // slash found, element is path until slash
								p = p[idx:]
							}
							switch string(elem) {
							case "configmaps": // -> 369
								// Edge: 369, path: "configmaps".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/configmaps/{name}.
									s.handleWatchCoreV1NamespacedConfigMapRequest(args, w, r)
									return
								}
							case "endpoints": // -> 371
								// Edge: 371, path: "endpoints".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/endpoints/{name}.
									s.handleWatchCoreV1NamespacedEndpointsRequest(args, w, r)
									return
								}
							case "events": // -> 373
								// Edge: 373, path: "events".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/events/{name}.
									s.handleWatchCoreV1NamespacedEventRequest(args, w, r)
									return
								}
							case "limitranges": // -> 375
								// Edge: 375, path: "limitranges".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/limitranges/{name}.
									s.handleWatchCoreV1NamespacedLimitRangeRequest(args, w, r)
									return
								}
							case "persistentvolumeclaims": // -> 377
								// Edge: 377, path: "persistentvolumeclaims".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}.
									s.handleWatchCoreV1NamespacedPersistentVolumeClaimRequest(args, w, r)
									return
								}
							case "pods": // -> 379
								// Edge: 379, path: "pods".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/pods/{name}.
									s.handleWatchCoreV1NamespacedPodRequest(args, w, r)
									return
								}
							case "podtemplates": // -> 381
								// Edge: 381, path: "podtemplates".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/podtemplates/{name}.
									s.handleWatchCoreV1NamespacedPodTemplateRequest(args, w, r)
									return
								}
							case "replicationcontrollers": // -> 383
								// Edge: 383, path: "replicationcontrollers".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}.
									s.handleWatchCoreV1NamespacedReplicationControllerRequest(args, w, r)
									return
								}
							case "resourcequotas": // -> 385
								// Edge: 385, path: "resourcequotas".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/resourcequotas/{name}.
									s.handleWatchCoreV1NamespacedResourceQuotaRequest(args, w, r)
									return
								}
							case "secrets": // -> 387
								// Edge: 387, path: "secrets".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/secrets/{name}.
									s.handleWatchCoreV1NamespacedSecretRequest(args, w, r)
									return
								}
							case "services": // -> 389
								// Edge: 389, path: "services".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/services/{name}.
									s.handleWatchCoreV1NamespacedServiceRequest(args, w, r)
									return
								}
							case "serviceaccounts": // -> 391
								// Edge: 391, path: "serviceaccounts".
								if len(p) > 1 && p[0] == '/' {
									p = p[1:]
								}
								if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
									elem, p = p, p[:0] // slash not found, using full path
								} else {
									elem = p[:idx] // slash found, element is path until slash
									p = p[idx:]
								}
								switch string(elem) {
								default:
									if args == nil {
										args = make(map[string]string)
									}
									args["name"] = string(elem)
									// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}.
									s.handleWatchCoreV1NamespacedServiceAccountRequest(args, w, r)
									return
								}
							default:
								// GET /api/v1/watch/namespaces/{name}.
								s.handleWatchCoreV1NamespaceRequest(args, w, r)
								return
							}
						}
					case "nodes": // -> 393
						// Edge: 393, path: "nodes".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /api/v1/watch/nodes/{name}.
							s.handleWatchCoreV1NodeRequest(args, w, r)
							return
						}
					case "persistentvolumes": // -> 395
						// Edge: 395, path: "persistentvolumes".
						if len(p) > 1 && p[0] == '/' {
							p = p[1:]
						}
						if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
							elem, p = p, p[:0] // slash not found, using full path
						} else {
							elem = p[:idx] // slash found, element is path until slash
							p = p[idx:]
						}
						switch string(elem) {
						default:
							if args == nil {
								args = make(map[string]string)
							}
							args["name"] = string(elem)
							// GET /api/v1/watch/persistentvolumes/{name}.
							s.handleWatchCoreV1PersistentVolumeRequest(args, w, r)
							return
						}
					case "persistentvolumeclaims": // -> 397
						// GET /api/v1/watch/persistentvolumeclaims.
						s.handleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest(args, w, r)
						return
					case "pods": // -> 398
						// GET /api/v1/watch/pods.
						s.handleWatchCoreV1PodListForAllNamespacesRequest(args, w, r)
						return
					case "podtemplates": // -> 399
						// GET /api/v1/watch/podtemplates.
						s.handleWatchCoreV1PodTemplateListForAllNamespacesRequest(args, w, r)
						return
					case "replicationcontrollers": // -> 400
						// GET /api/v1/watch/replicationcontrollers.
						s.handleWatchCoreV1ReplicationControllerListForAllNamespacesRequest(args, w, r)
						return
					case "resourcequotas": // -> 401
						// GET /api/v1/watch/resourcequotas.
						s.handleWatchCoreV1ResourceQuotaListForAllNamespacesRequest(args, w, r)
						return
					case "secrets": // -> 402
						// GET /api/v1/watch/secrets.
						s.handleWatchCoreV1SecretListForAllNamespacesRequest(args, w, r)
						return
					case "serviceaccounts": // -> 403
						// GET /api/v1/watch/serviceaccounts.
						s.handleWatchCoreV1ServiceAccountListForAllNamespacesRequest(args, w, r)
						return
					case "services": // -> 404
						// GET /api/v1/watch/services.
						s.handleWatchCoreV1ServiceListForAllNamespacesRequest(args, w, r)
						return
					default:
						s.notFound(w, r)
						return
					}
				default:
					// GET /api/v1/.
					s.handleGetCoreV1APIResourcesRequest(args, w, r)
					return
				}
			default:
				// GET /api/.
				s.handleGetCoreAPIVersionsRequest(args, w, r)
				return
			}
		case ".well-known": // -> 52
			// Edge: 52, path: ".well-known".
			if len(p) > 1 && p[0] == '/' {
				p = p[1:]
			}
			if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
				elem, p = p, p[:0] // slash not found, using full path
			} else {
				elem = p[:idx] // slash found, element is path until slash
				p = p[idx:]
			}
			switch string(elem) {
			case "openid-configuration": // -> 53
				// GET /.well-known/openid-configuration/.
				s.handleGetServiceAccountIssuerOpenIDConfigurationRequest(args, w, r)
				return
			default:
				s.notFound(w, r)
				return
			}
		case "logs": // -> 191
			// Edge: 191, path: "logs".
			if len(p) > 1 && p[0] == '/' {
				p = p[1:]
			}
			if idx = bytes.IndexByte(p[:], '/'); idx < 0 { // looking for next element
				elem, p = p, p[:0] // slash not found, using full path
			} else {
				elem = p[:idx] // slash found, element is path until slash
				p = p[idx:]
			}
			switch string(elem) {
			default:
				if args == nil {
					args = make(map[string]string)
				}
				args["logpath"] = string(elem)
				// GET /logs/{logpath}.
				s.handleLogFileHandlerRequest(args, w, r)
				return
			}
		default:
			s.notFound(w, r)
			return
		}
	default:
		s.notFound(w, r)
		return
	}
}
