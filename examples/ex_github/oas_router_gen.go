// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"strings"
)

func (s *Server) notFound(w http.ResponseWriter, r *http.Request) {
	s.cfg.NotFound(w, r)
}

func (s *Server) notAllowed(w http.ResponseWriter, r *http.Request, allowed string) {
	s.cfg.MethodNotAllowed(w, r, allowed)
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [5]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				switch r.Method {
				case "GET":
					s.handleMetaRootRequest([0]string{}, w, r)
				default:
					s.notAllowed(w, r, "GET")
				}

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleAppsGetAuthenticatedRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '-': // Prefix: "-manifests/"
						if l := len("-manifests/"); len(elem) >= l && elem[0:l] == "-manifests/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "code"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/conversions"
							if l := len("/conversions"); len(elem) >= l && elem[0:l] == "/conversions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAppsCreateFromManifestRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/"
							if l := len("hook/"); len(elem) >= l && elem[0:l] == "hook/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "config"
								if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsGetWebhookConfigForAppRequest([0]string{}, w, r)
									case "PATCH":
										s.handleAppsUpdateWebhookConfigForAppRequest([0]string{}, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}
							case 'd': // Prefix: "deliveries"
								if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleAppsListWebhookDeliveriesRequest([0]string{}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleAppsGetWebhookDeliveryRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"
										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAppsRedeliverWebhookDeliveryRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}
									}
								}
							}
						case 'i': // Prefix: "installations/"
							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleAppsDeleteInstallationRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "access_tokens"
									if l := len("access_tokens"); len(elem) >= l && elem[0:l] == "access_tokens" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleAppsCreateInstallationAccessTokenRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								case 's': // Prefix: "suspended"
									if l := len("suspended"); len(elem) >= l && elem[0:l] == "suspended" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleAppsUnsuspendInstallationRequest([1]string{
												args[0],
											}, w, r)
										case "PUT":
											s.handleAppsSuspendInstallationRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,PUT")
										}

										return
									}
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants"
							if l := len("grants"); len(elem) >= l && elem[0:l] == "grants" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOAuthAuthorizationsListGrantsRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "grant_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleOAuthAuthorizationsDeleteGrantRequest([1]string{
											args[0],
										}, w, r)
									case "GET":
										s.handleOAuthAuthorizationsGetGrantRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}
							}
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"
								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleAppsDeleteAuthorizationRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							case 't': // Prefix: "token"
								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleAppsDeleteTokenRequest([1]string{
											args[0],
										}, w, r)
									case "PATCH":
										s.handleAppsResetTokenRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleAppsCheckTokenRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PATCH,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/scoped"
									if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleAppsScopeTokenRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								}
							}
						}
					case 's': // Prefix: "s/"
						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAppsGetBySlugRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleOAuthAuthorizationsListAuthorizationsRequest([0]string{}, w, r)
						case "POST":
							s.handleOAuthAuthorizationsCreateAuthorizationRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "clients/"
							if l := len("clients/"); len(elem) >= l && elem[0:l] == "clients/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "client_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "PUT":
									s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "fingerprint"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							}
						}
						// Param: "authorization_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleOAuthAuthorizationsDeleteAuthorizationRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleOAuthAuthorizationsGetAuthorizationRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleOAuthAuthorizationsUpdateAuthorizationRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
					}
				}
			case 'c': // Prefix: "codes_of_conduct"
				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleCodesOfConductGetAllCodesOfConductRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleCodesOfConductGetConductCodeRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"
					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleEmojisGetRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				case 'n': // Prefix: "nterprises/"
					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest([1]string{
												args[0],
											}, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"
											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
														args[0],
													}, w, r)
												case "PUT":
													s.handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "org_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest([1]string{
														args[0],
													}, w, r)
												case "PUT":
													s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest([1]string{
													args[0],
												}, w, r)
											case "POST":
												s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PATCH":
													s.handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"
													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "PUT":
															s.handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "org_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												case 'r': // Prefix: "runners"
													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "PUT":
															s.handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest([1]string{
															args[0],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"
													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest([1]string{
																args[0],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												case 'm': // Prefix: "move-token"
													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest([1]string{
																args[0],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminGetAuditLogRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case 's': // Prefix: "settings/billing/"
							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"
								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetGithubActionsBillingGheRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'p': // Prefix: "packages"
								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetGithubPackagesBillingGheRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 's': // Prefix: "shared-storage"
								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetSharedStorageBillingGheRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 'v': // Prefix: "vents"
					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleActivityListPublicEventsRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'f': // Prefix: "feeds"
				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleActivityGetFeedsRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
			case 'g': // Prefix: "gi"
				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "sts"
					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGistsListRequest([0]string{}, w, r)
						case "POST":
							s.handleGistsCreateRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsListPublicRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 's': // Prefix: "starred"
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsListStarredRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleGistsDeleteRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleGistsGetRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"
									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGistsListCommentsRequest([1]string{
												args[0],
											}, w, r)
										case "POST":
											s.handleGistsCreateCommentRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleGistsDeleteCommentRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "GET":
												s.handleGistsGetCommentRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PATCH":
												s.handleGistsUpdateCommentRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PATCH")
											}

											return
										}
									}
								case 'i': // Prefix: "its"
									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGistsListCommitsRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 'f': // Prefix: "forks"
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGistsListForksRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleGistsForkRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
							case 's': // Prefix: "star"
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleGistsUnstarRequest([1]string{
											args[0],
										}, w, r)
									case "GET":
										s.handleGistsCheckIsStarredRequest([1]string{
											args[0],
										}, w, r)
									case "PUT":
										s.handleGistsStarRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
							}
							// Param: "sha"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsGetRevisionRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 't': // Prefix: "tignore/templates"
					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGitignoreGetAllTemplatesRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGitignoreGetTemplateRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/"
					if l := len("nstallation/"); len(elem) >= l && elem[0:l] == "nstallation/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAppsListReposAccessibleToInstallationRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 't': // Prefix: "token"
						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleAppsRevokeInstallationAccessTokenRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
					}
				case 's': // Prefix: "ssues"
					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleIssuesListRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'l': // Prefix: "licenses"
				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleLicensesGetAllCommonlyUsedRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleLicensesGetRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'm': // Prefix: "m"
				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "arketplace_listing/"
					if l := len("arketplace_listing/"); len(elem) >= l && elem[0:l] == "arketplace_listing/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "accounts/"
						if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "account_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAppsGetSubscriptionPlanForAccountRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'p': // Prefix: "plans"
						if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleAppsListPlansRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "plan_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/accounts"
								if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsListAccountsForPlanRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					case 's': // Prefix: "stubbed/"
						if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"
							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAppsGetSubscriptionPlanForAccountStubbedRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'p': // Prefix: "plans"
							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleAppsListPlansStubbedRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"
									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAppsListAccountsForPlanStubbedRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eta"
					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleMetaGetRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'n': // Prefix: "n"
				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"
					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"
							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleActivityListPublicEventsForRepoNetworkRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 'o': // Prefix: "otifications"
					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleActivityListNotificationsForAuthenticatedUserRequest([0]string{}, w, r)
						case "PUT":
							s.handleActivityMarkNotificationsAsReadRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,PUT")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"
						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleActivityGetThreadRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleActivityMarkThreadAsReadRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"
							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleActivityDeleteThreadSubscriptionRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleActivityGetThreadSubscriptionForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)
								case "PUT":
									s.handleActivitySetThreadSubscriptionRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						}
					}
				}
			case 'o': // Prefix: "org"
				if l := len("org"); len(elem) >= l && elem[0:l] == "org" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "anizations"
					if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleOrgsListRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleOrgsGetRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleActionsGetGithubActionsPermissionsOrganizationRequest([1]string{
												args[0],
											}, w, r)
										case "PUT":
											s.handleActionsSetGithubActionsPermissionsOrganizationRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
														args[0],
													}, w, r)
												case "PUT":
													s.handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleActionsGetAllowedActionsOrganizationRequest([1]string{
														args[0],
													}, w, r)
												case "PUT":
													s.handleActionsSetAllowedActionsOrganizationRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsListSelfHostedRunnerGroupsForOrgRequest([1]string{
													args[0],
												}, w, r)
											case "POST":
												s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleActionsGetSelfHostedRunnerGroupForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PATCH":
													s.handleActionsUpdateSelfHostedRunnerGroupForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/r"
												if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "epositories"
													if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "PUT":
															s.handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "repository_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												case 'u': // Prefix: "unners"
													if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListSelfHostedRunnersInGroupForOrgRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "PUT":
															s.handleActionsSetSelfHostedRunnersInGroupForOrgRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsListSelfHostedRunnersForOrgRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsListRunnerApplicationsForOrgRequest([1]string{
															args[0],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"
													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleActionsCreateRegistrationTokenForOrgRequest([1]string{
																args[0],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												case 'm': // Prefix: "move-token"
													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleActionsCreateRemoveTokenForOrgRequest([1]string{
																args[0],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleActionsDeleteSelfHostedRunnerFromOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleActionsGetSelfHostedRunnerForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
										}
									}
								case 's': // Prefix: "secrets"
									if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleActionsListOrgSecretsRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleActionsGetOrgPublicKeyRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										}
										// Param: "secret_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleActionsDeleteOrgSecretRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "GET":
												s.handleActionsGetOrgSecretRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PUT":
												s.handleActionsCreateOrUpdateOrgSecretRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/repositories"
											if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleActionsListSelectedReposForOrgSecretRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PUT":
													s.handleActionsSetSelectedReposForOrgSecretRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleActionsRemoveSelectedRepoFromOrgSecretRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PUT":
														s.handleActionsAddSelectedRepoToOrgSecretRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsGetAuditLogRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case 'b': // Prefix: "blocks"
							if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListBlockedUsersRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleOrgsUnblockUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "GET":
										s.handleOrgsCheckBlockedUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "PUT":
										s.handleOrgsBlockUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
							}
						case 'c': // Prefix: "credential-authorizations"
							if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListSamlSSOAuthorizationsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "credential_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleOrgsRemoveSamlSSOAuthorizationRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							}
						case 'e': // Prefix: "events"
							if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleActivityListPublicOrgEventsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'f': // Prefix: "failed_invitations"
							if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleOrgsListFailedInvitationsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListWebhooksRequest([1]string{
										args[0],
									}, w, r)
								case "POST":
									s.handleOrgsCreateWebhookRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleOrgsDeleteWebhookRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "GET":
										s.handleOrgsGetWebhookRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "PATCH":
										s.handleOrgsUpdateWebhookRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleOrgsGetWebhookConfigForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PATCH":
												s.handleOrgsUpdateWebhookConfigForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,PATCH")
											}

											return
										}
									case 'd': // Prefix: "deliveries"
										if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleOrgsListWebhookDeliveriesRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "delivery_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleOrgsGetWebhookDeliveryRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/attempts"
												if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleOrgsRedeliverWebhookDeliveryRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
										}
									case 'p': // Prefix: "pings"
										if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleOrgsPingWebhookRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}
									}
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'n': // Prefix: "n"
								if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 't': // Prefix: "teraction-limits"
									if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleInteractionsRemoveRestrictionsForOrgRequest([1]string{
												args[0],
											}, w, r)
										case "PUT":
											s.handleInteractionsSetRestrictionsForOrgRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,PUT")
										}

										return
									}
								case 'v': // Prefix: "vitations"
									if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleOrgsListPendingInvitationsRequest([1]string{
												args[0],
											}, w, r)
										case "POST":
											s.handleOrgsCreateInvitationRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "invitation_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleOrgsCancelInvitationRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/teams"
											if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleOrgsListInvitationTeamsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										}
									}
								}
							case 's': // Prefix: "ssues"
								if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleIssuesListForOrgRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "embers"
								if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListMembersRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsRemoveMemberRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleOrgsCheckMembershipForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET")
										}

										return
									}
								case 'h': // Prefix: "hips/"
									if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsRemoveMembershipForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleOrgsGetMembershipForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PUT":
											s.handleOrgsSetMembershipForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}
								}
							case 'i': // Prefix: "igrations"
								if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleMigrationsListForOrgRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleMigrationsStartForOrgRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "migration_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleMigrationsGetStatusForOrgRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleMigrationsDeleteArchiveForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleMigrationsDownloadArchiveForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repo_name"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/lock"
													if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleMigrationsUnlockRepoForOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE")
														}

														return
													}
												}
											case 'i': // Prefix: "itories"
												if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleMigrationsListReposForOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										}
									}
								}
							}
						case 'o': // Prefix: "outside_collaborators"
							if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListOutsideCollaboratorsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleOrgsRemoveOutsideCollaboratorRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "PUT":
										s.handleOrgsConvertMemberToOutsideCollaboratorRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PUT")
									}

									return
								}
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages"
								if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handlePackagesListPackagesForOrganizationRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handlePackagesDeletePackageForOrgRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											case "GET":
												s.handlePackagesGetPackageForOrganizationRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "restore"
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handlePackagesRestorePackageForOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											case 'v': // Prefix: "versions"
												if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[3] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handlePackagesDeletePackageVersionForOrgRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)
														case "GET":
															s.handlePackagesGetPackageVersionForOrganizationRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/restore"
														if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handlePackagesRestorePackageVersionForOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}
													}
												}
											}
										}
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleProjectsListForOrgRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleProjectsCreateForOrgRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
							case 'u': // Prefix: "ublic_members"
								if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListPublicMembersRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsRemovePublicMembershipForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleOrgsCheckPublicMembershipForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PUT":
											s.handleOrgsSetPublicMembershipForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReposListForOrgRequest([1]string{
										args[0],
									}, w, r)
								case "POST":
									s.handleReposCreateInOrgRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
						case 's': // Prefix: "se"
							if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "cret-scanning/alerts"
								if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSecretScanningListAlertsForOrgRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 't': // Prefix: "ttings/billing/"
								if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"
									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleBillingGetGithubActionsBillingOrgRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 'p': // Prefix: "packages"
									if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleBillingGetGithubPackagesBillingOrgRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 's': // Prefix: "shared-storage"
									if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleBillingGetSharedStorageBillingOrgRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							}
						case 't': // Prefix: "team"
							if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-sync/groups"
								if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleTeamsListIdpGroupsForOrgRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleTeamsListRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleTeamsCreateRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "team_slug"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleTeamsDeleteInOrgRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleTeamsGetByNameRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PATCH":
											s.handleTeamsUpdateInOrgRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'd': // Prefix: "discussions"
											if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleTeamsListDiscussionsInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleTeamsCreateDiscussionInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "discussion_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleTeamsDeleteDiscussionInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleTeamsGetDiscussionInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handleTeamsUpdateDiscussionInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleTeamsListDiscussionCommentsInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "POST":
																s.handleTeamsCreateDiscussionCommentInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "DELETE":
																	s.handleTeamsDeleteDiscussionCommentInOrgRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																case "GET":
																	s.handleTeamsGetDiscussionCommentInOrgRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																case "PATCH":
																	s.handleTeamsUpdateDiscussionCommentInOrgRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET,PATCH")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "GET":
																		s.handleReactionsListForTeamDiscussionCommentInOrgRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	case "POST":
																		s.handleReactionsCreateForTeamDiscussionCommentInOrgRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "GET,POST")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter
																	args[4] = elem
																	elem = ""

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "DELETE":
																			s.handleReactionsDeleteForTeamDiscussionCommentRequest([5]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																				args[4],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "DELETE")
																		}

																		return
																	}
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReactionsListForTeamDiscussionInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "POST":
																s.handleReactionsCreateForTeamDiscussionInOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleReactionsDeleteForTeamDiscussionRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE")
																}

																return
															}
														}
													}
												}
											}
										case 'i': // Prefix: "invitations"
											if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleTeamsListPendingInvitationsInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										case 'm': // Prefix: "members"
											if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleTeamsListMembersInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case 'h': // Prefix: "hips/"
												if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleTeamsRemoveMembershipForUserInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleTeamsGetMembershipForUserInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PUT":
														s.handleTeamsAddOrUpdateMembershipForUserInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}
											}
										case 'p': // Prefix: "projects"
											if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleTeamsListProjectsInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "project_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleTeamsRemoveProjectInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleTeamsCheckPermissionsForProjectInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PUT":
														s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleTeamsListReposInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "owner"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleTeamsRemoveRepoInOrgRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)
														case "GET":
															s.handleTeamsCheckPermissionsForRepoInOrgRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)
														case "PUT":
															s.handleTeamsAddOrUpdateRepoPermissionsInOrgRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
												}
											}
										case 't': // Prefix: "team"
											if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-sync/group-mappings"
												if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleTeamsListIdpGroupsInOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PATCH":
														s.handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleTeamsListChildInOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleProjectsDeleteCardRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleProjectsGetCardRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleProjectsUpdateCardRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"
							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsMoveCardRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleProjectsDeleteColumnRequest([1]string{
								args[0],
							}, w, r)
						case "GET":
							s.handleProjectsGetColumnRequest([1]string{
								args[0],
							}, w, r)
						case "PATCH":
							s.handleProjectsUpdateColumnRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PATCH")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "cards"
							if l := len("cards"); len(elem) >= l && elem[0:l] == "cards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleProjectsListCardsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'm': // Prefix: "moves"
							if l := len("moves"); len(elem) >= l && elem[0:l] == "moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsMoveColumnRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch r.Method {
					case "DELETE":
						s.handleProjectsDeleteRequest([1]string{
							args[0],
						}, w, r)
					case "GET":
						s.handleProjectsGetRequest([1]string{
							args[0],
						}, w, r)
					case "PATCH":
						s.handleProjectsUpdateRequest([1]string{
							args[0],
						}, w, r)
					default:
						s.notAllowed(w, r, "DELETE,GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/col"
					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"
						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleProjectsListCollaboratorsRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleProjectsRemoveCollaboratorRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "PUT":
									s.handleProjectsAddCollaboratorRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"
								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleProjectsGetPermissionForUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					case 'u': // Prefix: "umns"
						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleProjectsListColumnsRequest([1]string{
									args[0],
								}, w, r)
							case "POST":
								s.handleProjectsCreateColumnRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
					}
				}
			case 'r': // Prefix: "r"
				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"
					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleRateLimitGetRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				case 'e': // Prefix: "e"
					if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "reaction_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleReactionsDeleteLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
					case 'p': // Prefix: "pos"
						if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleReposDeleteRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "GET":
										s.handleReposGetRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									case "PATCH":
										s.handleReposUpdateRequest([2]string{
											args[0],
											args[1],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "ctions/"
											if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "artifacts"
												if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListArtifactsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "artifact_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleActionsDeleteArtifactRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleActionsGetArtifactRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "archive_format"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleActionsDownloadArtifactRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											case 'j': // Prefix: "jobs/"
												if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "job_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsGetJobForWorkflowRunRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"
													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleActionsDownloadJobLogsForWorkflowRunRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 'p': // Prefix: "permissions"
												if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsGetGithubActionsPermissionsRepositoryRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleActionsSetGithubActionsPermissionsRepositoryRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,PUT")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/selected-actions"
													if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleActionsGetAllowedActionsRepositoryRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "PUT":
															s.handleActionsSetAllowedActionsRepositoryRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
												}
											case 'r': // Prefix: "run"
												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'n': // Prefix: "ners"
													if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListSelfHostedRunnersForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'd': // Prefix: "downloads"
															if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleActionsListRunnerApplicationsForRepoRequest([2]string{
																		args[0],
																		args[1],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
														case 'r': // Prefix: "re"
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'g': // Prefix: "gistration-token"
																if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCreateRegistrationTokenForRepoRequest([2]string{
																			args[0],
																			args[1],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}
															case 'm': // Prefix: "move-token"
																if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCreateRemoveTokenForRepoRequest([2]string{
																			args[0],
																			args[1],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}
															}
														}
														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleActionsDeleteSelfHostedRunnerFromRepoRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "GET":
																s.handleActionsGetSelfHostedRunnerForRepoRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
													}
												case 's': // Prefix: "s"
													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListWorkflowRunsForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "run_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handleActionsDeleteWorkflowRunRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "GET":
																s.handleActionsGetWorkflowRunRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'a': // Prefix: "a"
																if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pprov"
																	if l := len("pprov"); len(elem) >= l && elem[0:l] == "pprov" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "als"
																		if l := len("als"); len(elem) >= l && elem[0:l] == "als" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleActionsGetReviewsForRunRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}
																	case 'e': // Prefix: "e"
																		if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "POST":
																				s.handleActionsApproveWorkflowRunRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "POST")
																			}

																			return
																		}
																	}
																case 'r': // Prefix: "rtifacts"
																	if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleActionsListWorkflowRunArtifactsRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}
																}
															case 'c': // Prefix: "cancel"
																if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCancelWorkflowRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}
															case 'j': // Prefix: "jobs"
																if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleActionsListJobsForWorkflowRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}
															case 'l': // Prefix: "logs"
																if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleActionsDeleteWorkflowRunLogsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	case "GET":
																		s.handleActionsDownloadWorkflowRunLogsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET")
																	}

																	return
																}
															case 'p': // Prefix: "pending_deployments"
																if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsReviewPendingDeploymentsForRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}
															case 'r': // Prefix: "re"
																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'r': // Prefix: "run"
																	if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handleActionsReRunWorkflowRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}
																case 't': // Prefix: "try"
																	if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handleActionsRetryWorkflowRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}
																}
															case 't': // Prefix: "timing"
																if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleActionsGetWorkflowRunUsageRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}
															}
														}
													}
												}
											case 's': // Prefix: "secrets"
												if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListRepoSecretsRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "public-key"
														if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleActionsGetRepoPublicKeyRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
													// Param: "secret_name"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleActionsDeleteRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleActionsGetRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PUT":
															s.handleActionsCreateOrUpdateRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
												}
											case 'w': // Prefix: "workflows"
												if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsListRepoWorkflowsRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										case 's': // Prefix: "ssignees"
											if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListAssigneesRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "assignee"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleIssuesCheckUserCanBeAssignedRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										case 'u': // Prefix: "uto"
											if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "links"
												if l := len("links"); len(elem) >= l && elem[0:l] == "links" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListAutolinksRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "POST":
														s.handleReposCreateAutolinkRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteAutolinkRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleReposGetAutolinkRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET")
														}

														return
													}
												}
											case 'm': // Prefix: "mated-security-fixes"
												if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleReposDisableAutomatedSecurityFixesRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleReposEnableAutomatedSecurityFixesRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}
											}
										}
									case 'b': // Prefix: "branches"
										if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListBranchesRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "branch"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposGetBranchRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'p': // Prefix: "protection"
													if l := len("protection"); len(elem) >= l && elem[0:l] == "protection" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleReposGetBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PUT":
															s.handleReposUpdateBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "enforce_admins"
															if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleReposDeleteAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "GET":
																	s.handleReposGetAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "POST":
																	s.handleReposSetAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET,POST")
																}

																return
															}
														case 'r': // Prefix: "re"
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'q': // Prefix: "quired_"
																if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pull_request_reviews"
																	if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "DELETE":
																			s.handleReposDeletePullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		case "GET":
																			s.handleReposGetPullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		case "PATCH":
																			s.handleReposUpdatePullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "DELETE,GET,PATCH")
																		}

																		return
																	}
																case 's': // Prefix: "s"
																	if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'i': // Prefix: "ignatures"
																		if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposDeleteCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "GET":
																				s.handleReposGetCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "POST":
																				s.handleReposCreateCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST")
																			}

																			return
																		}
																	case 't': // Prefix: "tatus_checks"
																		if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveStatusCheckProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "GET":
																				s.handleReposGetStatusChecksProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "PATCH":
																				s.handleReposUpdateStatusCheckProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,PATCH")
																			}

																			return
																		}
																		switch elem[0] {
																		case '/': // Prefix: "/contexts"
																			if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "DELETE":
																					s.handleReposRemoveStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				case "GET":
																					s.handleReposGetAllStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				case "POST":
																					s.handleReposAddStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				case "PUT":
																					s.handleReposSetStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				default:
																					s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																				}

																				return
																			}
																		}
																	}
																}
															case 's': // Prefix: "strictions"
																if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "DELETE":
																		s.handleReposDeleteAccessRestrictionsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	case "GET":
																		s.handleReposGetAccessRestrictionsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "apps"
																		if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "GET":
																				s.handleReposGetAppsWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "POST":
																				s.handleReposAddAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "PUT":
																				s.handleReposSetAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}
																	case 't': // Prefix: "teams"
																		if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "GET":
																				s.handleReposGetTeamsWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "POST":
																				s.handleReposAddTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "PUT":
																				s.handleReposSetTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}
																	case 'u': // Prefix: "users"
																		if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "GET":
																				s.handleReposGetUsersWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "POST":
																				s.handleReposAddUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "PUT":
																				s.handleReposSetUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}
																	}
																}
															}
														}
													}
												case 'r': // Prefix: "rename"
													if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposRenameBranchRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
										}
									case 'c': // Prefix: "c"
										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "heck-"
											if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "runs/"
												if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "check_run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleChecksGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/annotations"
													if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleChecksListAnnotationsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 's': // Prefix: "suites"
												if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleChecksCreateSuiteRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "preferences"
														if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleChecksSetSuitesPreferencesRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}
													}
													// Param: "check_suite_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleChecksGetSuiteRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "check-runs"
															if l := len("check-runs"); len(elem) >= l && elem[0:l] == "check-runs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleChecksListForSuiteRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
														case 'r': // Prefix: "rerequest"
															if l := len("rerequest"); len(elem) >= l && elem[0:l] == "rerequest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleChecksRerequestSuiteRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}
														}
													}
												}
											}
										case 'o': // Prefix: "o"
											if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "de-scanning/"
												if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "a"
													if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'l': // Prefix: "lerts"
														if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleCodeScanningListAlertsForRepoRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "alert_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleCodeScanningGetAlertRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "PATCH":
																	s.handleCodeScanningUpdateAlertRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET,PATCH")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/instances"
																if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleCodeScanningListAlertInstancesRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}
															}
														}
													case 'n': // Prefix: "nalyses"
														if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleCodeScanningListRecentAnalysesRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "analysis_id"
															// Leaf parameter
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleCodeScanningDeleteAnalysisRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "GET":
																	s.handleCodeScanningGetAnalysisRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}
														}
													}
												case 's': // Prefix: "sarifs"
													if l := len("sarifs"); len(elem) >= l && elem[0:l] == "sarifs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleCodeScanningUploadSarifRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "sarif_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleCodeScanningGetSarifRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											case 'l': // Prefix: "llaborators"
												if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListCollaboratorsRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleReposRemoveCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleReposCheckCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PUT":
															s.handleReposAddCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/permission"
														if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCollaboratorPermissionLevelRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											case 'm': // Prefix: "m"
												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'm': // Prefix: "m"
													if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"
														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposListCommitCommentsForRepoRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "DELETE":
																	s.handleReposDeleteCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "GET":
																	s.handleReposGetCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "PATCH":
																	s.handleReposUpdateCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET,PATCH")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "GET":
																		s.handleReactionsListForCommitCommentRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	case "POST":
																		s.handleReactionsCreateForCommitCommentRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "GET,POST")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter
																	args[3] = elem
																	elem = ""

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "DELETE":
																			s.handleReactionsDeleteForCommitCommentRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "DELETE")
																		}

																		return
																	}
																}
															}
														}
													case 'i': // Prefix: "its"
														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposListCommitsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "ref"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReposGetCommitRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'b': // Prefix: "branches-where-head"
																	if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleReposListBranchesForHeadCommitRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}
																case 'c': // Prefix: "c"
																	if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'h': // Prefix: "heck-"
																		if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			break
																		}
																		switch elem[0] {
																		case 'r': // Prefix: "runs"
																			if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "GET":
																					s.handleChecksListForRefRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				default:
																					s.notAllowed(w, r, "GET")
																				}

																				return
																			}
																		case 's': // Prefix: "suites"
																			if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "GET":
																					s.handleChecksListSuitesForRefRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, w, r)
																				default:
																					s.notAllowed(w, r, "GET")
																				}

																				return
																			}
																		}
																	case 'o': // Prefix: "omments"
																		if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleReposListCommentsForCommitRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			case "POST":
																				s.handleReposCreateCommitCommentRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "GET,POST")
																			}

																			return
																		}
																	}
																case 'p': // Prefix: "pulls"
																	if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleReposListPullRequestsAssociatedWithCommitRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}
																case 's': // Prefix: "status"
																	if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch r.Method {
																		case "GET":
																			s.handleReposGetCombinedStatusForRefRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}
																	switch elem[0] {
																	case 'e': // Prefix: "es"
																		if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleReposListCommitStatusesForRefRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}
																	}
																}
															}
														}
													case 'u': // Prefix: "unity/profile"
														if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCommunityProfileMetricsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												case 'p': // Prefix: "pare/"
													if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "basehead"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposCompareCommitsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 'n': // Prefix: "nt"
												if l := len("nt"); len(elem) >= l && elem[0:l] == "nt" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "ent"
													if l := len("ent"); len(elem) >= l && elem[0:l] == "ent" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '_': // Prefix: "_references/"
														if l := len("_references/"); len(elem) >= l && elem[0:l] == "_references/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "content_reference_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/attachments"
															if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleAppsCreateContentAttachmentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}
														}
													case 's': // Prefix: "s/"
														if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "path"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleReposDeleteFileRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handleReposCreateOrUpdateFileContentsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												case 'r': // Prefix: "ributors"
													if l := len("ributors"); len(elem) >= l && elem[0:l] == "ributors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposListContributorsRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											}
										}
									case 'd': // Prefix: "d"
										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "eployments"
											if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposListDeploymentsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleReposCreateDeploymentRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "deployment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleReposDeleteDeploymentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleReposGetDeploymentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/statuses"
													if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListDeploymentStatusesRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "POST":
															s.handleReposCreateDeploymentStatusRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "status_id"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetDeploymentStatusRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											}
										case 'i': // Prefix: "ispatches"
											if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleReposCreateDispatchEventRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										}
									case 'e': // Prefix: "e"
										if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'n': // Prefix: "nvironments/"
											if l := len("nvironments/"); len(elem) >= l && elem[0:l] == "nvironments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "environment_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteAnEnvironmentRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}
										case 'v': // Prefix: "vents"
											if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleActivityListRepoEventsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										}
									case 'f': // Prefix: "forks"
										if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleReposListForksRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "POST":
												s.handleReposCreateForkRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
									case 'g': // Prefix: "g"
										if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "enerate"
											if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleReposCreateUsingTemplateRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										case 'i': // Prefix: "it/"
											if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "blobs"
												if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleGitCreateBlobRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "file_sha"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetBlobRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 'c': // Prefix: "commits"
												if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleGitCreateCommitRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "commit_sha"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetCommitRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 'm': // Prefix: "matching-refs/"
												if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGitListMatchingRefsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'r': // Prefix: "ref"
												if l := len("ref"); len(elem) >= l && elem[0:l] == "ref" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ref"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetRefRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												case 's': // Prefix: "s"
													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateRefRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleGitDeleteRefRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PATCH":
																s.handleGitUpdateRefRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PATCH")
															}

															return
														}
													}
												}
											case 't': // Prefix: "t"
												if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "ags"
													if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateTagRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tag_sha"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGitGetTagRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												case 'r': // Prefix: "rees"
													if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateTreeRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tree_sha"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGitGetTreeRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											}
										}
									case 'h': // Prefix: "hooks"
										if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListWebhooksRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "POST":
												s.handleReposCreateWebhookRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "hook_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "GET":
													s.handleReposGetWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "PATCH":
													s.handleReposUpdateWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"
													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetWebhookConfigForRepoRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PATCH":
															s.handleReposUpdateWebhookConfigForRepoRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,PATCH")
														}

														return
													}
												case 'd': // Prefix: "deliveries"
													if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListWebhookDeliveriesRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "delivery_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposGetWebhookDeliveryRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/attempts"
															if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleReposRedeliverWebhookDeliveryRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}
														}
													}
												case 'p': // Prefix: "pings"
													if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposPingWebhookRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												case 't': // Prefix: "tests"
													if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposTestPushWebhookRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
										}
									case 'i': // Prefix: "i"
										if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'm': // Prefix: "mport"
											if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleMigrationsCancelImportRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleMigrationsGetImportStatusRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PATCH":
													s.handleMigrationsUpdateImportRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PUT":
													s.handleMigrationsStartImportRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "authors"
													if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleMigrationsGetCommitAuthorsRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "author_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleMigrationsMapCommitAuthorRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}
													}
												case 'l': // Prefix: "l"
													if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "arge_files"
														if l := len("arge_files"); len(elem) >= l && elem[0:l] == "arge_files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleMigrationsGetLargeFilesRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'f': // Prefix: "fs"
														if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleMigrationsSetLfsPreferenceRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}
													}
												}
											}
										case 'n': // Prefix: "n"
											if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "teraction-limits"
												if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleInteractionsRemoveRestrictionsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleInteractionsSetRestrictionsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}
											case 'v': // Prefix: "vitations"
												if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListInvitationsRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "invitation_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteInvitationRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PATCH":
															s.handleReposUpdateInvitationRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,PATCH")
														}

														return
													}
												}
											}
										case 's': // Prefix: "ssues"
											if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleIssuesCreateRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleIssuesListCommentsForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handleIssuesDeleteCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "GET":
																s.handleIssuesGetCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PATCH":
																s.handleIssuesUpdateCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET,PATCH")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReactionsListForIssueCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "POST":
																	s.handleReactionsCreateForIssueCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleReactionsDeleteForIssueCommentRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}
															}
														}
													}
												case 'e': // Prefix: "events"
													if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleIssuesListEventsForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "event_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleIssuesGetEventRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
												// Param: "issue_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleIssuesGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handleIssuesUpdateRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assignees"
														if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleIssuesRemoveAssigneesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "POST":
																s.handleIssuesAddAssigneesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,POST")
															}

															return
														}
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleIssuesListCommentsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "POST":
																s.handleIssuesCreateCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}
													case 'l': // Prefix: "l"
														if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "abels"
															if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "DELETE":
																	s.handleIssuesRemoveAllLabelsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "GET":
																	s.handleIssuesListLabelsOnIssueRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "name"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleIssuesRemoveLabelRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}
															}
														case 'o': // Prefix: "ock"
															if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleIssuesUnlockRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "PUT":
																	s.handleIssuesLockRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,PUT")
																}

																return
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReactionsListForIssueRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "POST":
																s.handleReactionsCreateForIssueRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleReactionsDeleteForIssueRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE")
																}

																return
															}
														}
													}
												}
											}
										}
									case 'k': // Prefix: "keys"
										if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListDeployKeysRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "POST":
												s.handleReposCreateDeployKeyRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "key_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteDeployKeyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "GET":
													s.handleReposGetDeployKeyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
										}
									case 'l': // Prefix: "l"
										if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bels"
												if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleIssuesListLabelsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "POST":
														s.handleIssuesCreateLabelRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "name"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleIssuesDeleteLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleIssuesGetLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PATCH":
															s.handleIssuesUpdateLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PATCH")
														}

														return
													}
												}
											case 'n': // Prefix: "nguages"
												if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposListLanguagesRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										case 'f': // Prefix: "fs"
											if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDisableLfsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PUT":
													s.handleReposEnableLfsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,PUT")
												}

												return
											}
										case 'i': // Prefix: "icense"
											if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleLicensesGetForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										}
									case 'm': // Prefix: "m"
										if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "erge"
											if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-upstream"
												if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposMergeUpstreamRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposMergeRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
										case 'i': // Prefix: "ilestones"
											if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListMilestonesRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleIssuesCreateMilestoneRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "milestone_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleIssuesDeleteMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleIssuesGetMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handleIssuesUpdateMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/labels"
													if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleIssuesListLabelsForMilestoneRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											}
										}
									case 'n': // Prefix: "notifications"
										if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListRepoNotificationsForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PUT":
												s.handleActivityMarkRepoNotificationsAsReadRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET,PUT")
											}

											return
										}
									case 'p': // Prefix: "p"
										if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ages"
											if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleReposDeletePagesSiteRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "GET":
													s.handleReposGetPagesRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleReposCreatePagesSiteRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'b': // Prefix: "builds"
													if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListPagesBuildsRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														case "POST":
															s.handleReposRequestPagesBuildRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET,POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'l': // Prefix: "latest"
															if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleReposGetLatestPagesBuildRequest([2]string{
																		args[0],
																		args[1],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
														}
														// Param: "build_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetPagesBuildRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												case 'h': // Prefix: "health"
													if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetPagesHealthCheckRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											}
										case 'r': // Prefix: "rojects"
											if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleProjectsListForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleProjectsCreateForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
										case 'u': // Prefix: "ulls"
											if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handlePullsListRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handlePullsCreateRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handlePullsListReviewCommentsForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handlePullsDeleteReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "GET":
																s.handlePullsGetReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PATCH":
																s.handlePullsUpdateReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET,PATCH")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReactionsListForPullRequestReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "POST":
																	s.handleReactionsCreateForPullRequestReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleReactionsDeleteForPullRequestCommentRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}
															}
														}
													}
												}
												// Param: "pull_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handlePullsGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handlePullsUpdateRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comm"
														if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "ents"
															if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handlePullsListReviewCommentsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "POST":
																	s.handlePullsCreateReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/replies"
																	if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handlePullsCreateReplyForReviewCommentRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}
																}
															}
														case 'i': // Prefix: "its"
															if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handlePullsListCommitsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
														}
													case 'f': // Prefix: "files"
														if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handlePullsListFilesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'm': // Prefix: "merge"
														if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handlePullsCheckIfMergedRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															case "PUT":
																s.handlePullsMergeRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET,PUT")
															}

															return
														}
													case 'r': // Prefix: "re"
														if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'q': // Prefix: "quested_reviewers"
															if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handlePullsRemoveRequestedReviewersRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "GET":
																	s.handlePullsListRequestedReviewersRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}
														case 'v': // Prefix: "views"
															if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handlePullsListReviewsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																case "POST":
																	s.handlePullsCreateReviewRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "review_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch r.Method {
																	case "DELETE":
																		s.handlePullsDeletePendingReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	case "GET":
																		s.handlePullsGetReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	case "PUT":
																		s.handlePullsUpdateReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET,PUT")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'c': // Prefix: "comments"
																		if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handlePullsListCommentsForReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}
																	case 'd': // Prefix: "dismissals"
																		if l := len("dismissals"); len(elem) >= l && elem[0:l] == "dismissals" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "PUT":
																				s.handlePullsDismissReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "PUT")
																			}

																			return
																		}
																	case 'e': // Prefix: "events"
																		if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "POST":
																				s.handlePullsSubmitReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, w, r)
																			default:
																				s.notAllowed(w, r, "POST")
																			}

																			return
																		}
																	}
																}
															}
														}
													case 'u': // Prefix: "update-branch"
														if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PUT":
																s.handlePullsUpdateBranchRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "PUT")
															}

															return
														}
													}
												}
											}
										}
									case 'r': // Prefix: "re"
										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "adme"
											if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposGetReadmeRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "dir"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposGetReadmeInDirectoryRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										case 'l': // Prefix: "leases"
											if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposListReleasesRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "POST":
													s.handleReposCreateReleaseRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "assets/"
													if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "asset_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "GET":
															s.handleReposGetReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														case "PATCH":
															s.handleReposUpdateReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PATCH")
														}

														return
													}
												case 'l': // Prefix: "latest"
													if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetLatestReleaseRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												case 't': // Prefix: "tags/"
													if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tag"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetReleaseByTagRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
												// Param: "release_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleReposDeleteReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handleReposGetReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handleReposUpdateReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assets"
														if l := len("assets"); len(elem) >= l && elem[0:l] == "assets" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposListReleaseAssetsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleReactionsCreateForReleaseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "ecret-scanning/alerts"
											if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleSecretScanningListAlertsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "alert_number"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleSecretScanningGetAlertRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "PATCH":
														s.handleSecretScanningUpdateAlertRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
											}
										case 't': // Prefix: "tat"
											if l := len("tat"); len(elem) >= l && elem[0:l] == "tat" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 's': // Prefix: "s/"
												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "co"
													if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "de_frequency"
														if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCodeFrequencyStatsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'm': // Prefix: "mmit_activity"
														if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCommitActivityStatsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'n': // Prefix: "ntributors"
														if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetContributorsStatsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												case 'p': // Prefix: "p"
													if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "articipation"
														if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetParticipationStatsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'u': // Prefix: "unch_card"
														if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetPunchCardStatsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												}
											case 'u': // Prefix: "uses/"
												if l := len("uses/"); len(elem) >= l && elem[0:l] == "uses/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sha"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposCreateCommitStatusRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
										case 'u': // Prefix: "ubscri"
											if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bers"
												if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActivityListWatchersForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'p': // Prefix: "ption"
												if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleActivityDeleteRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "GET":
														s.handleActivityGetRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													case "PUT":
														s.handleActivitySetRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}
											}
										}
									case 't': // Prefix: "t"
										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'g': // Prefix: "gs"
												if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposListTagsRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'r': // Prefix: "rball/"
												if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposDownloadTarballArchiveRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
										case 'e': // Prefix: "eams"
											if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReposListTeamsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										case 'o': // Prefix: "opics"
											if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReposGetAllTopicsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												case "PUT":
													s.handleReposReplaceAllTopicsRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
										case 'r': // Prefix: "ra"
											if l := len("ra"); len(elem) >= l && elem[0:l] == "ra" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "ffic/"
												if l := len("ffic/"); len(elem) >= l && elem[0:l] == "ffic/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "clones"
													if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetClonesRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												case 'p': // Prefix: "popular/"
													if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "paths"
														if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetTopPathsRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													case 'r': // Prefix: "referrers"
														if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetTopReferrersRequest([2]string{
																	args[0],
																	args[1],
																}, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
													}
												case 'v': // Prefix: "views"
													if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetViewsRequest([2]string{
																args[0],
																args[1],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
												}
											case 'n': // Prefix: "nsfer"
												if l := len("nsfer"); len(elem) >= l && elem[0:l] == "nsfer" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposTransferRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
										}
									case 'v': // Prefix: "vulnerability-alerts"
										if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleReposDisableVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "GET":
												s.handleReposCheckVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PUT":
												s.handleReposEnableVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
									case 'z': // Prefix: "zipball/"
										if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleReposDownloadZipballArchiveRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								}
							}
						case 'i': // Prefix: "itories"
							if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleReposListPublicRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/environments/"
									if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/secrets"
										if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsListEnvironmentSecretsRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsGetEnvironmentPublicKeyRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											}
											// Param: "secret_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleActionsDeleteEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "GET":
													s.handleActionsGetEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "PUT":
													s.handleActionsCreateOrUpdateEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PUT")
												}

												return
											}
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/"
					if l := len("cim/v2/"); len(elem) >= l && elem[0:l] == "cim/v2/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "enterprises/"
						if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "enterprise"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups"
								if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_group_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PATCH":
											s.handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
										}

										return
									}
								}
							case 'U': // Prefix: "Users"
								if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest([1]string{
											args[0],
										}, w, r)
									case "POST":
										s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_user_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PATCH":
											s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
										}

										return
									}
								}
							}
						}
					case 'o': // Prefix: "organizations/"
						if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/Users/"
							if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleScimDeleteUserFromOrgRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
						}
					}
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"
						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "de"
							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleSearchCodeRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'm': // Prefix: "mmits"
							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleSearchCommitsRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case 'i': // Prefix: "issues"
						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchIssuesAndPullRequestsRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'l': // Prefix: "labels"
						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchLabelsRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchReposRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 't': // Prefix: "topics"
						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchTopicsRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'u': // Prefix: "users"
						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchUsersRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch r.Method {
					case "DELETE":
						s.handleTeamsDeleteLegacyRequest([1]string{
							args[0],
						}, w, r)
					case "GET":
						s.handleTeamsGetLegacyRequest([1]string{
							args[0],
						}, w, r)
					case "PATCH":
						s.handleTeamsUpdateLegacyRequest([1]string{
							args[0],
						}, w, r)
					default:
						s.notAllowed(w, r, "DELETE,GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"
						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListDiscussionsLegacyRequest([1]string{
									args[0],
								}, w, r)
							case "POST":
								s.handleTeamsCreateDiscussionLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleTeamsDeleteDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "GET":
									s.handleTeamsGetDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "PATCH":
									s.handleTeamsUpdateDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"
									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleTeamsListDiscussionCommentsLegacyRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "POST":
											s.handleTeamsCreateDiscussionCommentLegacyRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleTeamsDeleteDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											case "GET":
												s.handleTeamsGetDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											case "PATCH":
												s.handleTeamsUpdateDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PATCH")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReactionsListForTeamDiscussionCommentLegacyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "POST":
													s.handleReactionsCreateForTeamDiscussionCommentLegacyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
										}
									}
								case 'r': // Prefix: "reactions"
									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleReactionsListForTeamDiscussionLegacyRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "POST":
											s.handleReactionsCreateForTeamDiscussionLegacyRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTeamsListPendingInvitationsLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListMembersLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "GET":
									s.handleTeamsGetMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "PUT":
									s.handleTeamsAddMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "GET":
									s.handleTeamsGetMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "PUT":
									s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						}
					case 'p': // Prefix: "projects"
						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListProjectsLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveProjectLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "GET":
									s.handleTeamsCheckPermissionsForProjectLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								case "PUT":
									s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListReposLegacyRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleTeamsRemoveRepoLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)
									case "GET":
										s.handleTeamsCheckPermissionsForRepoLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)
									case "PUT":
										s.handleTeamsAddOrUpdateRepoPermissionsLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
							}
						}
					case 't': // Prefix: "team"
						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"
							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTeamsListIdpGroupsForLegacyRequest([1]string{
										args[0],
									}, w, r)
								case "PATCH":
									s.handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET,PATCH")
								}

								return
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTeamsListChildLegacyRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleUsersGetAuthenticatedRequest([0]string{}, w, r)
					case "PATCH":
						s.handleUsersUpdateAuthenticatedRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"
						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListBlockedByAuthenticatedRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersUnblockRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleUsersCheckBlockedRequest([1]string{
										args[0],
									}, w, r)
								case "PUT":
									s.handleUsersBlockRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						}
					case 'e': // Prefix: "email"
						if l := len("email"); len(elem) >= l && elem[0:l] == "email" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/visibility"
							if l := len("/visibility"); len(elem) >= l && elem[0:l] == "/visibility" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "PATCH":
									s.handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "PATCH")
								}

								return
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeleteEmailForAuthenticatedRequest([0]string{}, w, r)
								case "GET":
									s.handleUsersListEmailsForAuthenticatedRequest([0]string{}, w, r)
								case "POST":
									s.handleUsersAddEmailForAuthenticatedRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,POST")
								}

								return
							}
						}
					case 'f': // Prefix: "follow"
						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"
							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleUsersListFollowersForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'i': // Prefix: "ing"
							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleUsersListFollowedByAuthenticatedRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleUsersUnfollowRequest([1]string{
											args[0],
										}, w, r)
									case "GET":
										s.handleUsersCheckPersonIsFollowedByAuthenticatedRequest([1]string{
											args[0],
										}, w, r)
									case "PUT":
										s.handleUsersFollowRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
							}
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListGpgKeysForAuthenticatedRequest([0]string{}, w, r)
							case "POST":
								s.handleUsersCreateGpgKeyForAuthenticatedRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeleteGpgKeyForAuthenticatedRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleUsersGetGpgKeyForAuthenticatedRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
						}
					case 'i': // Prefix: "i"
						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'n': // Prefix: "n"
							if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "stallations/"
								if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "installation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories"
									if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleAppsListInstallationReposForAuthenticatedUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleAppsRemoveRepoFromInstallationRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											case "PUT":
												s.handleAppsAddRepoToInstallationRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,PUT")
											}

											return
										}
									}
								}
							case 't': // Prefix: "teraction-limits"
								if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)
									case "PUT":
										s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PUT")
									}

									return
								}
							}
						case 's': // Prefix: "ssues"
							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleIssuesListForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListPublicSSHKeysForAuthenticatedRequest([0]string{}, w, r)
							case "POST":
								s.handleUsersCreatePublicSSHKeyForAuthenticatedRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeletePublicSSHKeyForAuthenticatedRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleUsersGetPublicSSHKeyForAuthenticatedRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"
							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleAppsListSubscriptionsForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"
								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest([0]string{}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case 'e': // Prefix: "emberships/orgs"
							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListMembershipsForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsGetMembershipForAuthenticatedUserRequest([1]string{
											args[0],
										}, w, r)
									case "PATCH":
										s.handleOrgsUpdateMembershipForAuthenticatedUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}
							}
						case 'i': // Prefix: "igrations"
							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleMigrationsListForAuthenticatedUserRequest([0]string{}, w, r)
								case "POST":
									s.handleMigrationsStartForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleMigrationsGetStatusForAuthenticatedUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"
										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleMigrationsDeleteArchiveForAuthenticatedUserRequest([1]string{
													args[0],
												}, w, r)
											case "GET":
												s.handleMigrationsGetArchiveForAuthenticatedUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET")
											}

											return
										}
									case 'r': // Prefix: "repos"
										if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repo_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/lock"
												if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleMigrationsUnlockRepoForAuthenticatedUserRequest([2]string{
															args[0],
															args[1],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE")
													}

													return
												}
											}
										case 'i': // Prefix: "itories"
											if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleMigrationsListReposForUserRequest([1]string{
														args[0],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										}
									}
								}
							}
						}
					case 'o': // Prefix: "orgs"
						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleOrgsListForAuthenticatedUserRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"
							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handlePackagesListPackagesForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handlePackagesDeletePackageForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handlePackagesGetPackageForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "restore"
											if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePackagesRestorePackageForAuthenticatedUserRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										case 'v': // Prefix: "versions"
											if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest([2]string{
														args[0],
														args[1],
													}, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handlePackagesDeletePackageVersionForAuthenticatedUserRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													case "GET":
														s.handlePackagesGetPackageVersionForAuthenticatedUserRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/restore"
													if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsCreateForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						case 'u': // Prefix: "ublic_emails"
							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleUsersListPublicEmailsForAuthenticatedRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleReposListForAuthenticatedUserRequest([0]string{}, w, r)
							case "POST":
								s.handleReposCreateForAuthenticatedUserRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"
							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleReposListInvitationsForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleReposDeclineInvitationRequest([1]string{
											args[0],
										}, w, r)
									case "PATCH":
										s.handleReposAcceptInvitationRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PATCH")
									}

									return
								}
							}
						}
					case 's': // Prefix: "s"
						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"
							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleActivityListReposStarredByAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleActivityUnstarRepoForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "GET":
											s.handleActivityCheckRepoIsStarredByAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										case "PUT":
											s.handleActivityStarRepoForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}
								}
							}
						case 'u': // Prefix: "ubscriptions"
							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleActivityListWatchedReposForAuthenticatedUserRequest([0]string{}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTeamsListForAuthenticatedUserRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				case 's': // Prefix: "s"
					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleUsersListRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersGetByUsernameRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "events"
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleActivityListEventsForAuthenticatedUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"
										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListOrgEventsForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									case 'p': // Prefix: "public"
										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListPublicEventsForUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								}
							case 'f': // Prefix: "follow"
								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"
									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleUsersListFollowersForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 'i': // Prefix: "ing"
									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleUsersListFollowingForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleUsersCheckFollowingForUserRequest([2]string{
													args[0],
													args[1],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								}
							case 'g': // Prefix: "g"
								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"
									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGistsListForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 'p': // Prefix: "pg_keys"
									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleUsersListGpgKeysForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 'h': // Prefix: "hovercard"
								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleUsersGetContextForUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'k': // Prefix: "keys"
								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleUsersListPublicKeysForUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'o': // Prefix: "orgs"
								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsListForUserRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'p': // Prefix: "p"
								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"
									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handlePackagesListPackagesForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handlePackagesDeletePackageForUserRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												case "GET":
													s.handlePackagesGetPackageForUserRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"
													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handlePackagesRestorePackageForUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												case 'v': // Prefix: "versions"
													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handlePackagesDeletePackageVersionForUserRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															case "GET":
																s.handlePackagesGetPackageVersionForUserRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"
															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handlePackagesRestorePackageVersionForUserRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "rojects"
									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleProjectsListForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"
									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleActivityListReceivedEventsForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/public"
										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListReceivedPublicEventsForUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								case 'p': // Prefix: "pos"
									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleReposListForUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"
									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"
										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubActionsBillingUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									case 'p': // Prefix: "packages"
										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubPackagesBillingUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									case 's': // Prefix: "shared-storage"
										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetSharedStorageBillingUserRequest([1]string{
													args[0],
												}, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								case 'u': // Prefix: "ubscriptions"
									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleActivityListReposWatchedByUserRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							}
						}
					}
				}
			case 'z': // Prefix: "zen"
				if l := len("zen"); len(elem) >= l && elem[0:l] == "zen" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleMetaGetZenRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name  string
	count int
	args  [5]string
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.name
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
func (s *Server) FindRoute(method, path string) (r Route, _ bool) {
	var (
		args = [5]string{}
		elem = path
	)
	r.args = args
	if elem == "" {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				switch method {
				case "GET":
					r.name = "MetaRoot"
					r.args = args
					r.count = 0
					return r, true
				default:
					return
				}
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "AppsGetAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '-': // Prefix: "-manifests/"
						if l := len("-manifests/"); len(elem) >= l && elem[0:l] == "-manifests/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "code"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/conversions"
							if l := len("/conversions"); len(elem) >= l && elem[0:l] == "/conversions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: AppsCreateFromManifest
									r.name = "AppsCreateFromManifest"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/"
							if l := len("hook/"); len(elem) >= l && elem[0:l] == "hook/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "config"
								if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: AppsGetWebhookConfigForApp
										r.name = "AppsGetWebhookConfigForApp"
										r.args = args
										r.count = 0
										return r, true
									case "PATCH":
										// Leaf: AppsUpdateWebhookConfigForApp
										r.name = "AppsUpdateWebhookConfigForApp"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							case 'd': // Prefix: "deliveries"
								if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "AppsListWebhookDeliveries"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "AppsGetWebhookDelivery"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"
										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: AppsRedeliverWebhookDelivery
												r.name = "AppsRedeliverWebhookDelivery"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "installations/"
							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "AppsDeleteInstallation"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "access_tokens"
									if l := len("access_tokens"); len(elem) >= l && elem[0:l] == "access_tokens" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: AppsCreateInstallationAccessToken
											r.name = "AppsCreateInstallationAccessToken"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 's': // Prefix: "suspended"
									if l := len("suspended"); len(elem) >= l && elem[0:l] == "suspended" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: AppsUnsuspendInstallation
											r.name = "AppsUnsuspendInstallation"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											// Leaf: AppsSuspendInstallation
											r.name = "AppsSuspendInstallation"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants"
							if l := len("grants"); len(elem) >= l && elem[0:l] == "grants" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OAuthAuthorizationsListGrants"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "grant_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: OAuthAuthorizationsDeleteGrant
										r.name = "OAuthAuthorizationsDeleteGrant"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										// Leaf: OAuthAuthorizationsGetGrant
										r.name = "OAuthAuthorizationsGetGrant"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"
								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: AppsDeleteAuthorization
										r.name = "AppsDeleteAuthorization"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 't': // Prefix: "token"
								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "AppsDeleteToken"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = "AppsResetToken"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "AppsCheckToken"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/scoped"
									if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: AppsScopeToken
											r.name = "AppsScopeToken"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					case 's': // Prefix: "s/"
						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: AppsGetBySlug
								r.name = "AppsGetBySlug"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "OAuthAuthorizationsListAuthorizations"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "OAuthAuthorizationsCreateAuthorization"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "clients/"
							if l := len("clients/"); len(elem) >= l && elem[0:l] == "clients/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "client_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "PUT":
									r.name = "OAuthAuthorizationsGetOrCreateAuthorizationForApp"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "fingerprint"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint
										r.name = "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						}
						// Param: "authorization_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: OAuthAuthorizationsDeleteAuthorization
								r.name = "OAuthAuthorizationsDeleteAuthorization"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: OAuthAuthorizationsGetAuthorization
								r.name = "OAuthAuthorizationsGetAuthorization"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								// Leaf: OAuthAuthorizationsUpdateAuthorization
								r.name = "OAuthAuthorizationsUpdateAuthorization"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'c': // Prefix: "codes_of_conduct"
				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "CodesOfConductGetAllCodesOfConduct"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: CodesOfConductGetConductCode
							r.name = "CodesOfConductGetConductCode"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"
					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: EmojisGet
							r.name = "EmojisGet"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				case 'n': // Prefix: "nterprises/"
					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "EnterpriseAdminGetGithubActionsPermissionsEnterprise"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = "EnterpriseAdminSetGithubActionsPermissionsEnterprise"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"
											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													r.name = "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "org_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
														r.name = "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
														r.name = "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: EnterpriseAdminGetAllowedActionsEnterprise
													r.name = "EnterpriseAdminGetAllowedActionsEnterprise"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													// Leaf: EnterpriseAdminSetAllowedActionsEnterprise
													r.name = "EnterpriseAdminSetAllowedActionsEnterprise"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"
													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "org_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
																r.name = "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
																r.name = "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'r': // Prefix: "runners"
													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
																r.name = "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
																r.name = "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "EnterpriseAdminListSelfHostedRunnersForEnterprise"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: EnterpriseAdminListRunnerApplicationsForEnterprise
														r.name = "EnterpriseAdminListRunnerApplicationsForEnterprise"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"
													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: EnterpriseAdminCreateRegistrationTokenForEnterprise
															r.name = "EnterpriseAdminCreateRegistrationTokenForEnterprise"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}
												case 'm': // Prefix: "move-token"
													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: EnterpriseAdminCreateRemoveTokenForEnterprise
															r.name = "EnterpriseAdminCreateRemoveTokenForEnterprise"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
													r.name = "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: EnterpriseAdminGetSelfHostedRunnerForEnterprise
													r.name = "EnterpriseAdminGetSelfHostedRunnerForEnterprise"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: EnterpriseAdminGetAuditLog
										r.name = "EnterpriseAdminGetAuditLog"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 's': // Prefix: "settings/billing/"
							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"
								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: BillingGetGithubActionsBillingGhe
										r.name = "BillingGetGithubActionsBillingGhe"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'p': // Prefix: "packages"
								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: BillingGetGithubPackagesBillingGhe
										r.name = "BillingGetGithubPackagesBillingGhe"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 's': // Prefix: "shared-storage"
								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: BillingGetSharedStorageBillingGhe
										r.name = "BillingGetSharedStorageBillingGhe"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'v': // Prefix: "vents"
					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: ActivityListPublicEvents
							r.name = "ActivityListPublicEvents"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				}
			case 'f': // Prefix: "feeds"
				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: ActivityGetFeeds
						r.name = "ActivityGetFeeds"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
			case 'g': // Prefix: "gi"
				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "sts"
					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GistsList"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "GistsCreate"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GistsListPublic
									r.name = "GistsListPublic"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 's': // Prefix: "starred"
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GistsListStarred
									r.name = "GistsListStarred"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "GistsDelete"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GistsGet"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"
									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "GistsListComments"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = "GistsCreateComment"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: GistsDeleteComment
												r.name = "GistsDeleteComment"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												// Leaf: GistsGetComment
												r.name = "GistsGetComment"
												r.args = args
												r.count = 2
												return r, true
											case "PATCH":
												// Leaf: GistsUpdateComment
												r.name = "GistsUpdateComment"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								case 'i': // Prefix: "its"
									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GistsListCommits
											r.name = "GistsListCommits"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'f': // Prefix: "forks"
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GistsListForks
										r.name = "GistsListForks"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: GistsFork
										r.name = "GistsFork"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 's': // Prefix: "star"
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: GistsUnstar
										r.name = "GistsUnstar"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										// Leaf: GistsCheckIsStarred
										r.name = "GistsCheckIsStarred"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										// Leaf: GistsStar
										r.name = "GistsStar"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
							// Param: "sha"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GistsGetRevision
									r.name = "GistsGetRevision"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					}
				case 't': // Prefix: "tignore/templates"
					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GitignoreGetAllTemplates"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GitignoreGetTemplate
								r.name = "GitignoreGetTemplate"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/"
					if l := len("nstallation/"); len(elem) >= l && elem[0:l] == "nstallation/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: AppsListReposAccessibleToInstallation
								r.name = "AppsListReposAccessibleToInstallation"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 't': // Prefix: "token"
						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: AppsRevokeInstallationAccessToken
								r.name = "AppsRevokeInstallationAccessToken"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					}
				case 's': // Prefix: "ssues"
					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: IssuesList
							r.name = "IssuesList"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				}
			case 'l': // Prefix: "licenses"
				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "LicensesGetAllCommonlyUsed"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: LicensesGet
							r.name = "LicensesGet"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			case 'm': // Prefix: "m"
				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "arketplace_listing/"
					if l := len("arketplace_listing/"); len(elem) >= l && elem[0:l] == "arketplace_listing/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "accounts/"
						if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "account_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: AppsGetSubscriptionPlanForAccount
								r.name = "AppsGetSubscriptionPlanForAccount"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					case 'p': // Prefix: "plans"
						if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "AppsListPlans"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "plan_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/accounts"
								if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: AppsListAccountsForPlan
										r.name = "AppsListAccountsForPlan"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case 's': // Prefix: "stubbed/"
						if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"
							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: AppsGetSubscriptionPlanForAccountStubbed
									r.name = "AppsGetSubscriptionPlanForAccountStubbed"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'p': // Prefix: "plans"
							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "AppsListPlansStubbed"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"
									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: AppsListAccountsForPlanStubbed
											r.name = "AppsListAccountsForPlanStubbed"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eta"
					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: MetaGet
							r.name = "MetaGet"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				}
			case 'n': // Prefix: "n"
				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"
					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"
							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ActivityListPublicEventsForRepoNetwork
									r.name = "ActivityListPublicEventsForRepoNetwork"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'o': // Prefix: "otifications"
					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ActivityListNotificationsForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						case "PUT":
							r.name = "ActivityMarkNotificationsAsRead"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"
						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ActivityGetThread"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "ActivityMarkThreadAsRead"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"
							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: ActivityDeleteThreadSubscription
									r.name = "ActivityDeleteThreadSubscription"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: ActivityGetThreadSubscriptionForAuthenticatedUser
									r.name = "ActivityGetThreadSubscriptionForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									// Leaf: ActivitySetThreadSubscription
									r.name = "ActivitySetThreadSubscription"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'o': // Prefix: "org"
				if l := len("org"); len(elem) >= l && elem[0:l] == "org" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "anizations"
					if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: OrgsList
							r.name = "OrgsList"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "OrgsGet"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "ActionsGetGithubActionsPermissionsOrganization"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = "ActionsSetGithubActionsPermissionsOrganization"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													r.name = "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: ActionsDisableSelectedRepositoryGithubActionsOrganization
														r.name = "ActionsDisableSelectedRepositoryGithubActionsOrganization"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: ActionsEnableSelectedRepositoryGithubActionsOrganization
														r.name = "ActionsEnableSelectedRepositoryGithubActionsOrganization"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ActionsGetAllowedActionsOrganization
													r.name = "ActionsGetAllowedActionsOrganization"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													// Leaf: ActionsSetAllowedActionsOrganization
													r.name = "ActionsSetAllowedActionsOrganization"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ActionsListSelfHostedRunnerGroupsForOrg"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = "ActionsCreateSelfHostedRunnerGroupForOrg"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "ActionsDeleteSelfHostedRunnerGroupFromOrg"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = "ActionsGetSelfHostedRunnerGroupForOrg"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = "ActionsUpdateSelfHostedRunnerGroupForOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/r"
												if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "epositories"
													if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "repository_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
																r.name = "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
																r.name = "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'u': // Prefix: "unners"
													if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ActionsListSelfHostedRunnersInGroupForOrg"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = "ActionsSetSelfHostedRunnersInGroupForOrg"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: ActionsRemoveSelfHostedRunnerFromGroupForOrg
																r.name = "ActionsRemoveSelfHostedRunnerFromGroupForOrg"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: ActionsAddSelfHostedRunnerToGroupForOrg
																r.name = "ActionsAddSelfHostedRunnerToGroupForOrg"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ActionsListSelfHostedRunnersForOrg"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ActionsListRunnerApplicationsForOrg
														r.name = "ActionsListRunnerApplicationsForOrg"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"
													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: ActionsCreateRegistrationTokenForOrg
															r.name = "ActionsCreateRegistrationTokenForOrg"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}
												case 'm': // Prefix: "move-token"
													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: ActionsCreateRemoveTokenForOrg
															r.name = "ActionsCreateRemoveTokenForOrg"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: ActionsDeleteSelfHostedRunnerFromOrg
													r.name = "ActionsDeleteSelfHostedRunnerFromOrg"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: ActionsGetSelfHostedRunnerForOrg
													r.name = "ActionsGetSelfHostedRunnerForOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								case 's': // Prefix: "secrets"
									if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "ActionsListOrgSecrets"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ActionsGetOrgPublicKey
													r.name = "ActionsGetOrgPublicKey"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										}
										// Param: "secret_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "ActionsDeleteOrgSecret"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = "ActionsGetOrgSecret"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = "ActionsCreateOrUpdateOrgSecret"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/repositories"
											if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ActionsListSelectedReposForOrgSecret"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = "ActionsSetSelectedReposForOrgSecret"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: ActionsRemoveSelectedRepoFromOrgSecret
														r.name = "ActionsRemoveSelectedRepoFromOrgSecret"
														r.args = args
														r.count = 3
														return r, true
													case "PUT":
														// Leaf: ActionsAddSelectedRepoToOrgSecret
														r.name = "ActionsAddSelectedRepoToOrgSecret"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: OrgsGetAuditLog
										r.name = "OrgsGetAuditLog"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 'b': // Prefix: "blocks"
							if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OrgsListBlockedUsers"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: OrgsUnblockUser
										r.name = "OrgsUnblockUser"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										// Leaf: OrgsCheckBlockedUser
										r.name = "OrgsCheckBlockedUser"
										r.args = args
										r.count = 2
										return r, true
									case "PUT":
										// Leaf: OrgsBlockUser
										r.name = "OrgsBlockUser"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						case 'c': // Prefix: "credential-authorizations"
							if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OrgsListSamlSSOAuthorizations"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "credential_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: OrgsRemoveSamlSSOAuthorization
										r.name = "OrgsRemoveSamlSSOAuthorization"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						case 'e': // Prefix: "events"
							if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ActivityListPublicOrgEvents
									r.name = "ActivityListPublicOrgEvents"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'f': // Prefix: "failed_invitations"
							if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: OrgsListFailedInvitations
									r.name = "OrgsListFailedInvitations"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OrgsListWebhooks"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "OrgsCreateWebhook"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "OrgsDeleteWebhook"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										r.name = "OrgsGetWebhook"
										r.args = args
										r.count = 2
										return r, true
									case "PATCH":
										r.name = "OrgsUpdateWebhook"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: OrgsGetWebhookConfigForOrg
												r.name = "OrgsGetWebhookConfigForOrg"
												r.args = args
												r.count = 2
												return r, true
											case "PATCH":
												// Leaf: OrgsUpdateWebhookConfigForOrg
												r.name = "OrgsUpdateWebhookConfigForOrg"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 'd': // Prefix: "deliveries"
										if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "OrgsListWebhookDeliveries"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "delivery_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "OrgsGetWebhookDelivery"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/attempts"
												if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: OrgsRedeliverWebhookDelivery
														r.name = "OrgsRedeliverWebhookDelivery"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										}
									case 'p': // Prefix: "pings"
										if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: OrgsPingWebhook
												r.name = "OrgsPingWebhook"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'n': // Prefix: "n"
								if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 't': // Prefix: "teraction-limits"
									if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: InteractionsRemoveRestrictionsForOrg
											r.name = "InteractionsRemoveRestrictionsForOrg"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											// Leaf: InteractionsSetRestrictionsForOrg
											r.name = "InteractionsSetRestrictionsForOrg"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'v': // Prefix: "vitations"
									if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "OrgsListPendingInvitations"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = "OrgsCreateInvitation"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "invitation_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "OrgsCancelInvitation"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/teams"
											if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: OrgsListInvitationTeams
													r.name = "OrgsListInvitationTeams"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								}
							case 's': // Prefix: "ssues"
								if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: IssuesListForOrg
										r.name = "IssuesListForOrg"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "embers"
								if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "OrgsListMembers"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: OrgsRemoveMember
											r.name = "OrgsRemoveMember"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: OrgsCheckMembershipForUser
											r.name = "OrgsCheckMembershipForUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								case 'h': // Prefix: "hips/"
									if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: OrgsRemoveMembershipForUser
											r.name = "OrgsRemoveMembershipForUser"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: OrgsGetMembershipForUser
											r.name = "OrgsGetMembershipForUser"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: OrgsSetMembershipForUser
											r.name = "OrgsSetMembershipForUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 'i': // Prefix: "igrations"
								if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "MigrationsListForOrg"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "MigrationsStartForOrg"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "migration_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "MigrationsGetStatusForOrg"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: MigrationsDeleteArchiveForOrg
													r.name = "MigrationsDeleteArchiveForOrg"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: MigrationsDownloadArchiveForOrg
													r.name = "MigrationsDownloadArchiveForOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repo_name"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/lock"
													if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: MigrationsUnlockRepoForOrg
															r.name = "MigrationsUnlockRepoForOrg"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'i': // Prefix: "itories"
												if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: MigrationsListReposForOrg
														r.name = "MigrationsListReposForOrg"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									}
								}
							}
						case 'o': // Prefix: "outside_collaborators"
							if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OrgsListOutsideCollaborators"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: OrgsRemoveOutsideCollaborator
										r.name = "OrgsRemoveOutsideCollaborator"
										r.args = args
										r.count = 2
										return r, true
									case "PUT":
										// Leaf: OrgsConvertMemberToOutsideCollaborator
										r.name = "OrgsConvertMemberToOutsideCollaborator"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages"
								if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "PackagesListPackagesForOrganization"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "PackagesDeletePackageForOrg"
												r.args = args
												r.count = 3
												return r, true
											case "GET":
												r.name = "PackagesGetPackageForOrganization"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "restore"
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: PackagesRestorePackageForOrg
														r.name = "PackagesRestorePackageForOrg"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											case 'v': // Prefix: "versions"
												if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "PackagesGetAllPackageVersionsForPackageOwnedByOrg"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[3] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = "PackagesDeletePackageVersionForOrg"
															r.args = args
															r.count = 4
															return r, true
														case "GET":
															r.name = "PackagesGetPackageVersionForOrganization"
															r.args = args
															r.count = 4
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/restore"
														if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "POST":
																// Leaf: PackagesRestorePackageVersionForOrg
																r.name = "PackagesRestorePackageVersionForOrg"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ProjectsListForOrg
										r.name = "ProjectsListForOrg"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: ProjectsCreateForOrg
										r.name = "ProjectsCreateForOrg"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'u': // Prefix: "ublic_members"
								if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "OrgsListPublicMembers"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: OrgsRemovePublicMembershipForAuthenticatedUser
											r.name = "OrgsRemovePublicMembershipForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: OrgsCheckPublicMembershipForUser
											r.name = "OrgsCheckPublicMembershipForUser"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: OrgsSetPublicMembershipForAuthenticatedUser
											r.name = "OrgsSetPublicMembershipForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReposListForOrg
									r.name = "ReposListForOrg"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									// Leaf: ReposCreateInOrg
									r.name = "ReposCreateInOrg"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 's': // Prefix: "se"
							if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "cret-scanning/alerts"
								if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: SecretScanningListAlertsForOrg
										r.name = "SecretScanningListAlertsForOrg"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 't': // Prefix: "ttings/billing/"
								if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"
									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: BillingGetGithubActionsBillingOrg
											r.name = "BillingGetGithubActionsBillingOrg"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'p': // Prefix: "packages"
									if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: BillingGetGithubPackagesBillingOrg
											r.name = "BillingGetGithubPackagesBillingOrg"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 's': // Prefix: "shared-storage"
									if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: BillingGetSharedStorageBillingOrg
											r.name = "BillingGetSharedStorageBillingOrg"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						case 't': // Prefix: "team"
							if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-sync/groups"
								if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: TeamsListIdpGroupsForOrg
										r.name = "TeamsListIdpGroupsForOrg"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "TeamsList"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "TeamsCreate"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "team_slug"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = "TeamsDeleteInOrg"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = "TeamsGetByName"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											r.name = "TeamsUpdateInOrg"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'd': // Prefix: "discussions"
											if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "TeamsListDiscussionsInOrg"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "TeamsCreateDiscussionInOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "discussion_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = "TeamsDeleteDiscussionInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = "TeamsGetDiscussionInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = "TeamsUpdateDiscussionInOrg"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "TeamsListDiscussionCommentsInOrg"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = "TeamsCreateDiscussionCommentInOrg"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	r.name = "TeamsDeleteDiscussionCommentInOrg"
																	r.args = args
																	r.count = 4
																	return r, true
																case "GET":
																	r.name = "TeamsGetDiscussionCommentInOrg"
																	r.args = args
																	r.count = 4
																	return r, true
																case "PATCH":
																	r.name = "TeamsUpdateDiscussionCommentInOrg"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		r.name = "ReactionsListForTeamDiscussionCommentInOrg"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "POST":
																		r.name = "ReactionsCreateForTeamDiscussionCommentInOrg"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter
																	args[4] = elem
																	elem = ""

																	if len(elem) == 0 {
																		switch method {
																		case "DELETE":
																			// Leaf: ReactionsDeleteForTeamDiscussionComment
																			r.name = "ReactionsDeleteForTeamDiscussionComment"
																			r.args = args
																			r.count = 5
																			return r, true
																		default:
																			return
																		}
																	}
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "ReactionsListForTeamDiscussionInOrg"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = "ReactionsCreateForTeamDiscussionInOrg"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: ReactionsDeleteForTeamDiscussion
																	r.name = "ReactionsDeleteForTeamDiscussion"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}
														}
													}
												}
											}
										case 'i': // Prefix: "invitations"
											if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: TeamsListPendingInvitationsInOrg
													r.name = "TeamsListPendingInvitationsInOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'm': // Prefix: "members"
											if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "TeamsListMembersInOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case 'h': // Prefix: "hips/"
												if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: TeamsRemoveMembershipForUserInOrg
														r.name = "TeamsRemoveMembershipForUserInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														// Leaf: TeamsGetMembershipForUserInOrg
														r.name = "TeamsGetMembershipForUserInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "PUT":
														// Leaf: TeamsAddOrUpdateMembershipForUserInOrg
														r.name = "TeamsAddOrUpdateMembershipForUserInOrg"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'p': // Prefix: "projects"
											if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "TeamsListProjectsInOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "project_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: TeamsRemoveProjectInOrg
														r.name = "TeamsRemoveProjectInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														// Leaf: TeamsCheckPermissionsForProjectInOrg
														r.name = "TeamsCheckPermissionsForProjectInOrg"
														r.args = args
														r.count = 3
														return r, true
													case "PUT":
														// Leaf: TeamsAddOrUpdateProjectPermissionsInOrg
														r.name = "TeamsAddOrUpdateProjectPermissionsInOrg"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "TeamsListReposInOrg"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "owner"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: TeamsRemoveRepoInOrg
															r.name = "TeamsRemoveRepoInOrg"
															r.args = args
															r.count = 4
															return r, true
														case "GET":
															// Leaf: TeamsCheckPermissionsForRepoInOrg
															r.name = "TeamsCheckPermissionsForRepoInOrg"
															r.args = args
															r.count = 4
															return r, true
														case "PUT":
															// Leaf: TeamsAddOrUpdateRepoPermissionsInOrg
															r.name = "TeamsAddOrUpdateRepoPermissionsInOrg"
															r.args = args
															r.count = 4
															return r, true
														default:
															return
														}
													}
												}
											}
										case 't': // Prefix: "team"
											if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-sync/group-mappings"
												if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: TeamsListIdpGroupsInOrg
														r.name = "TeamsListIdpGroupsInOrg"
														r.args = args
														r.count = 2
														return r, true
													case "PATCH":
														// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsInOrg
														r.name = "TeamsCreateOrUpdateIdpGroupConnectionsInOrg"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: TeamsListChildInOrg
														r.name = "TeamsListChildInOrg"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "ProjectsDeleteCard"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ProjectsGetCard"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "ProjectsUpdateCard"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"
							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: ProjectsMoveCard
									r.name = "ProjectsMoveCard"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "ProjectsDeleteColumn"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "ProjectsGetColumn"
							r.args = args
							r.count = 1
							return r, true
						case "PATCH":
							r.name = "ProjectsUpdateColumn"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "cards"
							if l := len("cards"); len(elem) >= l && elem[0:l] == "cards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ProjectsListCards
									r.name = "ProjectsListCards"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'm': // Prefix: "moves"
							if l := len("moves"); len(elem) >= l && elem[0:l] == "moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: ProjectsMoveColumn
									r.name = "ProjectsMoveColumn"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch method {
					case "DELETE":
						r.name = "ProjectsDelete"
						r.args = args
						r.count = 1
						return r, true
					case "GET":
						r.name = "ProjectsGet"
						r.args = args
						r.count = 1
						return r, true
					case "PATCH":
						r.name = "ProjectsUpdate"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/col"
					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"
						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ProjectsListCollaborators"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "ProjectsRemoveCollaborator"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = "ProjectsAddCollaborator"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"
								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ProjectsGetPermissionForUser
										r.name = "ProjectsGetPermissionForUser"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						}
					case 'u': // Prefix: "umns"
						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: ProjectsListColumns
								r.name = "ProjectsListColumns"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								// Leaf: ProjectsCreateColumn
								r.name = "ProjectsCreateColumn"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'r': // Prefix: "r"
				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"
					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: RateLimitGet
							r.name = "RateLimitGet"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				case 'e': // Prefix: "e"
					if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "reaction_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: ReactionsDeleteLegacy
								r.name = "ReactionsDeleteLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					case 'p': // Prefix: "pos"
						if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "ReposDelete"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										r.name = "ReposGet"
										r.args = args
										r.count = 2
										return r, true
									case "PATCH":
										r.name = "ReposUpdate"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "ctions/"
											if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "artifacts"
												if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ActionsListArtifactsForRepo"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "artifact_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = "ActionsDeleteArtifact"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = "ActionsGetArtifact"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "archive_format"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ActionsDownloadArtifact
																r.name = "ActionsDownloadArtifact"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
													}
												}
											case 'j': // Prefix: "jobs/"
												if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "job_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ActionsGetJobForWorkflowRun"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"
													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ActionsDownloadJobLogsForWorkflowRun
															r.name = "ActionsDownloadJobLogsForWorkflowRun"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'p': // Prefix: "permissions"
												if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ActionsGetGithubActionsPermissionsRepository"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = "ActionsSetGithubActionsPermissionsRepository"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/selected-actions"
													if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ActionsGetAllowedActionsRepository
															r.name = "ActionsGetAllowedActionsRepository"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															// Leaf: ActionsSetAllowedActionsRepository
															r.name = "ActionsSetAllowedActionsRepository"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												}
											case 'r': // Prefix: "run"
												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'n': // Prefix: "ners"
													if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ActionsListSelfHostedRunnersForRepo"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'd': // Prefix: "downloads"
															if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	// Leaf: ActionsListRunnerApplicationsForRepo
																	r.name = "ActionsListRunnerApplicationsForRepo"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}
														case 'r': // Prefix: "re"
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'g': // Prefix: "gistration-token"
																if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "POST":
																		// Leaf: ActionsCreateRegistrationTokenForRepo
																		r.name = "ActionsCreateRegistrationTokenForRepo"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}
															case 'm': // Prefix: "move-token"
																if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "POST":
																		// Leaf: ActionsCreateRemoveTokenForRepo
																		r.name = "ActionsCreateRemoveTokenForRepo"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}
															}
														}
														// Param: "runner_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: ActionsDeleteSelfHostedRunnerFromRepo
																r.name = "ActionsDeleteSelfHostedRunnerFromRepo"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																// Leaf: ActionsGetSelfHostedRunnerForRepo
																r.name = "ActionsGetSelfHostedRunnerForRepo"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 's': // Prefix: "s"
													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ActionsListWorkflowRunsForRepo"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "run_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = "ActionsDeleteWorkflowRun"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = "ActionsGetWorkflowRun"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'a': // Prefix: "a"
																if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pprov"
																	if l := len("pprov"); len(elem) >= l && elem[0:l] == "pprov" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "als"
																		if l := len("als"); len(elem) >= l && elem[0:l] == "als" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "GET":
																				// Leaf: ActionsGetReviewsForRun
																				r.name = "ActionsGetReviewsForRun"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	case 'e': // Prefix: "e"
																		if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "POST":
																				// Leaf: ActionsApproveWorkflowRun
																				r.name = "ActionsApproveWorkflowRun"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	}
																case 'r': // Prefix: "rtifacts"
																	if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			// Leaf: ActionsListWorkflowRunArtifacts
																			r.name = "ActionsListWorkflowRunArtifacts"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																}
															case 'c': // Prefix: "cancel"
																if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "POST":
																		// Leaf: ActionsCancelWorkflowRun
																		r.name = "ActionsCancelWorkflowRun"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															case 'j': // Prefix: "jobs"
																if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		// Leaf: ActionsListJobsForWorkflowRun
																		r.name = "ActionsListJobsForWorkflowRun"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															case 'l': // Prefix: "logs"
																if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		// Leaf: ActionsDeleteWorkflowRunLogs
																		r.name = "ActionsDeleteWorkflowRunLogs"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "GET":
																		// Leaf: ActionsDownloadWorkflowRunLogs
																		r.name = "ActionsDownloadWorkflowRunLogs"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															case 'p': // Prefix: "pending_deployments"
																if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "POST":
																		// Leaf: ActionsReviewPendingDeploymentsForRun
																		r.name = "ActionsReviewPendingDeploymentsForRun"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															case 'r': // Prefix: "re"
																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'r': // Prefix: "run"
																	if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "POST":
																			// Leaf: ActionsReRunWorkflow
																			r.name = "ActionsReRunWorkflow"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																case 't': // Prefix: "try"
																	if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "POST":
																			// Leaf: ActionsRetryWorkflow
																			r.name = "ActionsRetryWorkflow"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																}
															case 't': // Prefix: "timing"
																if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		// Leaf: ActionsGetWorkflowRunUsage
																		r.name = "ActionsGetWorkflowRunUsage"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															}
														}
													}
												}
											case 's': // Prefix: "secrets"
												if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ActionsListRepoSecrets"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "public-key"
														if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ActionsGetRepoPublicKey
																r.name = "ActionsGetRepoPublicKey"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
													// Param: "secret_name"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: ActionsDeleteRepoSecret
															r.name = "ActionsDeleteRepoSecret"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															// Leaf: ActionsGetRepoSecret
															r.name = "ActionsGetRepoSecret"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															// Leaf: ActionsCreateOrUpdateRepoSecret
															r.name = "ActionsCreateOrUpdateRepoSecret"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'w': // Prefix: "workflows"
												if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ActionsListRepoWorkflows
														r.name = "ActionsListRepoWorkflows"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 's': // Prefix: "ssignees"
											if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "IssuesListAssignees"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "assignee"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: IssuesCheckUserCanBeAssigned
														r.name = "IssuesCheckUserCanBeAssigned"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'u': // Prefix: "uto"
											if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "links"
												if l := len("links"); len(elem) >= l && elem[0:l] == "links" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ReposListAutolinks"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = "ReposCreateAutolink"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: ReposDeleteAutolink
															r.name = "ReposDeleteAutolink"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															// Leaf: ReposGetAutolink
															r.name = "ReposGetAutolink"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'm': // Prefix: "mated-security-fixes"
												if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: ReposDisableAutomatedSecurityFixes
														r.name = "ReposDisableAutomatedSecurityFixes"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: ReposEnableAutomatedSecurityFixes
														r.name = "ReposEnableAutomatedSecurityFixes"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									case 'b': // Prefix: "branches"
										if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ReposListBranches"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "branch"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ReposGetBranch"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'p': // Prefix: "protection"
													if l := len("protection"); len(elem) >= l && elem[0:l] == "protection" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = "ReposDeleteBranchProtection"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = "ReposGetBranchProtection"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = "ReposUpdateBranchProtection"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "enforce_admins"
															if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: ReposDeleteAdminBranchProtection
																	r.name = "ReposDeleteAdminBranchProtection"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	// Leaf: ReposGetAdminBranchProtection
																	r.name = "ReposGetAdminBranchProtection"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	// Leaf: ReposSetAdminBranchProtection
																	r.name = "ReposSetAdminBranchProtection"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														case 'r': // Prefix: "re"
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'q': // Prefix: "quired_"
																if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pull_request_reviews"
																	if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "DELETE":
																			// Leaf: ReposDeletePullRequestReviewProtection
																			r.name = "ReposDeletePullRequestReviewProtection"
																			r.args = args
																			r.count = 3
																			return r, true
																		case "GET":
																			// Leaf: ReposGetPullRequestReviewProtection
																			r.name = "ReposGetPullRequestReviewProtection"
																			r.args = args
																			r.count = 3
																			return r, true
																		case "PATCH":
																			// Leaf: ReposUpdatePullRequestReviewProtection
																			r.name = "ReposUpdatePullRequestReviewProtection"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																case 's': // Prefix: "s"
																	if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'i': // Prefix: "ignatures"
																		if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				// Leaf: ReposDeleteCommitSignatureProtection
																				r.name = "ReposDeleteCommitSignatureProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				// Leaf: ReposGetCommitSignatureProtection
																				r.name = "ReposGetCommitSignatureProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				// Leaf: ReposCreateCommitSignatureProtection
																				r.name = "ReposCreateCommitSignatureProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	case 't': // Prefix: "tatus_checks"
																		if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				r.name = "ReposRemoveStatusCheckProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = "ReposGetStatusChecksProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PATCH":
																				r.name = "ReposUpdateStatusCheckProtection"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																		switch elem[0] {
																		case '/': // Prefix: "/contexts"
																			if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				switch method {
																				case "DELETE":
																					// Leaf: ReposRemoveStatusCheckContexts
																					r.name = "ReposRemoveStatusCheckContexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "GET":
																					// Leaf: ReposGetAllStatusCheckContexts
																					r.name = "ReposGetAllStatusCheckContexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "POST":
																					// Leaf: ReposAddStatusCheckContexts
																					r.name = "ReposAddStatusCheckContexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "PUT":
																					// Leaf: ReposSetStatusCheckContexts
																					r.name = "ReposSetStatusCheckContexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}
																		}
																	}
																}
															case 's': // Prefix: "strictions"
																if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		r.name = "ReposDeleteAccessRestrictions"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "GET":
																		r.name = "ReposGetAccessRestrictions"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "apps"
																		if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				// Leaf: ReposRemoveAppAccessRestrictions
																				r.name = "ReposRemoveAppAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				// Leaf: ReposGetAppsWithAccessToProtectedBranch
																				r.name = "ReposGetAppsWithAccessToProtectedBranch"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				// Leaf: ReposAddAppAccessRestrictions
																				r.name = "ReposAddAppAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				// Leaf: ReposSetAppAccessRestrictions
																				r.name = "ReposSetAppAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	case 't': // Prefix: "teams"
																		if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				// Leaf: ReposRemoveTeamAccessRestrictions
																				r.name = "ReposRemoveTeamAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				// Leaf: ReposGetTeamsWithAccessToProtectedBranch
																				r.name = "ReposGetTeamsWithAccessToProtectedBranch"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				// Leaf: ReposAddTeamAccessRestrictions
																				r.name = "ReposAddTeamAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				// Leaf: ReposSetTeamAccessRestrictions
																				r.name = "ReposSetTeamAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	case 'u': // Prefix: "users"
																		if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				// Leaf: ReposRemoveUserAccessRestrictions
																				r.name = "ReposRemoveUserAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				// Leaf: ReposGetUsersWithAccessToProtectedBranch
																				r.name = "ReposGetUsersWithAccessToProtectedBranch"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				// Leaf: ReposAddUserAccessRestrictions
																				r.name = "ReposAddUserAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				// Leaf: ReposSetUserAccessRestrictions
																				r.name = "ReposSetUserAccessRestrictions"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	}
																}
															}
														}
													}
												case 'r': // Prefix: "rename"
													if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: ReposRenameBranch
															r.name = "ReposRenameBranch"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									case 'c': // Prefix: "c"
										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "heck-"
											if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "runs/"
												if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "check_run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ChecksGet"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/annotations"
													if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ChecksListAnnotations
															r.name = "ChecksListAnnotations"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 's': // Prefix: "suites"
												if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = "ChecksCreateSuite"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "preferences"
														if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "PATCH":
																// Leaf: ChecksSetSuitesPreferences
																r.name = "ChecksSetSuitesPreferences"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
													// Param: "check_suite_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ChecksGetSuite"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "check-runs"
															if l := len("check-runs"); len(elem) >= l && elem[0:l] == "check-runs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	// Leaf: ChecksListForSuite
																	r.name = "ChecksListForSuite"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														case 'r': // Prefix: "rerequest"
															if l := len("rerequest"); len(elem) >= l && elem[0:l] == "rerequest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "POST":
																	// Leaf: ChecksRerequestSuite
																	r.name = "ChecksRerequestSuite"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														}
													}
												}
											}
										case 'o': // Prefix: "o"
											if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "de-scanning/"
												if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "a"
													if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'l': // Prefix: "lerts"
														if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "CodeScanningListAlertsForRepo"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "alert_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "CodeScanningGetAlert"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PATCH":
																	r.name = "CodeScanningUpdateAlert"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/instances"
																if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		// Leaf: CodeScanningListAlertInstances
																		r.name = "CodeScanningListAlertInstances"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
															}
														}
													case 'n': // Prefix: "nalyses"
														if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "CodeScanningListRecentAnalyses"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "analysis_id"
															// Leaf parameter
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: CodeScanningDeleteAnalysis
																	r.name = "CodeScanningDeleteAnalysis"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	// Leaf: CodeScanningGetAnalysis
																	r.name = "CodeScanningGetAnalysis"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														}
													}
												case 's': // Prefix: "sarifs"
													if l := len("sarifs"); len(elem) >= l && elem[0:l] == "sarifs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = "CodeScanningUploadSarif"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "sarif_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: CodeScanningGetSarif
																r.name = "CodeScanningGetSarif"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											case 'l': // Prefix: "llaborators"
												if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ReposListCollaborators"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = "ReposRemoveCollaborator"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = "ReposCheckCollaborator"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = "ReposAddCollaborator"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/permission"
														if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetCollaboratorPermissionLevel
																r.name = "ReposGetCollaboratorPermissionLevel"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											case 'm': // Prefix: "m"
												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'm': // Prefix: "m"
													if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"
														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "ReposListCommitCommentsForRepo"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	r.name = "ReposDeleteCommitComment"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = "ReposGetCommitComment"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PATCH":
																	r.name = "ReposUpdateCommitComment"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		r.name = "ReactionsListForCommitComment"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "POST":
																		r.name = "ReactionsCreateForCommitComment"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter
																	args[3] = elem
																	elem = ""

																	if len(elem) == 0 {
																		switch method {
																		case "DELETE":
																			// Leaf: ReactionsDeleteForCommitComment
																			r.name = "ReactionsDeleteForCommitComment"
																			r.args = args
																			r.count = 4
																			return r, true
																		default:
																			return
																		}
																	}
																}
															}
														}
													case 'i': // Prefix: "its"
														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "ReposListCommits"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "ref"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "ReposGetCommit"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'b': // Prefix: "branches-where-head"
																	if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			// Leaf: ReposListBranchesForHeadCommit
																			r.name = "ReposListBranchesForHeadCommit"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																case 'c': // Prefix: "c"
																	if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'h': // Prefix: "heck-"
																		if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			break
																		}
																		switch elem[0] {
																		case 'r': // Prefix: "runs"
																			if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				switch method {
																				case "GET":
																					// Leaf: ChecksListForRef
																					r.name = "ChecksListForRef"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}
																		case 's': // Prefix: "suites"
																			if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				switch method {
																				case "GET":
																					// Leaf: ChecksListSuitesForRef
																					r.name = "ChecksListSuitesForRef"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}
																		}
																	case 'o': // Prefix: "omments"
																		if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "GET":
																				// Leaf: ReposListCommentsForCommit
																				r.name = "ReposListCommentsForCommit"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				// Leaf: ReposCreateCommitComment
																				r.name = "ReposCreateCommitComment"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	}
																case 'p': // Prefix: "pulls"
																	if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			// Leaf: ReposListPullRequestsAssociatedWithCommit
																			r.name = "ReposListPullRequestsAssociatedWithCommit"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																case 's': // Prefix: "status"
																	if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			r.name = "ReposGetCombinedStatusForRef"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																	switch elem[0] {
																	case 'e': // Prefix: "es"
																		if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "GET":
																				// Leaf: ReposListCommitStatusesForRef
																				r.name = "ReposListCommitStatusesForRef"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																	}
																}
															}
														}
													case 'u': // Prefix: "unity/profile"
														if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetCommunityProfileMetrics
																r.name = "ReposGetCommunityProfileMetrics"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
												case 'p': // Prefix: "pare/"
													if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "basehead"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposCompareCommits
															r.name = "ReposCompareCommits"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'n': // Prefix: "nt"
												if l := len("nt"); len(elem) >= l && elem[0:l] == "nt" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "ent"
													if l := len("ent"); len(elem) >= l && elem[0:l] == "ent" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '_': // Prefix: "_references/"
														if l := len("_references/"); len(elem) >= l && elem[0:l] == "_references/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "content_reference_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/attachments"
															if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "POST":
																	// Leaf: AppsCreateContentAttachment
																	r.name = "AppsCreateContentAttachment"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														}
													case 's': // Prefix: "s/"
														if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "path"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: ReposDeleteFile
																r.name = "ReposDeleteFile"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: ReposCreateOrUpdateFileContents
																r.name = "ReposCreateOrUpdateFileContents"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'r': // Prefix: "ributors"
													if l := len("ributors"); len(elem) >= l && elem[0:l] == "ributors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposListContributors
															r.name = "ReposListContributors"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									case 'd': // Prefix: "d"
										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "eployments"
											if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ReposListDeployments"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "ReposCreateDeployment"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "deployment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = "ReposDeleteDeployment"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = "ReposGetDeployment"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/statuses"
													if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ReposListDeploymentStatuses"
															r.args = args
															r.count = 3
															return r, true
														case "POST":
															r.name = "ReposCreateDeploymentStatus"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "status_id"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetDeploymentStatus
																r.name = "ReposGetDeploymentStatus"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										case 'i': // Prefix: "ispatches"
											if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: ReposCreateDispatchEvent
													r.name = "ReposCreateDispatchEvent"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									case 'e': // Prefix: "e"
										if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'n': // Prefix: "nvironments/"
											if l := len("nvironments/"); len(elem) >= l && elem[0:l] == "nvironments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "environment_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: ReposDeleteAnEnvironment
													r.name = "ReposDeleteAnEnvironment"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
										case 'v': // Prefix: "vents"
											if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ActivityListRepoEvents
													r.name = "ActivityListRepoEvents"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									case 'f': // Prefix: "forks"
										if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ReposListForks
												r.name = "ReposListForks"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												// Leaf: ReposCreateFork
												r.name = "ReposCreateFork"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 'g': // Prefix: "g"
										if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "enerate"
											if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: ReposCreateUsingTemplate
													r.name = "ReposCreateUsingTemplate"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'i': // Prefix: "it/"
											if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "blobs"
												if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = "GitCreateBlob"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "file_sha"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: GitGetBlob
															r.name = "GitGetBlob"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'c': // Prefix: "commits"
												if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = "GitCreateCommit"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "commit_sha"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: GitGetCommit
															r.name = "GitGetCommit"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'm': // Prefix: "matching-refs/"
												if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: GitListMatchingRefs
														r.name = "GitListMatchingRefs"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "ref"
												if l := len("ref"); len(elem) >= l && elem[0:l] == "ref" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ref"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: GitGetRef
															r.name = "GitGetRef"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												case 's': // Prefix: "s"
													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = "GitCreateRef"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: GitDeleteRef
																r.name = "GitDeleteRef"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																// Leaf: GitUpdateRef
																r.name = "GitUpdateRef"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											case 't': // Prefix: "t"
												if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "ags"
													if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = "GitCreateTag"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tag_sha"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: GitGetTag
																r.name = "GitGetTag"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'r': // Prefix: "rees"
													if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = "GitCreateTree"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tree_sha"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: GitGetTree
																r.name = "GitGetTree"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									case 'h': // Prefix: "hooks"
										if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ReposListWebhooks"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												r.name = "ReposCreateWebhook"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "hook_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "ReposDeleteWebhook"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = "ReposGetWebhook"
													r.args = args
													r.count = 3
													return r, true
												case "PATCH":
													r.name = "ReposUpdateWebhook"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"
													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetWebhookConfigForRepo
															r.name = "ReposGetWebhookConfigForRepo"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															// Leaf: ReposUpdateWebhookConfigForRepo
															r.name = "ReposUpdateWebhookConfigForRepo"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												case 'd': // Prefix: "deliveries"
													if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ReposListWebhookDeliveries"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "delivery_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "ReposGetWebhookDelivery"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/attempts"
															if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "POST":
																	// Leaf: ReposRedeliverWebhookDelivery
																	r.name = "ReposRedeliverWebhookDelivery"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}
														}
													}
												case 'p': // Prefix: "pings"
													if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: ReposPingWebhook
															r.name = "ReposPingWebhook"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												case 't': // Prefix: "tests"
													if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: ReposTestPushWebhook
															r.name = "ReposTestPushWebhook"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									case 'i': // Prefix: "i"
										if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'm': // Prefix: "mport"
											if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "MigrationsCancelImport"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = "MigrationsGetImportStatus"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = "MigrationsUpdateImport"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = "MigrationsStartImport"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "authors"
													if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "MigrationsGetCommitAuthors"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "author_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "PATCH":
																// Leaf: MigrationsMapCommitAuthor
																r.name = "MigrationsMapCommitAuthor"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'l': // Prefix: "l"
													if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "arge_files"
														if l := len("arge_files"); len(elem) >= l && elem[0:l] == "arge_files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: MigrationsGetLargeFiles
																r.name = "MigrationsGetLargeFiles"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													case 'f': // Prefix: "fs"
														if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "PATCH":
																// Leaf: MigrationsSetLfsPreference
																r.name = "MigrationsSetLfsPreference"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										case 'n': // Prefix: "n"
											if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "teraction-limits"
												if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: InteractionsRemoveRestrictionsForRepo
														r.name = "InteractionsRemoveRestrictionsForRepo"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: InteractionsSetRestrictionsForRepo
														r.name = "InteractionsSetRestrictionsForRepo"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'v': // Prefix: "vitations"
												if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "ReposListInvitations"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "invitation_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: ReposDeleteInvitation
															r.name = "ReposDeleteInvitation"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															// Leaf: ReposUpdateInvitation
															r.name = "ReposUpdateInvitation"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										case 's': // Prefix: "ssues"
											if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "IssuesListForRepo"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "IssuesCreate"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "IssuesListCommentsForRepo"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = "IssuesDeleteComment"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = "IssuesGetComment"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																r.name = "IssuesUpdateComment"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "ReactionsListForIssueComment"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = "ReactionsCreateForIssueComment"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		// Leaf: ReactionsDeleteForIssueComment
																		r.name = "ReactionsDeleteForIssueComment"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
															}
														}
													}
												case 'e': // Prefix: "events"
													if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "IssuesListEventsForRepo"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "event_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: IssuesGetEvent
																r.name = "IssuesGetEvent"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
												// Param: "issue_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "IssuesGet"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = "IssuesUpdate"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assignees"
														if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: IssuesRemoveAssignees
																r.name = "IssuesRemoveAssignees"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																// Leaf: IssuesAddAssignees
																r.name = "IssuesAddAssignees"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: IssuesListComments
																r.name = "IssuesListComments"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																// Leaf: IssuesCreateComment
																r.name = "IssuesCreateComment"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													case 'l': // Prefix: "l"
														if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "abels"
															if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	r.name = "IssuesRemoveAllLabels"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = "IssuesListLabelsOnIssue"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "name"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		// Leaf: IssuesRemoveLabel
																		r.name = "IssuesRemoveLabel"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
															}
														case 'o': // Prefix: "ock"
															if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: IssuesUnlock
																	r.name = "IssuesUnlock"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PUT":
																	// Leaf: IssuesLock
																	r.name = "IssuesLock"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = "ReactionsListForIssue"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = "ReactionsCreateForIssue"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: ReactionsDeleteForIssue
																	r.name = "ReactionsDeleteForIssue"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}
														}
													}
												}
											}
										}
									case 'k': // Prefix: "keys"
										if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ReposListDeployKeys"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												r.name = "ReposCreateDeployKey"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "key_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: ReposDeleteDeployKey
													r.name = "ReposDeleteDeployKey"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													// Leaf: ReposGetDeployKey
													r.name = "ReposGetDeployKey"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
										}
									case 'l': // Prefix: "l"
										if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bels"
												if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "IssuesListLabelsForRepo"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = "IssuesCreateLabel"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "name"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: IssuesDeleteLabel
															r.name = "IssuesDeleteLabel"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															// Leaf: IssuesGetLabel
															r.name = "IssuesGetLabel"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															// Leaf: IssuesUpdateLabel
															r.name = "IssuesUpdateLabel"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											case 'n': // Prefix: "nguages"
												if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ReposListLanguages
														r.name = "ReposListLanguages"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 'f': // Prefix: "fs"
											if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: ReposDisableLfsForRepo
													r.name = "ReposDisableLfsForRepo"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													// Leaf: ReposEnableLfsForRepo
													r.name = "ReposEnableLfsForRepo"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'i': // Prefix: "icense"
											if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: LicensesGetForRepo
													r.name = "LicensesGetForRepo"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									case 'm': // Prefix: "m"
										if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "erge"
											if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-upstream"
												if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: ReposMergeUpstream
														r.name = "ReposMergeUpstream"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: ReposMerge
														r.name = "ReposMerge"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 'i': // Prefix: "ilestones"
											if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "IssuesListMilestones"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "IssuesCreateMilestone"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "milestone_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = "IssuesDeleteMilestone"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = "IssuesGetMilestone"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = "IssuesUpdateMilestone"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/labels"
													if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: IssuesListLabelsForMilestone
															r.name = "IssuesListLabelsForMilestone"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									case 'n': // Prefix: "notifications"
										if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ActivityListRepoNotificationsForAuthenticatedUser
												r.name = "ActivityListRepoNotificationsForAuthenticatedUser"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												// Leaf: ActivityMarkRepoNotificationsAsRead
												r.name = "ActivityMarkRepoNotificationsAsRead"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 'p': // Prefix: "p"
										if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ages"
											if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "ReposDeletePagesSite"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = "ReposGetPages"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "ReposCreatePagesSite"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'b': // Prefix: "builds"
													if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "ReposListPagesBuilds"
															r.args = args
															r.count = 2
															return r, true
														case "POST":
															r.name = "ReposRequestPagesBuild"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'l': // Prefix: "latest"
															if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	// Leaf: ReposGetLatestPagesBuild
																	r.name = "ReposGetLatestPagesBuild"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}
														}
														// Param: "build_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetPagesBuild
																r.name = "ReposGetPagesBuild"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'h': // Prefix: "health"
													if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetPagesHealthCheck
															r.name = "ReposGetPagesHealthCheck"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												}
											}
										case 'r': // Prefix: "rojects"
											if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ProjectsListForRepo
													r.name = "ProjectsListForRepo"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													// Leaf: ProjectsCreateForRepo
													r.name = "ProjectsCreateForRepo"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'u': // Prefix: "ulls"
											if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "PullsList"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "PullsCreate"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "PullsListReviewCommentsForRepo"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = "PullsDeleteReviewComment"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = "PullsGetReviewComment"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																r.name = "PullsUpdateReviewComment"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "ReactionsListForPullRequestReviewComment"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = "ReactionsCreateForPullRequestReviewComment"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		// Leaf: ReactionsDeleteForPullRequestComment
																		r.name = "ReactionsDeleteForPullRequestComment"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
															}
														}
													}
												}
												// Param: "pull_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "PullsGet"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = "PullsUpdate"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comm"
														if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "ents"
															if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "PullsListReviewComments"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = "PullsCreateReviewComment"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/replies"
																	if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "POST":
																			// Leaf: PullsCreateReplyForReviewComment
																			r.name = "PullsCreateReplyForReviewComment"
																			r.args = args
																			r.count = 4
																			return r, true
																		default:
																			return
																		}
																	}
																}
															}
														case 'i': // Prefix: "its"
															if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	// Leaf: PullsListCommits
																	r.name = "PullsListCommits"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														}
													case 'f': // Prefix: "files"
														if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: PullsListFiles
																r.name = "PullsListFiles"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													case 'm': // Prefix: "merge"
														if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: PullsCheckIfMerged
																r.name = "PullsCheckIfMerged"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: PullsMerge
																r.name = "PullsMerge"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													case 'r': // Prefix: "re"
														if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'q': // Prefix: "quested_reviewers"
															if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	// Leaf: PullsRemoveRequestedReviewers
																	r.name = "PullsRemoveRequestedReviewers"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	// Leaf: PullsListRequestedReviewers
																	r.name = "PullsListRequestedReviewers"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
														case 'v': // Prefix: "views"
															if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = "PullsListReviews"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = "PullsCreateReview"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "review_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		r.name = "PullsDeletePendingReview"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "GET":
																		r.name = "PullsGetReview"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "PUT":
																		r.name = "PullsUpdateReview"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'c': // Prefix: "comments"
																		if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "GET":
																				// Leaf: PullsListCommentsForReview
																				r.name = "PullsListCommentsForReview"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}
																	case 'd': // Prefix: "dismissals"
																		if l := len("dismissals"); len(elem) >= l && elem[0:l] == "dismissals" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "PUT":
																				// Leaf: PullsDismissReview
																				r.name = "PullsDismissReview"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}
																	case 'e': // Prefix: "events"
																		if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "POST":
																				// Leaf: PullsSubmitReview
																				r.name = "PullsSubmitReview"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}
																	}
																}
															}
														}
													case 'u': // Prefix: "update-branch"
														if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "PUT":
																// Leaf: PullsUpdateBranch
																r.name = "PullsUpdateBranch"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									case 'r': // Prefix: "re"
										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "adme"
											if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ReposGetReadme"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "dir"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ReposGetReadmeInDirectory
														r.name = "ReposGetReadmeInDirectory"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'l': // Prefix: "leases"
											if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ReposListReleases"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "ReposCreateRelease"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "assets/"
													if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "asset_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: ReposDeleteReleaseAsset
															r.name = "ReposDeleteReleaseAsset"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															// Leaf: ReposGetReleaseAsset
															r.name = "ReposGetReleaseAsset"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															// Leaf: ReposUpdateReleaseAsset
															r.name = "ReposUpdateReleaseAsset"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												case 'l': // Prefix: "latest"
													if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetLatestRelease
															r.name = "ReposGetLatestRelease"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												case 't': // Prefix: "tags/"
													if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tag"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetReleaseByTag
															r.name = "ReposGetReleaseByTag"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
												// Param: "release_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = "ReposDeleteRelease"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = "ReposGetRelease"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = "ReposUpdateRelease"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assets"
														if l := len("assets"); len(elem) >= l && elem[0:l] == "assets" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposListReleaseAssets
																r.name = "ReposListReleaseAssets"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "POST":
																// Leaf: ReactionsCreateForRelease
																r.name = "ReactionsCreateForRelease"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "ecret-scanning/alerts"
											if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "SecretScanningListAlertsForRepo"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "alert_number"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: SecretScanningGetAlert
														r.name = "SecretScanningGetAlert"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														// Leaf: SecretScanningUpdateAlert
														r.name = "SecretScanningUpdateAlert"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 't': // Prefix: "tat"
											if l := len("tat"); len(elem) >= l && elem[0:l] == "tat" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 's': // Prefix: "s/"
												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "co"
													if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "de_frequency"
														if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetCodeFrequencyStats
																r.name = "ReposGetCodeFrequencyStats"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													case 'm': // Prefix: "mmit_activity"
														if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetCommitActivityStats
																r.name = "ReposGetCommitActivityStats"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													case 'n': // Prefix: "ntributors"
														if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetContributorsStats
																r.name = "ReposGetContributorsStats"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
												case 'p': // Prefix: "p"
													if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "articipation"
														if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetParticipationStats
																r.name = "ReposGetParticipationStats"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													case 'u': // Prefix: "unch_card"
														if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetPunchCardStats
																r.name = "ReposGetPunchCardStats"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
												}
											case 'u': // Prefix: "uses/"
												if l := len("uses/"); len(elem) >= l && elem[0:l] == "uses/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sha"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: ReposCreateCommitStatus
														r.name = "ReposCreateCommitStatus"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'u': // Prefix: "ubscri"
											if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bers"
												if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ActivityListWatchersForRepo
														r.name = "ActivityListWatchersForRepo"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'p': // Prefix: "ption"
												if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: ActivityDeleteRepoSubscription
														r.name = "ActivityDeleteRepoSubscription"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														// Leaf: ActivityGetRepoSubscription
														r.name = "ActivityGetRepoSubscription"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: ActivitySetRepoSubscription
														r.name = "ActivitySetRepoSubscription"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									case 't': // Prefix: "t"
										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'g': // Prefix: "gs"
												if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ReposListTags
														r.name = "ReposListTags"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "rball/"
												if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ReposDownloadTarballArchive
														r.name = "ReposDownloadTarballArchive"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										case 'e': // Prefix: "eams"
											if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ReposListTeams
													r.name = "ReposListTeams"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'o': // Prefix: "opics"
											if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ReposGetAllTopics
													r.name = "ReposGetAllTopics"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													// Leaf: ReposReplaceAllTopics
													r.name = "ReposReplaceAllTopics"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'r': // Prefix: "ra"
											if l := len("ra"); len(elem) >= l && elem[0:l] == "ra" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "ffic/"
												if l := len("ffic/"); len(elem) >= l && elem[0:l] == "ffic/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "clones"
													if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetClones
															r.name = "ReposGetClones"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												case 'p': // Prefix: "popular/"
													if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "paths"
														if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetTopPaths
																r.name = "ReposGetTopPaths"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													case 'r': // Prefix: "referrers"
														if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																// Leaf: ReposGetTopReferrers
																r.name = "ReposGetTopReferrers"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
													}
												case 'v': // Prefix: "views"
													if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															// Leaf: ReposGetViews
															r.name = "ReposGetViews"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												}
											case 'n': // Prefix: "nsfer"
												if l := len("nsfer"); len(elem) >= l && elem[0:l] == "nsfer" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: ReposTransfer
														r.name = "ReposTransfer"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									case 'v': // Prefix: "vulnerability-alerts"
										if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: ReposDisableVulnerabilityAlerts
												r.name = "ReposDisableVulnerabilityAlerts"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												// Leaf: ReposCheckVulnerabilityAlerts
												r.name = "ReposCheckVulnerabilityAlerts"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												// Leaf: ReposEnableVulnerabilityAlerts
												r.name = "ReposEnableVulnerabilityAlerts"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 'z': // Prefix: "zipball/"
										if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ReposDownloadZipballArchive
												r.name = "ReposDownloadZipballArchive"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "itories"
							if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ReposListPublic"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/environments/"
									if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/secrets"
										if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "ActionsListEnvironmentSecrets"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: ActionsGetEnvironmentPublicKey
														r.name = "ActionsGetEnvironmentPublicKey"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
											// Param: "secret_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: ActionsDeleteEnvironmentSecret
													r.name = "ActionsDeleteEnvironmentSecret"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													// Leaf: ActionsGetEnvironmentSecret
													r.name = "ActionsGetEnvironmentSecret"
													r.args = args
													r.count = 3
													return r, true
												case "PUT":
													// Leaf: ActionsCreateOrUpdateEnvironmentSecret
													r.name = "ActionsCreateOrUpdateEnvironmentSecret"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/"
					if l := len("cim/v2/"); len(elem) >= l && elem[0:l] == "cim/v2/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "enterprises/"
						if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "enterprise"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups"
								if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "EnterpriseAdminListProvisionedGroupsEnterprise"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "EnterpriseAdminProvisionAndInviteEnterpriseGroup"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_group_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: EnterpriseAdminDeleteScimGroupFromEnterprise
											r.name = "EnterpriseAdminDeleteScimGroupFromEnterprise"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseGroup
											r.name = "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseGroup
											r.name = "EnterpriseAdminUpdateAttributeForEnterpriseGroup"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseGroup
											r.name = "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 'U': // Prefix: "Users"
								if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "EnterpriseAdminListProvisionedIdentitiesEnterprise"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "EnterpriseAdminProvisionAndInviteEnterpriseUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_user_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: EnterpriseAdminDeleteUserFromEnterprise
											r.name = "EnterpriseAdminDeleteUserFromEnterprise"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseUser
											r.name = "EnterpriseAdminGetProvisioningInformationForEnterpriseUser"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseUser
											r.name = "EnterpriseAdminUpdateAttributeForEnterpriseUser"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseUser
											r.name = "EnterpriseAdminSetInformationForProvisionedEnterpriseUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					case 'o': // Prefix: "organizations/"
						if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/Users/"
							if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: ScimDeleteUserFromOrg
									r.name = "ScimDeleteUserFromOrg"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"
						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "de"
							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: SearchCode
									r.name = "SearchCode"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 'm': // Prefix: "mmits"
							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: SearchCommits
									r.name = "SearchCommits"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case 'i': // Prefix: "issues"
						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: SearchIssuesAndPullRequests
								r.name = "SearchIssuesAndPullRequests"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'l': // Prefix: "labels"
						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: SearchLabels
								r.name = "SearchLabels"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: SearchRepos
								r.name = "SearchRepos"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 't': // Prefix: "topics"
						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: SearchTopics
								r.name = "SearchTopics"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'u': // Prefix: "users"
						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: SearchUsers
								r.name = "SearchUsers"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch method {
					case "DELETE":
						r.name = "TeamsDeleteLegacy"
						r.args = args
						r.count = 1
						return r, true
					case "GET":
						r.name = "TeamsGetLegacy"
						r.args = args
						r.count = 1
						return r, true
					case "PATCH":
						r.name = "TeamsUpdateLegacy"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"
						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "TeamsListDiscussionsLegacy"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "TeamsCreateDiscussionLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "TeamsDeleteDiscussionLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									r.name = "TeamsGetDiscussionLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "PATCH":
									r.name = "TeamsUpdateDiscussionLegacy"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"
									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "TeamsListDiscussionCommentsLegacy"
											r.args = args
											r.count = 2
											return r, true
										case "POST":
											r.name = "TeamsCreateDiscussionCommentLegacy"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "TeamsDeleteDiscussionCommentLegacy"
												r.args = args
												r.count = 3
												return r, true
											case "GET":
												r.name = "TeamsGetDiscussionCommentLegacy"
												r.args = args
												r.count = 3
												return r, true
											case "PATCH":
												r.name = "TeamsUpdateDiscussionCommentLegacy"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: ReactionsListForTeamDiscussionCommentLegacy
													r.name = "ReactionsListForTeamDiscussionCommentLegacy"
													r.args = args
													r.count = 3
													return r, true
												case "POST":
													// Leaf: ReactionsCreateForTeamDiscussionCommentLegacy
													r.name = "ReactionsCreateForTeamDiscussionCommentLegacy"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'r': // Prefix: "reactions"
									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ReactionsListForTeamDiscussionLegacy
											r.name = "ReactionsListForTeamDiscussionLegacy"
											r.args = args
											r.count = 2
											return r, true
										case "POST":
											// Leaf: ReactionsCreateForTeamDiscussionLegacy
											r.name = "ReactionsCreateForTeamDiscussionLegacy"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: TeamsListPendingInvitationsLegacy
								r.name = "TeamsListPendingInvitationsLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "TeamsListMembersLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: TeamsRemoveMemberLegacy
									r.name = "TeamsRemoveMemberLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									// Leaf: TeamsGetMemberLegacy
									r.name = "TeamsGetMemberLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									// Leaf: TeamsAddMemberLegacy
									r.name = "TeamsAddMemberLegacy"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: TeamsRemoveMembershipForUserLegacy
									r.name = "TeamsRemoveMembershipForUserLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									// Leaf: TeamsGetMembershipForUserLegacy
									r.name = "TeamsGetMembershipForUserLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									// Leaf: TeamsAddOrUpdateMembershipForUserLegacy
									r.name = "TeamsAddOrUpdateMembershipForUserLegacy"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					case 'p': // Prefix: "projects"
						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "TeamsListProjectsLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: TeamsRemoveProjectLegacy
									r.name = "TeamsRemoveProjectLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									// Leaf: TeamsCheckPermissionsForProjectLegacy
									r.name = "TeamsCheckPermissionsForProjectLegacy"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									// Leaf: TeamsAddOrUpdateProjectPermissionsLegacy
									r.name = "TeamsAddOrUpdateProjectPermissionsLegacy"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "TeamsListReposLegacy"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: TeamsRemoveRepoLegacy
										r.name = "TeamsRemoveRepoLegacy"
										r.args = args
										r.count = 3
										return r, true
									case "GET":
										// Leaf: TeamsCheckPermissionsForRepoLegacy
										r.name = "TeamsCheckPermissionsForRepoLegacy"
										r.args = args
										r.count = 3
										return r, true
									case "PUT":
										// Leaf: TeamsAddOrUpdateRepoPermissionsLegacy
										r.name = "TeamsAddOrUpdateRepoPermissionsLegacy"
										r.args = args
										r.count = 3
										return r, true
									default:
										return
									}
								}
							}
						}
					case 't': // Prefix: "team"
						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"
							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: TeamsListIdpGroupsForLegacy
									r.name = "TeamsListIdpGroupsForLegacy"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsLegacy
									r.name = "TeamsCreateOrUpdateIdpGroupConnectionsLegacy"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: TeamsListChildLegacy
									r.name = "TeamsListChildLegacy"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "UsersGetAuthenticated"
						r.args = args
						r.count = 0
						return r, true
					case "PATCH":
						r.name = "UsersUpdateAuthenticated"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"
						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "UsersListBlockedByAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: UsersUnblock
									r.name = "UsersUnblock"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: UsersCheckBlocked
									r.name = "UsersCheckBlocked"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									// Leaf: UsersBlock
									r.name = "UsersBlock"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case 'e': // Prefix: "email"
						if l := len("email"); len(elem) >= l && elem[0:l] == "email" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/visibility"
							if l := len("/visibility"); len(elem) >= l && elem[0:l] == "/visibility" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "PATCH":
									// Leaf: UsersSetPrimaryEmailVisibilityForAuthenticated
									r.name = "UsersSetPrimaryEmailVisibilityForAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: UsersDeleteEmailForAuthenticated
									r.name = "UsersDeleteEmailForAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								case "GET":
									// Leaf: UsersListEmailsForAuthenticated
									r.name = "UsersListEmailsForAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									// Leaf: UsersAddEmailForAuthenticated
									r.name = "UsersAddEmailForAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case 'f': // Prefix: "follow"
						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"
							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: UsersListFollowersForAuthenticatedUser
									r.name = "UsersListFollowersForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 'i': // Prefix: "ing"
							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "UsersListFollowedByAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: UsersUnfollow
										r.name = "UsersUnfollow"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										// Leaf: UsersCheckPersonIsFollowedByAuthenticated
										r.name = "UsersCheckPersonIsFollowedByAuthenticated"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										// Leaf: UsersFollow
										r.name = "UsersFollow"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "UsersListGpgKeysForAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "UsersCreateGpgKeyForAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: UsersDeleteGpgKeyForAuthenticated
									r.name = "UsersDeleteGpgKeyForAuthenticated"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: UsersGetGpgKeyForAuthenticated
									r.name = "UsersGetGpgKeyForAuthenticated"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case 'i': // Prefix: "i"
						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'n': // Prefix: "n"
							if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "stallations/"
								if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "installation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories"
									if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "AppsListInstallationReposForAuthenticatedUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: AppsRemoveRepoFromInstallation
												r.name = "AppsRemoveRepoFromInstallation"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												// Leaf: AppsAddRepoToInstallation
												r.name = "AppsAddRepoToInstallation"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								}
							case 't': // Prefix: "teraction-limits"
								if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: InteractionsRemoveRestrictionsForAuthenticatedUser
										r.name = "InteractionsRemoveRestrictionsForAuthenticatedUser"
										r.args = args
										r.count = 0
										return r, true
									case "PUT":
										// Leaf: InteractionsSetRestrictionsForAuthenticatedUser
										r.name = "InteractionsSetRestrictionsForAuthenticatedUser"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							}
						case 's': // Prefix: "ssues"
							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: IssuesListForAuthenticatedUser
									r.name = "IssuesListForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "UsersListPublicSSHKeysForAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "UsersCreatePublicSSHKeyForAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: UsersDeletePublicSSHKeyForAuthenticated
									r.name = "UsersDeletePublicSSHKeyForAuthenticated"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: UsersGetPublicSSHKeyForAuthenticated
									r.name = "UsersGetPublicSSHKeyForAuthenticated"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"
							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "AppsListSubscriptionsForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"
								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: AppsListSubscriptionsForAuthenticatedUserStubbed
										r.name = "AppsListSubscriptionsForAuthenticatedUserStubbed"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							}
						case 'e': // Prefix: "emberships/orgs"
							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "OrgsListMembershipsForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: OrgsGetMembershipForAuthenticatedUser
										r.name = "OrgsGetMembershipForAuthenticatedUser"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										// Leaf: OrgsUpdateMembershipForAuthenticatedUser
										r.name = "OrgsUpdateMembershipForAuthenticatedUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 'i': // Prefix: "igrations"
							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "MigrationsListForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = "MigrationsStartForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "MigrationsGetStatusForAuthenticatedUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"
										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: MigrationsDeleteArchiveForAuthenticatedUser
												r.name = "MigrationsDeleteArchiveForAuthenticatedUser"
												r.args = args
												r.count = 1
												return r, true
											case "GET":
												// Leaf: MigrationsGetArchiveForAuthenticatedUser
												r.name = "MigrationsGetArchiveForAuthenticatedUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 'r': // Prefix: "repos"
										if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repo_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/lock"
												if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: MigrationsUnlockRepoForAuthenticatedUser
														r.name = "MigrationsUnlockRepoForAuthenticatedUser"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 'i': // Prefix: "itories"
											if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: MigrationsListReposForUser
													r.name = "MigrationsListReposForUser"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										}
									}
								}
							}
						}
					case 'o': // Prefix: "orgs"
						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: OrgsListForAuthenticatedUser
								r.name = "OrgsListForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"
							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "PackagesListPackagesForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = "PackagesDeletePackageForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = "PackagesGetPackageForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "restore"
											if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: PackagesRestorePackageForAuthenticatedUser
													r.name = "PackagesRestorePackageForAuthenticatedUser"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'v': // Prefix: "versions"
											if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = "PackagesDeletePackageVersionForAuthenticatedUser"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = "PackagesGetPackageVersionForAuthenticatedUser"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/restore"
													if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: PackagesRestorePackageVersionForAuthenticatedUser
															r.name = "PackagesRestorePackageVersionForAuthenticatedUser"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: ProjectsCreateForAuthenticatedUser
									r.name = "ProjectsCreateForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 'u': // Prefix: "ublic_emails"
							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: UsersListPublicEmailsForAuthenticated
									r.name = "UsersListPublicEmailsForAuthenticated"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ReposListForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "ReposCreateForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"
							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ReposListInvitationsForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: ReposDeclineInvitation
										r.name = "ReposDeclineInvitation"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										// Leaf: ReposAcceptInvitation
										r.name = "ReposAcceptInvitation"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case 's': // Prefix: "s"
						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"
							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ActivityListReposStarredByAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: ActivityUnstarRepoForAuthenticatedUser
											r.name = "ActivityUnstarRepoForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: ActivityCheckRepoIsStarredByAuthenticatedUser
											r.name = "ActivityCheckRepoIsStarredByAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: ActivityStarRepoForAuthenticatedUser
											r.name = "ActivityStarRepoForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							}
						case 'u': // Prefix: "ubscriptions"
							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ActivityListWatchedReposForAuthenticatedUser
									r.name = "ActivityListWatchedReposForAuthenticatedUser"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: TeamsListForAuthenticatedUser
								r.name = "TeamsListForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					}
				case 's': // Prefix: "s"
					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "UsersList"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "UsersGetByUsername"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "events"
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "ActivityListEventsForAuthenticatedUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"
										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ActivityListOrgEventsForAuthenticatedUser
												r.name = "ActivityListOrgEventsForAuthenticatedUser"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 'p': // Prefix: "public"
										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ActivityListPublicEventsForUser
												r.name = "ActivityListPublicEventsForUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								}
							case 'f': // Prefix: "follow"
								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"
									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: UsersListFollowersForUser
											r.name = "UsersListFollowersForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'i': // Prefix: "ing"
									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "UsersListFollowingForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: UsersCheckFollowingForUser
												r.name = "UsersCheckFollowingForUser"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								}
							case 'g': // Prefix: "g"
								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"
									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GistsListForUser
											r.name = "GistsListForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'p': // Prefix: "pg_keys"
									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: UsersListGpgKeysForUser
											r.name = "UsersListGpgKeysForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'h': // Prefix: "hovercard"
								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: UsersGetContextForUser
										r.name = "UsersGetContextForUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'k': // Prefix: "keys"
								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: UsersListPublicKeysForUser
										r.name = "UsersListPublicKeysForUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'o': // Prefix: "orgs"
								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: OrgsListForUser
										r.name = "OrgsListForUser"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'p': // Prefix: "p"
								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"
									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "PackagesListPackagesForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "PackagesDeletePackageForUser"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = "PackagesGetPackageForUser"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"
													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: PackagesRestorePackageForUser
															r.name = "PackagesRestorePackageForUser"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												case 'v': // Prefix: "versions"
													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = "PackagesGetAllPackageVersionsForPackageOwnedByUser"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = "PackagesDeletePackageVersionForUser"
																r.args = args
																r.count = 4
																return r, true
															case "GET":
																r.name = "PackagesGetPackageVersionForUser"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"
															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "POST":
																	// Leaf: PackagesRestorePackageVersionForUser
																	r.name = "PackagesRestorePackageVersionForUser"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "rojects"
									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ProjectsListForUser
											r.name = "ProjectsListForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"
									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "ActivityListReceivedEventsForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/public"
										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ActivityListReceivedPublicEventsForUser
												r.name = "ActivityListReceivedPublicEventsForUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								case 'p': // Prefix: "pos"
									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ReposListForUser
											r.name = "ReposListForUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"
									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"
										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: BillingGetGithubActionsBillingUser
												r.name = "BillingGetGithubActionsBillingUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 'p': // Prefix: "packages"
										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: BillingGetGithubPackagesBillingUser
												r.name = "BillingGetGithubPackagesBillingUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 's': // Prefix: "shared-storage"
										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: BillingGetSharedStorageBillingUser
												r.name = "BillingGetSharedStorageBillingUser"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								case 'u': // Prefix: "ubscriptions"
									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ActivityListReposWatchedByUser
											r.name = "ActivityListReposWatchedByUser"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					}
				}
			case 'z': // Prefix: "zen"
				if l := len("zen"); len(elem) >= l && elem[0:l] == "zen" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: MetaGetZen
						r.name = "MetaGetZen"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
			}
		}
	}
	return r, false
}
