// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

func (s *Server) notFound(w http.ResponseWriter, r *http.Request) {
	http.NotFound(w, r)
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}

	args := map[string]string{}
	// Static code generated router with unwrapped path search.
	switch r.Method {
	case "DELETE":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsDeleteOrgSecretRequest(args, w, r)
				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsDeleteAuthorizationRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsDeleteInstallationRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/installations/"
						if l := len("/installations/"); len(elem) >= l && elem[0:l] == "/installations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["installation_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleAppsDeleteInstallationRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/suspended"
								if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsUnsuspendInstallation
									s.handleAppsUnsuspendInstallationRequest(args, w, r)
									return
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants/"
							if l := len("grants/"); len(elem) >= l && elem[0:l] == "grants/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args["grant_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsDeleteGrant
								s.handleOAuthAuthorizationsDeleteGrantRequest(args, w, r)
								return
							}
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["client_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleAppsDeleteTokenRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'g': // Prefix: "grant"
									if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsDeleteAuthorization
										s.handleAppsDeleteAuthorizationRequest(args, w, r)
										return
									}
								case 't': // Prefix: "token"
									if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsDeleteToken
										s.handleAppsDeleteTokenRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args["authorization_id"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsDeleteAuthorization
						s.handleOAuthAuthorizationsDeleteAuthorizationRequest(args, w, r)
						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/actions/"
						if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions/organizations/"
							if l := len("permissions/organizations/"); len(elem) >= l && elem[0:l] == "permissions/organizations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "org_id"
							// Leaf parameter
							args["org_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
								s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args, w, r)
								return
							}
						case 'r': // Prefix: "runner"
							if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '-': // Prefix: "-groups/"
								if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_group_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["runner_group_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations/"
											if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "org_id"
											// Leaf parameter
											args["org_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
												s.handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args, w, r)
												return
											}
										case 'r': // Prefix: "runners/"
											if l := len("runners/"); len(elem) >= l && elem[0:l] == "runners/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_id"
											// Leaf parameter
											args["runner_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
												s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args, w, r)
												return
											}
										}
									}
								}
							case 's': // Prefix: "s/"
								if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_id"
								// Leaf parameter
								args["runner_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
									s.handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(args, w, r)
									return
								}
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["gist_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleGistsDeleteRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleGistsUnstarRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'c': // Prefix: "comments/"
							if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "comment_id"
							// Leaf parameter
							args["comment_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: GistsDeleteComment
								s.handleGistsDeleteCommentRequest(args, w, r)
								return
							}
						case 's': // Prefix: "star"
							if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsUnstar
								s.handleGistsUnstarRequest(args, w, r)
								return
							}
						}
					}
				}
			case 'i': // Prefix: "installation/token"
				if l := len("installation/token"); len(elem) >= l && elem[0:l] == "installation/token" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: AppsRevokeInstallationAccessToken
					s.handleAppsRevokeInstallationAccessTokenRequest(args, w, r)
					return
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["thread_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/subscription"
						if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ActivityDeleteThreadSubscription
							s.handleActivityDeleteThreadSubscriptionRequest(args, w, r)
							return
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["org"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleInteractionsRemoveRestrictionsForOrgRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "actions/"
							if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsDeleteSelfHostedRunnerFromOrgRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'p': // Prefix: "permissions/repositories/"
								if l := len("permissions/repositories/"); len(elem) >= l && elem[0:l] == "permissions/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args["repository_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsDisableSelectedRepositoryGithubActionsOrganization
									s.handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(args, w, r)
									return
								}
							case 'r': // Prefix: "runner"
								if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '-': // Prefix: "-groups/"
									if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_group_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["runner_group_id"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/r"
											if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'e': // Prefix: "epositories/"
												if l := len("epositories/"); len(elem) >= l && elem[0:l] == "epositories/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args["repository_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
													s.handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(args, w, r)
													return
												}
											case 'u': // Prefix: "unners/"
												if l := len("unners/"); len(elem) >= l && elem[0:l] == "unners/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_id"
												// Leaf parameter
												args["runner_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsRemoveSelfHostedRunnerFromGroupForOrg
													s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args, w, r)
													return
												}
											}
										}
									}
								case 's': // Prefix: "s/"
									if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_id"
									// Leaf parameter
									args["runner_id"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActionsDeleteSelfHostedRunnerFromOrg
										s.handleActionsDeleteSelfHostedRunnerFromOrgRequest(args, w, r)
										return
									}
								}
							case 's': // Prefix: "secrets/"
								if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "secret_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["secret_name"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleActionsDeleteOrgSecretRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/repositories/"
										if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args["repository_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsRemoveSelectedRepoFromOrgSecret
											s.handleActionsRemoveSelectedRepoFromOrgSecretRequest(args, w, r)
											return
										}
									}
								}
							}
						case 'b': // Prefix: "blocks/"
							if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsUnblockUser
								s.handleOrgsUnblockUserRequest(args, w, r)
								return
							}
						case 'c': // Prefix: "credential-authorizations/"
							if l := len("credential-authorizations/"); len(elem) >= l && elem[0:l] == "credential-authorizations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "credential_id"
							// Leaf parameter
							args["credential_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsRemoveSamlSSOAuthorization
								s.handleOrgsRemoveSamlSSOAuthorizationRequest(args, w, r)
								return
							}
						case 'h': // Prefix: "hooks/"
							if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Leaf parameter
							args["hook_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsDeleteWebhook
								s.handleOrgsDeleteWebhookRequest(args, w, r)
								return
							}
						case 'i': // Prefix: "in"
							if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsCancelInvitationRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 't': // Prefix: "teraction-limits"
								if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: InteractionsRemoveRestrictionsForOrg
									s.handleInteractionsRemoveRestrictionsForOrgRequest(args, w, r)
									return
								}
							case 'v': // Prefix: "vitations/"
								if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter
								args["invitation_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsCancelInvitation
									s.handleOrgsCancelInvitationRequest(args, w, r)
									return
								}
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsRemoveMemberRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'e': // Prefix: "embers"
								if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsRemoveMembershipForUserRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args["username"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsRemoveMember
										s.handleOrgsRemoveMemberRequest(args, w, r)
										return
									}
								case 'h': // Prefix: "hips/"
									if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args["username"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsRemoveMembershipForUser
										s.handleOrgsRemoveMembershipForUserRequest(args, w, r)
										return
									}
								}
							case 'i': // Prefix: "igrations/"
								if l := len("igrations/"); len(elem) >= l && elem[0:l] == "igrations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["migration_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleMigrationsUnlockRepoForOrgRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsDeleteArchiveForOrg
												s.handleMigrationsDeleteArchiveForOrgRequest(args, w, r)
												return
											}
										case 'r': // Prefix: "repos/"
											if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repo_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["repo_name"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/lock"
													if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: MigrationsUnlockRepoForOrg
														s.handleMigrationsUnlockRepoForOrgRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								}
							}
						case 'o': // Prefix: "outside_collaborators/"
							if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsRemoveOutsideCollaborator
								s.handleOrgsRemoveOutsideCollaboratorRequest(args, w, r)
								return
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handlePackagesDeletePackageForOrgRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages/"
								if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["package_type"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["package_name"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handlePackagesDeletePackageForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/versions/"
												if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Leaf parameter
												args["package_version_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: PackagesDeletePackageVersionForOrg
													s.handlePackagesDeletePackageVersionForOrgRequest(args, w, r)
													return
												}
											}
										}
									}
								}
							case 'u': // Prefix: "ublic_members/"
								if l := len("ublic_members/"); len(elem) >= l && elem[0:l] == "ublic_members/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsRemovePublicMembershipForAuthenticatedUser
									s.handleOrgsRemovePublicMembershipForAuthenticatedUserRequest(args, w, r)
									return
								}
							}
						case 't': // Prefix: "teams/"
							if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "team_slug"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["team_slug"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsDeleteInOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleTeamsRemoveMembershipForUserInOrgRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'd': // Prefix: "discussions/"
										if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "discussion_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["discussion_number"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleTeamsDeleteDiscussionInOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReactionsDeleteForTeamDiscussionCommentRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'c': // Prefix: "comments/"
													if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_number"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["comment_number"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleTeamsDeleteDiscussionCommentInOrgRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions/"
															if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args["reaction_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReactionsDeleteForTeamDiscussionComment
																s.handleReactionsDeleteForTeamDiscussionCommentRequest(args, w, r)
																return
															}
														}
													}
												case 'r': // Prefix: "reactions/"
													if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "reaction_id"
													// Leaf parameter
													args["reaction_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReactionsDeleteForTeamDiscussion
														s.handleReactionsDeleteForTeamDiscussionRequest(args, w, r)
														return
													}
												}
											}
										}
									case 'm': // Prefix: "memberships/"
										if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args["username"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: TeamsRemoveMembershipForUserInOrg
											s.handleTeamsRemoveMembershipForUserInOrgRequest(args, w, r)
											return
										}
									case 'p': // Prefix: "projects/"
										if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "project_id"
										// Leaf parameter
										args["project_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: TeamsRemoveProjectInOrg
											s.handleTeamsRemoveProjectInOrgRequest(args, w, r)
											return
										}
									case 'r': // Prefix: "repos/"
										if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "owner"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["owner"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repo"
												// Leaf parameter
												args["repo"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsRemoveRepoInOrg
													s.handleTeamsRemoveRepoInOrgRequest(args, w, r)
													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsDeleteColumnRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args["card_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsDeleteCard
							s.handleProjectsDeleteCardRequest(args, w, r)
							return
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args["column_id"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsDeleteColumn
						s.handleProjectsDeleteColumnRequest(args, w, r)
						return
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["project_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleProjectsDeleteRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/collaborators/"
						if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args["username"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsRemoveCollaborator
							s.handleProjectsRemoveCollaboratorRequest(args, w, r)
							return
						}
					}
				}
			case 'r': // Prefix: "re"
				if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleReactionsDeleteLegacyRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'a': // Prefix: "actions/"
					if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "reaction_id"
					// Leaf parameter
					args["reaction_id"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ReactionsDeleteLegacy
						s.handleReactionsDeleteLegacyRequest(args, w, r)
						return
					}
				case 'p': // Prefix: "pos"
					if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActionsDeleteEnvironmentSecretRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["owner"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["repo"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleReposDeleteRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActivityDeleteRepoSubscriptionRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposDeleteAutolinkRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'c': // Prefix: "ctions/"
												if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsDeleteRepoSecretRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'a': // Prefix: "artifacts/"
													if l := len("artifacts/"); len(elem) >= l && elem[0:l] == "artifacts/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "artifact_id"
													// Leaf parameter
													args["artifact_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsDeleteArtifact
														s.handleActionsDeleteArtifactRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "run"
													if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsDeleteWorkflowRunRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'n': // Prefix: "ners/"
														if l := len("ners/"); len(elem) >= l && elem[0:l] == "ners/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter
														args["runner_id"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ActionsDeleteSelfHostedRunnerFromRepo
															s.handleActionsDeleteSelfHostedRunnerFromRepoRequest(args, w, r)
															return
														}
													case 's': // Prefix: "s/"
														if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "run_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx > 0 {
															args["run_id"] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handleActionsDeleteWorkflowRunRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/logs"
																if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsDeleteWorkflowRunLogs
																	s.handleActionsDeleteWorkflowRunLogsRequest(args, w, r)
																	return
																}
															}
														}
													}
												case 's': // Prefix: "secrets/"
													if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "secret_name"
													// Leaf parameter
													args["secret_name"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsDeleteRepoSecret
														s.handleActionsDeleteRepoSecretRequest(args, w, r)
														return
													}
												}
											case 'u': // Prefix: "uto"
												if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposDisableAutomatedSecurityFixesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'l': // Prefix: "links/"
													if l := len("links/"); len(elem) >= l && elem[0:l] == "links/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter
													args["autolink_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposDeleteAutolink
														s.handleReposDeleteAutolinkRequest(args, w, r)
														return
													}
												case 'm': // Prefix: "mated-security-fixes"
													if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposDisableAutomatedSecurityFixes
														s.handleReposDisableAutomatedSecurityFixesRequest(args, w, r)
														return
													}
												}
											}
										case 'b': // Prefix: "branches/"
											if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "branch"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["branch"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/protection"
													if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposDeleteBranchProtectionRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposDeleteAdminBranchProtectionRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'e': // Prefix: "enforce_admins"
															if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposDeleteAdminBranchProtection
																s.handleReposDeleteAdminBranchProtectionRequest(args, w, r)
																return
															}
														case 'r': // Prefix: "re"
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposDeleteCommitSignatureProtectionRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'q': // Prefix: "quired_"
																if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposDeletePullRequestReviewProtectionRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case 'p': // Prefix: "pull_request_reviews"
																	if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposDeletePullRequestReviewProtection
																		s.handleReposDeletePullRequestReviewProtectionRequest(args, w, r)
																		return
																	}
																case 's': // Prefix: "s"
																	if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleReposRemoveStatusCheckContextsRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case 'i': // Prefix: "ignatures"
																		if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReposDeleteCommitSignatureProtection
																			s.handleReposDeleteCommitSignatureProtectionRequest(args, w, r)
																			return
																		}
																	case 't': // Prefix: "tatus_checks"
																		if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			s.handleReposRemoveStatusCheckProtectionRequest(args, w, r)
																			return
																		}
																		switch elem[0] {
																		case '/': // Prefix: "/contexts"
																			if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposRemoveStatusCheckContexts
																				s.handleReposRemoveStatusCheckContextsRequest(args, w, r)
																				return
																			}
																		}
																	}
																}
															case 's': // Prefix: "strictions"
																if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposDeleteAccessRestrictionsRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleReposRemoveTeamAccessRestrictionsRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "apps"
																		if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReposRemoveAppAccessRestrictions
																			s.handleReposRemoveAppAccessRestrictionsRequest(args, w, r)
																			return
																		}
																	case 't': // Prefix: "teams"
																		if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReposRemoveTeamAccessRestrictions
																			s.handleReposRemoveTeamAccessRestrictionsRequest(args, w, r)
																			return
																		}
																	case 'u': // Prefix: "users"
																		if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReposRemoveUserAccessRestrictions
																			s.handleReposRemoveUserAccessRestrictionsRequest(args, w, r)
																			return
																		}
																	}
																}
															}
														}
													}
												}
											}
										case 'c': // Prefix: "co"
											if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReactionsDeleteForCommitCommentRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'd': // Prefix: "de-scanning/analyses/"
												if l := len("de-scanning/analyses/"); len(elem) >= l && elem[0:l] == "de-scanning/analyses/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "analysis_id"
												// Leaf parameter
												args["analysis_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: CodeScanningDeleteAnalysis
													s.handleCodeScanningDeleteAnalysisRequest(args, w, r)
													return
												}
											case 'l': // Prefix: "llaborators/"
												if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Leaf parameter
												args["username"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposRemoveCollaborator
													s.handleReposRemoveCollaboratorRequest(args, w, r)
													return
												}
											case 'm': // Prefix: "mments/"
												if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["comment_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleReposDeleteCommitCommentRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions/"
														if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "reaction_id"
														// Leaf parameter
														args["reaction_id"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ReactionsDeleteForCommitComment
															s.handleReactionsDeleteForCommitCommentRequest(args, w, r)
															return
														}
													}
												}
											case 'n': // Prefix: "ntents/"
												if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "path"
												// Leaf parameter
												args["path"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposDeleteFile
													s.handleReposDeleteFileRequest(args, w, r)
													return
												}
											}
										case 'd': // Prefix: "deployments/"
											if l := len("deployments/"); len(elem) >= l && elem[0:l] == "deployments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "deployment_id"
											// Leaf parameter
											args["deployment_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteDeployment
												s.handleReposDeleteDeploymentRequest(args, w, r)
												return
											}
										case 'e': // Prefix: "environments/"
											if l := len("environments/"); len(elem) >= l && elem[0:l] == "environments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "environment_name"
											// Leaf parameter
											args["environment_name"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteAnEnvironment
												s.handleReposDeleteAnEnvironmentRequest(args, w, r)
												return
											}
										case 'g': // Prefix: "git/refs/"
											if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "ref"
											// Leaf parameter
											args["ref"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GitDeleteRef
												s.handleGitDeleteRefRequest(args, w, r)
												return
											}
										case 'h': // Prefix: "hooks/"
											if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "hook_id"
											// Leaf parameter
											args["hook_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteWebhook
												s.handleReposDeleteWebhookRequest(args, w, r)
												return
											}
										case 'i': // Prefix: "i"
											if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleIssuesDeleteCommentRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'm': // Prefix: "mport"
												if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsCancelImport
													s.handleMigrationsCancelImportRequest(args, w, r)
													return
												}
											case 'n': // Prefix: "n"
												if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposDeleteInvitationRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 't': // Prefix: "teraction-limits"
													if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: InteractionsRemoveRestrictionsForRepo
														s.handleInteractionsRemoveRestrictionsForRepoRequest(args, w, r)
														return
													}
												case 'v': // Prefix: "vitations/"
													if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "invitation_id"
													// Leaf parameter
													args["invitation_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposDeleteInvitation
														s.handleReposDeleteInvitationRequest(args, w, r)
														return
													}
												}
											case 's': // Prefix: "ssues/"
												if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesRemoveAllLabelsRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'c': // Prefix: "comments/"
													if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["comment_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleIssuesDeleteCommentRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions/"
															if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args["reaction_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReactionsDeleteForIssueComment
																s.handleReactionsDeleteForIssueCommentRequest(args, w, r)
																return
															}
														}
													}
												}
												// Param: "issue_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["issue_number"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleIssuesRemoveAssigneesRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'a': // Prefix: "assignees"
															if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: IssuesRemoveAssignees
																s.handleIssuesRemoveAssigneesRequest(args, w, r)
																return
															}
														case 'l': // Prefix: "l"
															if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleIssuesUnlockRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'a': // Prefix: "abels"
																if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleIssuesRemoveAllLabelsRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "name"
																	// Leaf parameter
																	args["name"] = elem
																	elem = ""

																	if len(elem) == 0 {
																		// Leaf: IssuesRemoveLabel
																		s.handleIssuesRemoveLabelRequest(args, w, r)
																		return
																	}
																}
															case 'o': // Prefix: "ock"
																if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: IssuesUnlock
																	s.handleIssuesUnlockRequest(args, w, r)
																	return
																}
															}
														case 'r': // Prefix: "reactions/"
															if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args["reaction_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReactionsDeleteForIssue
																s.handleReactionsDeleteForIssueRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 'k': // Prefix: "keys/"
											if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "key_id"
											// Leaf parameter
											args["key_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteDeployKey
												s.handleReposDeleteDeployKeyRequest(args, w, r)
												return
											}
										case 'l': // Prefix: "l"
											if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposDisableLfsForRepoRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "abels/"
												if l := len("abels/"); len(elem) >= l && elem[0:l] == "abels/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "name"
												// Leaf parameter
												args["name"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: IssuesDeleteLabel
													s.handleIssuesDeleteLabelRequest(args, w, r)
													return
												}
											case 'f': // Prefix: "fs"
												if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposDisableLfsForRepo
													s.handleReposDisableLfsForRepoRequest(args, w, r)
													return
												}
											}
										case 'm': // Prefix: "milestones/"
											if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "milestone_number"
											// Leaf parameter
											args["milestone_number"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: IssuesDeleteMilestone
												s.handleIssuesDeleteMilestoneRequest(args, w, r)
												return
											}
										case 'p': // Prefix: "p"
											if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposDeletePagesSiteRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "ages"
												if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposDeletePagesSite
													s.handleReposDeletePagesSiteRequest(args, w, r)
													return
												}
											case 'u': // Prefix: "ulls/"
												if l := len("ulls/"); len(elem) >= l && elem[0:l] == "ulls/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments/"
													if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["comment_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handlePullsDeleteReviewCommentRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions/"
															if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter
															args["reaction_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReactionsDeleteForPullRequestComment
																s.handleReactionsDeleteForPullRequestCommentRequest(args, w, r)
																return
															}
														}
													}
												}
												// Param: "pull_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["pull_number"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/re"
														if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePullsRemoveRequestedReviewersRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'q': // Prefix: "quested_reviewers"
															if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: PullsRemoveRequestedReviewers
																s.handlePullsRemoveRequestedReviewersRequest(args, w, r)
																return
															}
														case 'v': // Prefix: "views/"
															if l := len("views/"); len(elem) >= l && elem[0:l] == "views/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "review_id"
															// Leaf parameter
															args["review_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: PullsDeletePendingReview
																s.handlePullsDeletePendingReviewRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 'r': // Prefix: "releases/"
											if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "assets/"
												if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "asset_id"
												// Leaf parameter
												args["asset_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposDeleteReleaseAsset
													s.handleReposDeleteReleaseAssetRequest(args, w, r)
													return
												}
											}
											// Param: "release_id"
											// Leaf parameter
											args["release_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteRelease
												s.handleReposDeleteReleaseRequest(args, w, r)
												return
											}
										case 's': // Prefix: "subscription"
											if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityDeleteRepoSubscription
												s.handleActivityDeleteRepoSubscriptionRequest(args, w, r)
												return
											}
										case 'v': // Prefix: "vulnerability-alerts"
											if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposDisableVulnerabilityAlerts
												s.handleReposDisableVulnerabilityAlertsRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					case 'i': // Prefix: "itories/"
						if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repository_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["repository_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/environments/"
								if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "environment_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["environment_name"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/secrets/"
										if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "secret_name"
										// Leaf parameter
										args["secret_name"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsDeleteEnvironmentSecret
											s.handleActionsDeleteEnvironmentSecretRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/"
				if l := len("scim/v2/"); len(elem) >= l && elem[0:l] == "scim/v2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleScimDeleteUserFromOrgRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'e': // Prefix: "enterprises/"
					if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["enterprise"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups/"
								if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_group_id"
								// Leaf parameter
								args["scim_group_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminDeleteScimGroupFromEnterprise
									s.handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(args, w, r)
									return
								}
							case 'U': // Prefix: "Users/"
								if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_user_id"
								// Leaf parameter
								args["scim_user_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminDeleteUserFromEnterprise
									s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args, w, r)
									return
								}
							}
						}
					}
				case 'o': // Prefix: "organizations/"
					if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["org"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/Users/"
							if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args["scim_user_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ScimDeleteUserFromOrg
								s.handleScimDeleteUserFromOrgRequest(args, w, r)
								return
							}
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["team_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleTeamsDeleteLegacyRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsRemoveMemberLegacyRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'd': // Prefix: "discussions/"
							if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["discussion_number"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsDeleteDiscussionLegacyRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/comments/"
									if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Leaf parameter
									args["comment_number"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsDeleteDiscussionCommentLegacy
										s.handleTeamsDeleteDiscussionCommentLegacyRequest(args, w, r)
										return
									}
								}
							}
						case 'm': // Prefix: "members"
							if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsRemoveMembershipForUserLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveMemberLegacy
									s.handleTeamsRemoveMemberLegacyRequest(args, w, r)
									return
								}
							case 'h': // Prefix: "hips/"
								if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveMembershipForUserLegacy
									s.handleTeamsRemoveMembershipForUserLegacyRequest(args, w, r)
									return
								}
							}
						case 'p': // Prefix: "projects/"
							if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args["project_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveProjectLegacy
								s.handleTeamsRemoveProjectLegacyRequest(args, w, r)
								return
							}
						case 'r': // Prefix: "repos/"
							if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["owner"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args["repo"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsRemoveRepoLegacy
										s.handleTeamsRemoveRepoLegacyRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handlePackagesDeletePackageForUserRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsRemoveRepoFromInstallationRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args["username"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnblock
							s.handleUsersUnblockRequest(args, w, r)
							return
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersDeleteEmailForAuthenticated
							s.handleUsersDeleteEmailForAuthenticatedRequest(args, w, r)
							return
						}
					case 'f': // Prefix: "following/"
						if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args["username"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnfollow
							s.handleUsersUnfollowRequest(args, w, r)
							return
						}
					case 'g': // Prefix: "gpg_keys/"
						if l := len("gpg_keys/"); len(elem) >= l && elem[0:l] == "gpg_keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "gpg_key_id"
						// Leaf parameter
						args["gpg_key_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeleteGpgKeyForAuthenticated
							s.handleUsersDeleteGpgKeyForAuthenticatedRequest(args, w, r)
							return
						}
					case 'i': // Prefix: "in"
						if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 's': // Prefix: "stallations/"
							if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["installation_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories/"
									if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repository_id"
									// Leaf parameter
									args["repository_id"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: AppsRemoveRepoFromInstallation
										s.handleAppsRemoveRepoFromInstallationRequest(args, w, r)
										return
									}
								}
							}
						case 't': // Prefix: "teraction-limits"
							if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsRemoveRestrictionsForAuthenticatedUser
								s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					case 'k': // Prefix: "keys/"
						if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "key_id"
						// Leaf parameter
						args["key_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeletePublicSSHKeyForAuthenticated
							s.handleUsersDeletePublicSSHKeyForAuthenticatedRequest(args, w, r)
							return
						}
					case 'm': // Prefix: "migrations/"
						if l := len("migrations/"); len(elem) >= l && elem[0:l] == "migrations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "migration_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["migration_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleMigrationsUnlockRepoForAuthenticatedUserRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'a': // Prefix: "archive"
									if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsDeleteArchiveForAuthenticatedUser
										s.handleMigrationsDeleteArchiveForAuthenticatedUserRequest(args, w, r)
										return
									}
								case 'r': // Prefix: "repos/"
									if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["repo_name"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/lock"
											if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsUnlockRepoForAuthenticatedUser
												s.handleMigrationsUnlockRepoForAuthenticatedUserRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					case 'p': // Prefix: "packages/"
						if l := len("packages/"); len(elem) >= l && elem[0:l] == "packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["package_type"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["package_name"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handlePackagesDeletePackageForAuthenticatedUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/versions/"
										if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_version_id"
										// Leaf parameter
										args["package_version_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: PackagesDeletePackageVersionForAuthenticatedUser
											s.handlePackagesDeletePackageVersionForAuthenticatedUserRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args["invitation_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposDeclineInvitation
							s.handleReposDeclineInvitationRequest(args, w, r)
							return
						}
					case 's': // Prefix: "starred/"
						if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["owner"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter
								args["repo"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActivityUnstarRepoForAuthenticatedUser
									s.handleActivityUnstarRepoForAuthenticatedUserRequest(args, w, r)
									return
								}
							}
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["username"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/packages/"
							if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["package_type"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["package_name"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handlePackagesDeletePackageForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/versions/"
											if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_version_id"
											// Leaf parameter
											args["package_version_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: PackagesDeletePackageVersionForUser
												s.handlePackagesDeletePackageVersionForUserRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case "GET":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleMetaRootRequest(args, w, r)
				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsGetAuthorizationRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsGetAuthenticatedRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/"
						if l := len("/hook/"); len(elem) >= l && elem[0:l] == "/hook/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsGetWebhookDeliveryRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'c': // Prefix: "config"
							if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsGetWebhookConfigForApp
								s.handleAppsGetWebhookConfigForAppRequest(args, w, r)
								return
							}
						case 'd': // Prefix: "deliveries"
							if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListWebhookDeliveriesRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "delivery_id"
								// Leaf parameter
								args["delivery_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsGetWebhookDelivery
									s.handleAppsGetWebhookDeliveryRequest(args, w, r)
									return
								}
							}
						}
					case 'l': // Prefix: "lications/grants"
						if l := len("lications/grants"); len(elem) >= l && elem[0:l] == "lications/grants" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOAuthAuthorizationsListGrantsRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args["grant_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsGetGrant
								s.handleOAuthAuthorizationsGetGrantRequest(args, w, r)
								return
							}
						}
					case 's': // Prefix: "s/"
						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter
						args["app_slug"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetBySlug
							s.handleAppsGetBySlugRequest(args, w, r)
							return
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleOAuthAuthorizationsListAuthorizationsRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "authorization_id"
						// Leaf parameter
						args["authorization_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OAuthAuthorizationsGetAuthorization
							s.handleOAuthAuthorizationsGetAuthorizationRequest(args, w, r)
							return
						}
					}
				}
			case 'c': // Prefix: "codes_of_conduct"
				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleCodesOfConductGetAllCodesOfConductRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter
					args["key"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: CodesOfConductGetConductCode
						s.handleCodesOfConductGetConductCodeRequest(args, w, r)
						return
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleBillingGetGithubActionsBillingGheRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"
					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: EmojisGet
						s.handleEmojisGetRequest(args, w, r)
						return
					}
				case 'n': // Prefix: "nterprises/"
					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["enterprise"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'a': // Prefix: "a"
								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminGetAuditLogRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"
									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"
										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'o': // Prefix: "organizations"
												if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise
													s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args, w, r)
													return
												}
											case 's': // Prefix: "selected-actions"
												if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: EnterpriseAdminGetAllowedActionsEnterprise
													s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args, w, r)
													return
												}
											}
										}
									case 'r': // Prefix: "runner"
										if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '-': // Prefix: "-groups"
											if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_group_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["runner_group_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'o': // Prefix: "organizations"
															if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise
																s.handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args, w, r)
																return
															}
														case 'r': // Prefix: "runners"
															if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise
																s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "downloads"
													if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: EnterpriseAdminListRunnerApplicationsForEnterprise
														s.handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(args, w, r)
														return
													}
												}
												// Param: "runner_id"
												// Leaf parameter
												args["runner_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: EnterpriseAdminGetSelfHostedRunnerForEnterprise
													s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args, w, r)
													return
												}
											}
										}
									}
								case 'u': // Prefix: "udit-log"
									if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminGetAuditLog
										s.handleEnterpriseAdminGetAuditLogRequest(args, w, r)
										return
									}
								}
							case 's': // Prefix: "settings/billing/"
								if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleBillingGetGithubPackagesBillingGheRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"
									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubActionsBillingGhe
										s.handleBillingGetGithubActionsBillingGheRequest(args, w, r)
										return
									}
								case 'p': // Prefix: "packages"
									if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubPackagesBillingGhe
										s.handleBillingGetGithubPackagesBillingGheRequest(args, w, r)
										return
									}
								case 's': // Prefix: "shared-storage"
									if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetSharedStorageBillingGhe
										s.handleBillingGetSharedStorageBillingGheRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				case 'v': // Prefix: "vents"
					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ActivityListPublicEvents
						s.handleActivityListPublicEventsRequest(args, w, r)
						return
					}
				}
			case 'f': // Prefix: "feeds"
				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: ActivityGetFeeds
					s.handleActivityGetFeedsRequest(args, w, r)
					return
				}
			case 'g': // Prefix: "gi"
				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleGitignoreGetAllTemplatesRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 's': // Prefix: "sts"
					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleGistsListRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListPublic
								s.handleGistsListPublicRequest(args, w, r)
								return
							}
						case 's': // Prefix: "starred"
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListStarred
								s.handleGistsListStarredRequest(args, w, r)
								return
							}
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["gist_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleGistsGetRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleGistsGetCommentRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'c': // Prefix: "comm"
									if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleGistsListCommitsRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "ents"
										if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleGistsListCommentsRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Leaf parameter
											args["comment_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GistsGetComment
												s.handleGistsGetCommentRequest(args, w, r)
												return
											}
										}
									case 'i': // Prefix: "its"
										if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GistsListCommits
											s.handleGistsListCommitsRequest(args, w, r)
											return
										}
									}
								case 'f': // Prefix: "forks"
									if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsListForks
										s.handleGistsListForksRequest(args, w, r)
										return
									}
								case 's': // Prefix: "star"
									if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsCheckIsStarred
										s.handleGistsCheckIsStarredRequest(args, w, r)
										return
									}
								}
								// Param: "sha"
								// Leaf parameter
								args["sha"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: GistsGetRevision
									s.handleGistsGetRevisionRequest(args, w, r)
									return
								}
							}
						}
					}
				case 't': // Prefix: "tignore/templates"
					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleGitignoreGetAllTemplatesRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args["name"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GitignoreGetTemplate
							s.handleGitignoreGetTemplateRequest(args, w, r)
							return
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleIssuesListRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/repositories"
					if l := len("nstallation/repositories"); len(elem) >= l && elem[0:l] == "nstallation/repositories" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: AppsListReposAccessibleToInstallation
						s.handleAppsListReposAccessibleToInstallationRequest(args, w, r)
						return
					}
				case 's': // Prefix: "ssues"
					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: IssuesList
						s.handleIssuesListRequest(args, w, r)
						return
					}
				}
			case 'l': // Prefix: "licenses"
				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleLicensesGetAllCommonlyUsedRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter
					args["license"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: LicensesGet
						s.handleLicensesGetRequest(args, w, r)
						return
					}
				}
			case 'm': // Prefix: "m"
				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleMetaGetRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'a': // Prefix: "arketplace_listing/"
					if l := len("arketplace_listing/"); len(elem) >= l && elem[0:l] == "arketplace_listing/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsGetSubscriptionPlanForAccountStubbedRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'a': // Prefix: "accounts/"
						if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "account_id"
						// Leaf parameter
						args["account_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetSubscriptionPlanForAccount
							s.handleAppsGetSubscriptionPlanForAccountRequest(args, w, r)
							return
						}
					case 'p': // Prefix: "plans"
						if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsListPlansRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "plan_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["plan_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"
									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsListAccountsForPlan
										s.handleAppsListAccountsForPlanRequest(args, w, r)
										return
									}
								}
							}
						}
					case 's': // Prefix: "stubbed/"
						if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsListAccountsForPlanStubbedRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"
							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter
							args["account_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: AppsGetSubscriptionPlanForAccountStubbed
								s.handleAppsGetSubscriptionPlanForAccountStubbedRequest(args, w, r)
								return
							}
						case 'p': // Prefix: "plans"
							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListPlansStubbedRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["plan_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/accounts"
										if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: AppsListAccountsForPlanStubbed
											s.handleAppsListAccountsForPlanStubbedRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eta"
					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: MetaGet
						s.handleMetaGetRequest(args, w, r)
						return
					}
				}
			case 'n': // Prefix: "n"
				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActivityListPublicEventsForRepoNetworkRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"
					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["owner"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["repo"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/events"
									if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListPublicEventsForRepoNetwork
										s.handleActivityListPublicEventsForRepoNetworkRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				case 'o': // Prefix: "otifications"
					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActivityListNotificationsForAuthenticatedUserRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"
						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["thread_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleActivityGetThreadRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/subscription"
								if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivityGetThreadSubscriptionForAuthenticatedUser
									s.handleActivityGetThreadSubscriptionForAuthenticatedUserRequest(args, w, r)
									return
								}
							}
						}
					}
				}
			case 'o': // Prefix: "org"
				if l := len("org"); len(elem) >= l && elem[0:l] == "org" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOrgsListRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'a': // Prefix: "anizations"
					if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OrgsList
						s.handleOrgsListRequest(args, w, r)
						return
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["org"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleOrgsGetRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActivityListPublicOrgEventsRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'a': // Prefix: "a"
								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsGetAuditLogRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"
									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsGetOrgPublicKeyRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"
										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsGetGithubActionsPermissionsOrganizationRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'r': // Prefix: "repositories"
												if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
													s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args, w, r)
													return
												}
											case 's': // Prefix: "selected-actions"
												if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsGetAllowedActionsOrganization
													s.handleActionsGetAllowedActionsOrganizationRequest(args, w, r)
													return
												}
											}
										}
									case 'r': // Prefix: "runner"
										if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsGetSelfHostedRunnerGroupForOrgRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '-': // Prefix: "-groups"
											if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListSelfHostedRunnerGroupsForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_group_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["runner_group_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleActionsGetSelfHostedRunnerGroupForOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/r"
														if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsListSelfHostedRunnersInGroupForOrgRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'e': // Prefix: "epositories"
															if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
																s.handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(args, w, r)
																return
															}
														case 'u': // Prefix: "unners"
															if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsListSelfHostedRunnersInGroupForOrg
																s.handleActionsListSelfHostedRunnersInGroupForOrgRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListSelfHostedRunnersForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "downloads"
													if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListRunnerApplicationsForOrg
														s.handleActionsListRunnerApplicationsForOrgRequest(args, w, r)
														return
													}
												}
												// Param: "runner_id"
												// Leaf parameter
												args["runner_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsGetSelfHostedRunnerForOrg
													s.handleActionsGetSelfHostedRunnerForOrgRequest(args, w, r)
													return
												}
											}
										}
									case 's': // Prefix: "secrets"
										if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsListOrgSecretsRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsGetOrgSecretRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsGetOrgPublicKey
													s.handleActionsGetOrgPublicKeyRequest(args, w, r)
													return
												}
											}
											// Param: "secret_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["secret_name"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													s.handleActionsGetOrgSecretRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/repositories"
													if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListSelectedReposForOrgSecret
														s.handleActionsListSelectedReposForOrgSecretRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								case 'u': // Prefix: "udit-log"
									if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: OrgsGetAuditLog
										s.handleOrgsGetAuditLogRequest(args, w, r)
										return
									}
								}
							case 'b': // Prefix: "blocks"
								if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListBlockedUsersRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args["username"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsCheckBlockedUser
										s.handleOrgsCheckBlockedUserRequest(args, w, r)
										return
									}
								}
							case 'c': // Prefix: "credential-authorizations"
								if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsListSamlSSOAuthorizations
									s.handleOrgsListSamlSSOAuthorizationsRequest(args, w, r)
									return
								}
							case 'e': // Prefix: "events"
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivityListPublicOrgEvents
									s.handleActivityListPublicOrgEventsRequest(args, w, r)
									return
								}
							case 'f': // Prefix: "failed_invitations"
								if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsListFailedInvitations
									s.handleOrgsListFailedInvitationsRequest(args, w, r)
									return
								}
							case 'h': // Prefix: "hooks"
								if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListWebhooksRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["hook_id"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleOrgsGetWebhookRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleOrgsGetWebhookDeliveryRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'c': // Prefix: "config"
												if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: OrgsGetWebhookConfigForOrg
													s.handleOrgsGetWebhookConfigForOrgRequest(args, w, r)
													return
												}
											case 'd': // Prefix: "deliveries"
												if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleOrgsListWebhookDeliveriesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "delivery_id"
													// Leaf parameter
													args["delivery_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: OrgsGetWebhookDelivery
														s.handleOrgsGetWebhookDeliveryRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								}
							case 'i': // Prefix: "i"
								if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListInvitationTeamsRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'n': // Prefix: "nvitations"
									if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleOrgsListPendingInvitationsRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "invitation_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["invitation_id"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/teams"
												if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: OrgsListInvitationTeams
													s.handleOrgsListInvitationTeamsRequest(args, w, r)
													return
												}
											}
										}
									}
								case 's': // Prefix: "ssues"
									if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: IssuesListForOrg
										s.handleIssuesListForOrgRequest(args, w, r)
										return
									}
								}
							case 'm': // Prefix: "m"
								if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsCheckMembershipForUserRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'e': // Prefix: "embers"
									if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleOrgsListMembersRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args["username"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: OrgsCheckMembershipForUser
											s.handleOrgsCheckMembershipForUserRequest(args, w, r)
											return
										}
									case 'h': // Prefix: "hips/"
										if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args["username"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: OrgsGetMembershipForUser
											s.handleOrgsGetMembershipForUserRequest(args, w, r)
											return
										}
									}
								case 'i': // Prefix: "igrations"
									if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleMigrationsListForOrgRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "migration_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["migration_id"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleMigrationsGetStatusForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleMigrationsListReposForOrgRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'a': // Prefix: "archive"
													if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: MigrationsDownloadArchiveForOrg
														s.handleMigrationsDownloadArchiveForOrgRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "repositories"
													if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: MigrationsListReposForOrg
														s.handleMigrationsListReposForOrgRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								}
							case 'o': // Prefix: "outside_collaborators"
								if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsListOutsideCollaborators
									s.handleOrgsListOutsideCollaboratorsRequest(args, w, r)
									return
								}
							case 'p': // Prefix: "p"
								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"
									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePackagesListPackagesForOrganizationRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["package_type"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_name"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["package_name"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handlePackagesGetPackageForOrganizationRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/versions"
														if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "package_version_id"
															// Leaf parameter
															args["package_version_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: PackagesGetPackageVersionForOrganization
																s.handlePackagesGetPackageVersionForOrganizationRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "rojects"
									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ProjectsListForOrg
										s.handleProjectsListForOrgRequest(args, w, r)
										return
									}
								case 'u': // Prefix: "ublic_members"
									if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleOrgsListPublicMembersRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args["username"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: OrgsCheckPublicMembershipForUser
											s.handleOrgsCheckPublicMembershipForUserRequest(args, w, r)
											return
										}
									}
								}
							case 'r': // Prefix: "repos"
								if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposListForOrg
									s.handleReposListForOrgRequest(args, w, r)
									return
								}
							case 's': // Prefix: "se"
								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleSecretScanningListAlertsForOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'c': // Prefix: "cret-scanning/alerts"
									if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: SecretScanningListAlertsForOrg
										s.handleSecretScanningListAlertsForOrgRequest(args, w, r)
										return
									}
								case 't': // Prefix: "ttings/billing/"
									if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleBillingGetGithubPackagesBillingOrgRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"
										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubActionsBillingOrg
											s.handleBillingGetGithubActionsBillingOrgRequest(args, w, r)
											return
										}
									case 'p': // Prefix: "packages"
										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubPackagesBillingOrg
											s.handleBillingGetGithubPackagesBillingOrgRequest(args, w, r)
											return
										}
									case 's': // Prefix: "shared-storage"
										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetSharedStorageBillingOrg
											s.handleBillingGetSharedStorageBillingOrgRequest(args, w, r)
											return
										}
									}
								}
							case 't': // Prefix: "team"
								if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleTeamsListIdpGroupsForOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '-': // Prefix: "-sync/groups"
									if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: TeamsListIdpGroupsForOrg
										s.handleTeamsListIdpGroupsForOrgRequest(args, w, r)
										return
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleTeamsListRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "team_slug"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["team_slug"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleTeamsGetByNameRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleTeamsCheckPermissionsForProjectInOrgRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'd': // Prefix: "discussions"
													if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleTeamsListDiscussionsInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "discussion_number"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx > 0 {
															args["discussion_number"] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handleTeamsGetDiscussionInOrgRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReactionsListForTeamDiscussionInOrgRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case 'c': // Prefix: "comments"
																	if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleTeamsListDiscussionCommentsInOrgRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"
																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		// Param: "comment_number"
																		// Match until "/"
																		idx := strings.IndexByte(elem, '/')
																		if idx > 0 {
																			args["comment_number"] = elem[:idx]
																			elem = elem[idx:]

																			if len(elem) == 0 {
																				s.handleTeamsGetDiscussionCommentInOrgRequest(args, w, r)
																				return
																			}
																			switch elem[0] {
																			case '/': // Prefix: "/reactions"
																				if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					// Leaf: ReactionsListForTeamDiscussionCommentInOrg
																					s.handleReactionsListForTeamDiscussionCommentInOrgRequest(args, w, r)
																					return
																				}
																			}
																		}
																	}
																case 'r': // Prefix: "reactions"
																	if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReactionsListForTeamDiscussionInOrg
																		s.handleReactionsListForTeamDiscussionInOrgRequest(args, w, r)
																		return
																	}
																}
															}
														}
													}
												case 'i': // Prefix: "invitations"
													if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: TeamsListPendingInvitationsInOrg
														s.handleTeamsListPendingInvitationsInOrgRequest(args, w, r)
														return
													}
												case 'm': // Prefix: "members"
													if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleTeamsListMembersInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'h': // Prefix: "hips/"
														if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "username"
														// Leaf parameter
														args["username"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: TeamsGetMembershipForUserInOrg
															s.handleTeamsGetMembershipForUserInOrgRequest(args, w, r)
															return
														}
													}
												case 'p': // Prefix: "projects"
													if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleTeamsListProjectsInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "project_id"
														// Leaf parameter
														args["project_id"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: TeamsCheckPermissionsForProjectInOrg
															s.handleTeamsCheckPermissionsForProjectInOrgRequest(args, w, r)
															return
														}
													}
												case 'r': // Prefix: "repos"
													if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleTeamsListReposInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "owner"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx > 0 {
															args["owner"] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "repo"
																// Leaf parameter
																args["repo"] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf: TeamsCheckPermissionsForRepoInOrg
																	s.handleTeamsCheckPermissionsForRepoInOrgRequest(args, w, r)
																	return
																}
															}
														}
													}
												case 't': // Prefix: "team"
													if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleTeamsListIdpGroupsInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '-': // Prefix: "-sync/group-mappings"
														if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: TeamsListIdpGroupsInOrg
															s.handleTeamsListIdpGroupsInOrgRequest(args, w, r)
															return
														}
													case 's': // Prefix: "s"
														if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: TeamsListChildInOrg
															s.handleTeamsListChildInOrgRequest(args, w, r)
															return
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsGetColumnRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args["card_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsGetCard
							s.handleProjectsGetCardRequest(args, w, r)
							return
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["column_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleProjectsGetColumnRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/cards"
							if l := len("/cards"); len(elem) >= l && elem[0:l] == "/cards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsListCards
								s.handleProjectsListCardsRequest(args, w, r)
								return
							}
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["project_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleProjectsGetRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/col"
						if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleProjectsListColumnsRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'l': // Prefix: "laborators"
							if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleProjectsListCollaboratorsRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["username"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/permission"
										if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ProjectsGetPermissionForUser
											s.handleProjectsGetPermissionForUserRequest(args, w, r)
											return
										}
									}
								}
							}
						case 'u': // Prefix: "umns"
							if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsListColumns
								s.handleProjectsListColumnsRequest(args, w, r)
								return
							}
						}
					}
				}
			case 'r': // Prefix: "r"
				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleRateLimitGetRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"
					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: RateLimitGet
						s.handleRateLimitGetRequest(args, w, r)
						return
					}
				case 'e': // Prefix: "epos"
					if l := len("epos"); len(elem) >= l && elem[0:l] == "epos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActionsGetEnvironmentPublicKeyRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["owner"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["repo"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleReposGetRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActivityGetRepoSubscriptionRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'a': // Prefix: "a"
											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleIssuesCheckUserCanBeAssignedRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'c': // Prefix: "ctions/"
												if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsDownloadJobLogsForWorkflowRunRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'a': // Prefix: "artifacts"
													if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsListArtifactsForRepoRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "artifact_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx > 0 {
															args["artifact_id"] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handleActionsGetArtifactRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "archive_format"
																// Leaf parameter
																args["archive_format"] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf: ActionsDownloadArtifact
																	s.handleActionsDownloadArtifactRequest(args, w, r)
																	return
																}
															}
														}
													}
												case 'j': // Prefix: "jobs/"
													if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "job_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["job_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleActionsGetJobForWorkflowRunRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/logs"
															if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsDownloadJobLogsForWorkflowRun
																s.handleActionsDownloadJobLogsForWorkflowRunRequest(args, w, r)
																return
															}
														}
													}
												case 'p': // Prefix: "permissions"
													if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsGetGithubActionsPermissionsRepositoryRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/selected-actions"
														if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsGetAllowedActionsRepository
															s.handleActionsGetAllowedActionsRepositoryRequest(args, w, r)
															return
														}
													}
												case 'r': // Prefix: "run"
													if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsGetSelfHostedRunnerForRepoRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'n': // Prefix: "ners"
														if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsListSelfHostedRunnersForRepoRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'd': // Prefix: "downloads"
																if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsListRunnerApplicationsForRepo
																	s.handleActionsListRunnerApplicationsForRepoRequest(args, w, r)
																	return
																}
															}
															// Param: "runner_id"
															// Leaf parameter
															args["runner_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ActionsGetSelfHostedRunnerForRepo
																s.handleActionsGetSelfHostedRunnerForRepoRequest(args, w, r)
																return
															}
														}
													case 's': // Prefix: "s"
														if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsListWorkflowRunsForRepoRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "run_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["run_id"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	s.handleActionsGetWorkflowRunRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"
																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleActionsGetReviewsForRunRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "a"
																		if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			s.handleActionsListWorkflowRunArtifactsRequest(args, w, r)
																			return
																		}
																		switch elem[0] {
																		case 'p': // Prefix: "pprovals"
																			if l := len("pprovals"); len(elem) >= l && elem[0:l] == "pprovals" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ActionsGetReviewsForRun
																				s.handleActionsGetReviewsForRunRequest(args, w, r)
																				return
																			}
																		case 'r': // Prefix: "rtifacts"
																			if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ActionsListWorkflowRunArtifacts
																				s.handleActionsListWorkflowRunArtifactsRequest(args, w, r)
																				return
																			}
																		}
																	case 'j': // Prefix: "jobs"
																		if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ActionsListJobsForWorkflowRun
																			s.handleActionsListJobsForWorkflowRunRequest(args, w, r)
																			return
																		}
																	case 'l': // Prefix: "logs"
																		if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ActionsDownloadWorkflowRunLogs
																			s.handleActionsDownloadWorkflowRunLogsRequest(args, w, r)
																			return
																		}
																	case 't': // Prefix: "timing"
																		if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ActionsGetWorkflowRunUsage
																			s.handleActionsGetWorkflowRunUsageRequest(args, w, r)
																			return
																		}
																	}
																}
															}
														}
													}
												case 's': // Prefix: "secrets"
													if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsListRepoSecretsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsGetRepoSecretRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'p': // Prefix: "public-key"
															if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsGetRepoPublicKey
																s.handleActionsGetRepoPublicKeyRequest(args, w, r)
																return
															}
														}
														// Param: "secret_name"
														// Leaf parameter
														args["secret_name"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ActionsGetRepoSecret
															s.handleActionsGetRepoSecretRequest(args, w, r)
															return
														}
													}
												case 'w': // Prefix: "workflows"
													if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListRepoWorkflows
														s.handleActionsListRepoWorkflowsRequest(args, w, r)
														return
													}
												}
											case 's': // Prefix: "ssignees"
												if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesListAssigneesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "assignee"
													// Leaf parameter
													args["assignee"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: IssuesCheckUserCanBeAssigned
														s.handleIssuesCheckUserCanBeAssignedRequest(args, w, r)
														return
													}
												}
											case 'u': // Prefix: "utolinks"
												if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListAutolinksRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter
													args["autolink_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetAutolink
														s.handleReposGetAutolinkRequest(args, w, r)
														return
													}
												}
											}
										case 'b': // Prefix: "branches"
											if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListBranchesRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "branch"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["branch"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleReposGetBranchRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/protection"
														if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposGetBranchProtectionRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposGetAdminBranchProtectionRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'e': // Prefix: "enforce_admins"
																if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetAdminBranchProtection
																	s.handleReposGetAdminBranchProtectionRequest(args, w, r)
																	return
																}
															case 'r': // Prefix: "re"
																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposGetAllStatusCheckContextsRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case 'q': // Prefix: "quired_"
																	if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleReposGetPullRequestReviewProtectionRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case 'p': // Prefix: "pull_request_reviews"
																		if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReposGetPullRequestReviewProtection
																			s.handleReposGetPullRequestReviewProtectionRequest(args, w, r)
																			return
																		}
																	case 's': // Prefix: "s"
																		if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			s.handleReposGetCommitSignatureProtectionRequest(args, w, r)
																			return
																		}
																		switch elem[0] {
																		case 'i': // Prefix: "ignatures"
																			if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposGetCommitSignatureProtection
																				s.handleReposGetCommitSignatureProtectionRequest(args, w, r)
																				return
																			}
																		case 't': // Prefix: "tatus_checks"
																			if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				s.handleReposGetStatusChecksProtectionRequest(args, w, r)
																				return
																			}
																			switch elem[0] {
																			case '/': // Prefix: "/contexts"
																				if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					// Leaf: ReposGetAllStatusCheckContexts
																					s.handleReposGetAllStatusCheckContextsRequest(args, w, r)
																					return
																				}
																			}
																		}
																	}
																case 's': // Prefix: "strictions"
																	if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleReposGetAccessRestrictionsRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"
																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			s.handleReposGetTeamsWithAccessToProtectedBranchRequest(args, w, r)
																			return
																		}
																		switch elem[0] {
																		case 'a': // Prefix: "apps"
																			if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposGetAppsWithAccessToProtectedBranch
																				s.handleReposGetAppsWithAccessToProtectedBranchRequest(args, w, r)
																				return
																			}
																		case 't': // Prefix: "teams"
																			if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposGetTeamsWithAccessToProtectedBranch
																				s.handleReposGetTeamsWithAccessToProtectedBranchRequest(args, w, r)
																				return
																			}
																		case 'u': // Prefix: "users"
																			if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposGetUsersWithAccessToProtectedBranch
																				s.handleReposGetUsersWithAccessToProtectedBranchRequest(args, w, r)
																				return
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										case 'c': // Prefix: "c"
											if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleChecksListForRefRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'h': // Prefix: "heck-"
												if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleChecksGetSuiteRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'r': // Prefix: "runs/"
													if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "check_run_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["check_run_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleChecksGetRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/annotations"
															if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ChecksListAnnotations
																s.handleChecksListAnnotationsRequest(args, w, r)
																return
															}
														}
													}
												case 's': // Prefix: "suites/"
													if l := len("suites/"); len(elem) >= l && elem[0:l] == "suites/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "check_suite_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["check_suite_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleChecksGetSuiteRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/check-runs"
															if l := len("/check-runs"); len(elem) >= l && elem[0:l] == "/check-runs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ChecksListForSuite
																s.handleChecksListForSuiteRequest(args, w, r)
																return
															}
														}
													}
												}
											case 'o': // Prefix: "o"
												if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleCodeScanningGetAlertRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'd': // Prefix: "de-scanning/"
													if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleCodeScanningGetSarifRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'a': // Prefix: "a"
														if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleCodeScanningGetAnalysisRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'l': // Prefix: "lerts"
															if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleCodeScanningListAlertsForRepoRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "alert_number"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx > 0 {
																	args["alert_number"] = elem[:idx]
																	elem = elem[idx:]

																	if len(elem) == 0 {
																		s.handleCodeScanningGetAlertRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/instances"
																		if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: CodeScanningListAlertInstances
																			s.handleCodeScanningListAlertInstancesRequest(args, w, r)
																			return
																		}
																	}
																}
															}
														case 'n': // Prefix: "nalyses"
															if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleCodeScanningListRecentAnalysesRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "analysis_id"
																// Leaf parameter
																args["analysis_id"] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf: CodeScanningGetAnalysis
																	s.handleCodeScanningGetAnalysisRequest(args, w, r)
																	return
																}
															}
														}
													case 's': // Prefix: "sarifs/"
														if l := len("sarifs/"); len(elem) >= l && elem[0:l] == "sarifs/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "sarif_id"
														// Leaf parameter
														args["sarif_id"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: CodeScanningGetSarif
															s.handleCodeScanningGetSarifRequest(args, w, r)
															return
														}
													}
												case 'l': // Prefix: "llaborators"
													if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposListCollaboratorsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "username"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx > 0 {
															args["username"] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handleReposCheckCollaboratorRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/permission"
																if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetCollaboratorPermissionLevel
																	s.handleReposGetCollaboratorPermissionLevelRequest(args, w, r)
																	return
																}
															}
														}
													}
												case 'm': // Prefix: "m"
													if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposCompareCommitsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'm': // Prefix: "m"
														if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReactionsListForCommitCommentRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'e': // Prefix: "ents"
															if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposListCommitCommentsForRepoRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx > 0 {
																	args["comment_id"] = elem[:idx]
																	elem = elem[idx:]

																	if len(elem) == 0 {
																		s.handleReposGetCommitCommentRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/reactions"
																		if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ReactionsListForCommitComment
																			s.handleReactionsListForCommitCommentRequest(args, w, r)
																			return
																		}
																	}
																}
															}
														case 'i': // Prefix: "its"
															if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposListCommitsRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "ref"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx > 0 {
																	args["ref"] = elem[:idx]
																	elem = elem[idx:]

																	if len(elem) == 0 {
																		s.handleReposGetCommitRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"
																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			s.handleReposGetCombinedStatusForRefRequest(args, w, r)
																			return
																		}
																		switch elem[0] {
																		case 'b': // Prefix: "branches-where-head"
																			if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposListBranchesForHeadCommit
																				s.handleReposListBranchesForHeadCommitRequest(args, w, r)
																				return
																			}
																		case 'c': // Prefix: "c"
																			if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				s.handleReposListCommentsForCommitRequest(args, w, r)
																				return
																			}
																			switch elem[0] {
																			case 'h': // Prefix: "heck-"
																				if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					s.handleChecksListSuitesForRefRequest(args, w, r)
																					return
																				}
																				switch elem[0] {
																				case 'r': // Prefix: "runs"
																					if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																						elem = elem[l:]
																					} else {
																						break
																					}

																					if len(elem) == 0 {
																						// Leaf: ChecksListForRef
																						s.handleChecksListForRefRequest(args, w, r)
																						return
																					}
																				case 's': // Prefix: "suites"
																					if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																						elem = elem[l:]
																					} else {
																						break
																					}

																					if len(elem) == 0 {
																						// Leaf: ChecksListSuitesForRef
																						s.handleChecksListSuitesForRefRequest(args, w, r)
																						return
																					}
																				}
																			case 'o': // Prefix: "omments"
																				if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					// Leaf: ReposListCommentsForCommit
																					s.handleReposListCommentsForCommitRequest(args, w, r)
																					return
																				}
																			}
																		case 'p': // Prefix: "pulls"
																			if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf: ReposListPullRequestsAssociatedWithCommit
																				s.handleReposListPullRequestsAssociatedWithCommitRequest(args, w, r)
																				return
																			}
																		case 's': // Prefix: "status"
																			if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				s.handleReposGetCombinedStatusForRefRequest(args, w, r)
																				return
																			}
																			switch elem[0] {
																			case 'e': // Prefix: "es"
																				if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					// Leaf: ReposListCommitStatusesForRef
																					s.handleReposListCommitStatusesForRefRequest(args, w, r)
																					return
																				}
																			}
																		}
																	}
																}
															}
														case 'u': // Prefix: "unity/profile"
															if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposGetCommunityProfileMetrics
																s.handleReposGetCommunityProfileMetricsRequest(args, w, r)
																return
															}
														}
													case 'p': // Prefix: "pare/"
														if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "basehead"
														// Leaf parameter
														args["basehead"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ReposCompareCommits
															s.handleReposCompareCommitsRequest(args, w, r)
															return
														}
													}
												case 'n': // Prefix: "ntributors"
													if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposListContributors
														s.handleReposListContributorsRequest(args, w, r)
														return
													}
												}
											}
										case 'd': // Prefix: "deployments"
											if l := len("deployments"); len(elem) >= l && elem[0:l] == "deployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListDeploymentsRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "deployment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["deployment_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleReposGetDeploymentRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/statuses"
														if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposListDeploymentStatusesRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "status_id"
															// Leaf parameter
															args["status_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReposGetDeploymentStatus
																s.handleReposGetDeploymentStatusRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 'e': // Prefix: "events"
											if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListRepoEvents
												s.handleActivityListRepoEventsRequest(args, w, r)
												return
											}
										case 'f': // Prefix: "forks"
											if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListForks
												s.handleReposListForksRequest(args, w, r)
												return
											}
										case 'g': // Prefix: "git/"
											if l := len("git/"); len(elem) >= l && elem[0:l] == "git/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleGitGetCommitRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'b': // Prefix: "blobs/"
												if l := len("blobs/"); len(elem) >= l && elem[0:l] == "blobs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "file_sha"
												// Leaf parameter
												args["file_sha"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: GitGetBlob
													s.handleGitGetBlobRequest(args, w, r)
													return
												}
											case 'c': // Prefix: "commits/"
												if l := len("commits/"); len(elem) >= l && elem[0:l] == "commits/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "commit_sha"
												// Leaf parameter
												args["commit_sha"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: GitGetCommit
													s.handleGitGetCommitRequest(args, w, r)
													return
												}
											case 'm': // Prefix: "matching-refs/"
												if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args["ref"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: GitListMatchingRefs
													s.handleGitListMatchingRefsRequest(args, w, r)
													return
												}
											case 'r': // Prefix: "ref/"
												if l := len("ref/"); len(elem) >= l && elem[0:l] == "ref/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter
												args["ref"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: GitGetRef
													s.handleGitGetRefRequest(args, w, r)
													return
												}
											case 't': // Prefix: "t"
												if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleGitGetTreeRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'a': // Prefix: "ags/"
													if l := len("ags/"); len(elem) >= l && elem[0:l] == "ags/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tag_sha"
													// Leaf parameter
													args["tag_sha"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: GitGetTag
														s.handleGitGetTagRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "rees/"
													if l := len("rees/"); len(elem) >= l && elem[0:l] == "rees/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tree_sha"
													// Leaf parameter
													args["tree_sha"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: GitGetTree
														s.handleGitGetTreeRequest(args, w, r)
														return
													}
												}
											}
										case 'h': // Prefix: "hooks"
											if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListWebhooksRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "hook_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["hook_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleReposGetWebhookRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposGetWebhookDeliveryRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'c': // Prefix: "config"
															if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposGetWebhookConfigForRepo
																s.handleReposGetWebhookConfigForRepoRequest(args, w, r)
																return
															}
														case 'd': // Prefix: "deliveries"
															if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposListWebhookDeliveriesRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "delivery_id"
																// Leaf parameter
																args["delivery_id"] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf: ReposGetWebhookDelivery
																	s.handleReposGetWebhookDeliveryRequest(args, w, r)
																	return
																}
															}
														}
													}
												}
											}
										case 'i': // Prefix: "i"
											if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleMigrationsGetCommitAuthorsRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'm': // Prefix: "mport"
												if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleMigrationsGetImportStatusRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleMigrationsGetLargeFilesRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'a': // Prefix: "authors"
														if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: MigrationsGetCommitAuthors
															s.handleMigrationsGetCommitAuthorsRequest(args, w, r)
															return
														}
													case 'l': // Prefix: "large_files"
														if l := len("large_files"); len(elem) >= l && elem[0:l] == "large_files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: MigrationsGetLargeFiles
															s.handleMigrationsGetLargeFilesRequest(args, w, r)
															return
														}
													}
												}
											case 'n': // Prefix: "nvitations"
												if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposListInvitations
													s.handleReposListInvitationsRequest(args, w, r)
													return
												}
											case 's': // Prefix: "ssues"
												if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesListForRepoRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleIssuesListCommentsForRepoRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["comment_id"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	s.handleIssuesGetCommentRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/reactions"
																	if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReactionsListForIssueComment
																		s.handleReactionsListForIssueCommentRequest(args, w, r)
																		return
																	}
																}
															}
														}
													case 'e': // Prefix: "events"
														if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleIssuesListEventsForRepoRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "event_id"
															// Leaf parameter
															args["event_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: IssuesGetEvent
																s.handleIssuesGetEventRequest(args, w, r)
																return
															}
														}
													}
													// Param: "issue_number"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["issue_number"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleIssuesGetRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleIssuesListLabelsOnIssueRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'c': // Prefix: "comments"
																if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: IssuesListComments
																	s.handleIssuesListCommentsRequest(args, w, r)
																	return
																}
															case 'l': // Prefix: "labels"
																if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: IssuesListLabelsOnIssue
																	s.handleIssuesListLabelsOnIssueRequest(args, w, r)
																	return
																}
															case 'r': // Prefix: "reactions"
																if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReactionsListForIssue
																	s.handleReactionsListForIssueRequest(args, w, r)
																	return
																}
															}
														}
													}
												}
											}
										case 'k': // Prefix: "keys"
											if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListDeployKeysRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "key_id"
												// Leaf parameter
												args["key_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetDeployKey
													s.handleReposGetDeployKeyRequest(args, w, r)
													return
												}
											}
										case 'l': // Prefix: "l"
											if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleLicensesGetForRepoRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "a"
												if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListLanguagesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'b': // Prefix: "bels"
													if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleIssuesListLabelsForRepoRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "name"
														// Leaf parameter
														args["name"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: IssuesGetLabel
															s.handleIssuesGetLabelRequest(args, w, r)
															return
														}
													}
												case 'n': // Prefix: "nguages"
													if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposListLanguages
														s.handleReposListLanguagesRequest(args, w, r)
														return
													}
												}
											case 'i': // Prefix: "icense"
												if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: LicensesGetForRepo
													s.handleLicensesGetForRepoRequest(args, w, r)
													return
												}
											}
										case 'm': // Prefix: "milestones"
											if l := len("milestones"); len(elem) >= l && elem[0:l] == "milestones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleIssuesListMilestonesRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "milestone_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["milestone_number"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleIssuesGetMilestoneRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/labels"
														if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: IssuesListLabelsForMilestone
															s.handleIssuesListLabelsForMilestoneRequest(args, w, r)
															return
														}
													}
												}
											}
										case 'n': // Prefix: "notifications"
											if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListRepoNotificationsForAuthenticatedUser
												s.handleActivityListRepoNotificationsForAuthenticatedUserRequest(args, w, r)
												return
											}
										case 'p': // Prefix: "p"
											if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePullsCheckIfMergedRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "ages"
												if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposGetPagesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetPagesHealthCheckRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'b': // Prefix: "builds"
														if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposListPagesBuildsRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposGetPagesBuildRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'l': // Prefix: "latest"
																if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetLatestPagesBuild
																	s.handleReposGetLatestPagesBuildRequest(args, w, r)
																	return
																}
															}
															// Param: "build_id"
															// Leaf parameter
															args["build_id"] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf: ReposGetPagesBuild
																s.handleReposGetPagesBuildRequest(args, w, r)
																return
															}
														}
													case 'h': // Prefix: "health"
														if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetPagesHealthCheck
															s.handleReposGetPagesHealthCheckRequest(args, w, r)
															return
														}
													}
												}
											case 'r': // Prefix: "rojects"
												if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ProjectsListForRepo
													s.handleProjectsListForRepoRequest(args, w, r)
													return
												}
											case 'u': // Prefix: "ulls"
												if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePullsListRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePullsListReviewCommentsForRepoRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["comment_id"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	s.handlePullsGetReviewCommentRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/reactions"
																	if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReactionsListForPullRequestReviewComment
																		s.handleReactionsListForPullRequestReviewCommentRequest(args, w, r)
																		return
																	}
																}
															}
														}
													}
													// Param: "pull_number"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["pull_number"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handlePullsGetRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handlePullsGetReviewRequest(args, w, r)
																return
															}
															switch elem[0] {
															case 'c': // Prefix: "comm"
																if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handlePullsListReviewCommentsRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case 'e': // Prefix: "ents"
																	if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: PullsListReviewComments
																		s.handlePullsListReviewCommentsRequest(args, w, r)
																		return
																	}
																case 'i': // Prefix: "its"
																	if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: PullsListCommits
																		s.handlePullsListCommitsRequest(args, w, r)
																		return
																	}
																}
															case 'f': // Prefix: "files"
																if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: PullsListFiles
																	s.handlePullsListFilesRequest(args, w, r)
																	return
																}
															case 'm': // Prefix: "merge"
																if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: PullsCheckIfMerged
																	s.handlePullsCheckIfMergedRequest(args, w, r)
																	return
																}
															case 'r': // Prefix: "re"
																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handlePullsListRequestedReviewersRequest(args, w, r)
																	return
																}
																switch elem[0] {
																case 'q': // Prefix: "quested_reviewers"
																	if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: PullsListRequestedReviewers
																		s.handlePullsListRequestedReviewersRequest(args, w, r)
																		return
																	}
																case 'v': // Prefix: "views"
																	if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handlePullsListReviewsRequest(args, w, r)
																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"
																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		// Param: "review_id"
																		// Match until "/"
																		idx := strings.IndexByte(elem, '/')
																		if idx > 0 {
																			args["review_id"] = elem[:idx]
																			elem = elem[idx:]

																			if len(elem) == 0 {
																				s.handlePullsGetReviewRequest(args, w, r)
																				return
																			}
																			switch elem[0] {
																			case '/': // Prefix: "/comments"
																				if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
																					elem = elem[l:]
																				} else {
																					break
																				}

																				if len(elem) == 0 {
																					// Leaf: PullsListCommentsForReview
																					s.handlePullsListCommentsForReviewRequest(args, w, r)
																					return
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										case 'r': // Prefix: "re"
											if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetReadmeRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "adme"
												if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposGetReadmeRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "dir"
													// Leaf parameter
													args["dir"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetReadmeInDirectory
														s.handleReposGetReadmeInDirectoryRequest(args, w, r)
														return
													}
												}
											case 'l': // Prefix: "leases"
												if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListReleasesRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetReleaseRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'a': // Prefix: "assets/"
														if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "asset_id"
														// Leaf parameter
														args["asset_id"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ReposGetReleaseAsset
															s.handleReposGetReleaseAssetRequest(args, w, r)
															return
														}
													case 'l': // Prefix: "latest"
														if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetLatestRelease
															s.handleReposGetLatestReleaseRequest(args, w, r)
															return
														}
													case 't': // Prefix: "tags/"
														if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tag"
														// Leaf parameter
														args["tag"] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: ReposGetReleaseByTag
															s.handleReposGetReleaseByTagRequest(args, w, r)
															return
														}
													}
													// Param: "release_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["release_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleReposGetReleaseRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/assets"
															if l := len("/assets"); len(elem) >= l && elem[0:l] == "/assets" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposListReleaseAssets
																s.handleReposListReleaseAssetsRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetCodeFrequencyStatsRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'e': // Prefix: "ecret-scanning/alerts"
												if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleSecretScanningListAlertsForRepoRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "alert_number"
													// Leaf parameter
													args["alert_number"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: SecretScanningGetAlert
														s.handleSecretScanningGetAlertRequest(args, w, r)
														return
													}
												}
											case 't': // Prefix: "tats/"
												if l := len("tats/"); len(elem) >= l && elem[0:l] == "tats/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposGetParticipationStatsRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'c': // Prefix: "co"
													if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetCommitActivityStatsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'd': // Prefix: "de_frequency"
														if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetCodeFrequencyStats
															s.handleReposGetCodeFrequencyStatsRequest(args, w, r)
															return
														}
													case 'm': // Prefix: "mmit_activity"
														if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetCommitActivityStats
															s.handleReposGetCommitActivityStatsRequest(args, w, r)
															return
														}
													case 'n': // Prefix: "ntributors"
														if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetContributorsStats
															s.handleReposGetContributorsStatsRequest(args, w, r)
															return
														}
													}
												case 'p': // Prefix: "p"
													if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetPunchCardStatsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'a': // Prefix: "articipation"
														if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetParticipationStats
															s.handleReposGetParticipationStatsRequest(args, w, r)
															return
														}
													case 'u': // Prefix: "unch_card"
														if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetPunchCardStats
															s.handleReposGetPunchCardStatsRequest(args, w, r)
															return
														}
													}
												}
											case 'u': // Prefix: "ubscri"
												if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActivityListWatchersForRepoRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'b': // Prefix: "bers"
													if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActivityListWatchersForRepo
														s.handleActivityListWatchersForRepoRequest(args, w, r)
														return
													}
												case 'p': // Prefix: "ption"
													if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActivityGetRepoSubscription
														s.handleActivityGetRepoSubscriptionRequest(args, w, r)
														return
													}
												}
											}
										case 't': // Prefix: "t"
											if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetAllTopicsRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "a"
												if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListTagsRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'g': // Prefix: "gs"
													if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposListTags
														s.handleReposListTagsRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "rball/"
													if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ref"
													// Leaf parameter
													args["ref"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposDownloadTarballArchive
														s.handleReposDownloadTarballArchiveRequest(args, w, r)
														return
													}
												}
											case 'e': // Prefix: "eams"
												if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposListTeams
													s.handleReposListTeamsRequest(args, w, r)
													return
												}
											case 'o': // Prefix: "opics"
												if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetAllTopics
													s.handleReposGetAllTopicsRequest(args, w, r)
													return
												}
											case 'r': // Prefix: "raffic/"
												if l := len("raffic/"); len(elem) >= l && elem[0:l] == "raffic/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposGetTopPathsRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'c': // Prefix: "clones"
													if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetClones
														s.handleReposGetClonesRequest(args, w, r)
														return
													}
												case 'p': // Prefix: "popular/"
													if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetTopReferrersRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'p': // Prefix: "paths"
														if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetTopPaths
															s.handleReposGetTopPathsRequest(args, w, r)
															return
														}
													case 'r': // Prefix: "referrers"
														if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetTopReferrers
															s.handleReposGetTopReferrersRequest(args, w, r)
															return
														}
													}
												case 'v': // Prefix: "views"
													if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetViews
														s.handleReposGetViewsRequest(args, w, r)
														return
													}
												}
											}
										case 'v': // Prefix: "vulnerability-alerts"
											if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposCheckVulnerabilityAlerts
												s.handleReposCheckVulnerabilityAlertsRequest(args, w, r)
												return
											}
										case 'z': // Prefix: "zipball/"
											if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "ref"
											// Leaf parameter
											args["ref"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDownloadZipballArchive
												s.handleReposDownloadZipballArchiveRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					case 'i': // Prefix: "itories"
						if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleReposListPublicRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["repository_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/environments/"
									if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["environment_name"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/secrets"
											if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListEnvironmentSecretsRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsGetEnvironmentSecretRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'p': // Prefix: "public-key"
													if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsGetEnvironmentPublicKey
														s.handleActionsGetEnvironmentPublicKeyRequest(args, w, r)
														return
													}
												}
												// Param: "secret_name"
												// Leaf parameter
												args["secret_name"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsGetEnvironmentSecret
													s.handleActionsGetEnvironmentSecretRequest(args, w, r)
													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleSearchCodeRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/enterprises/"
					if l := len("cim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "cim/v2/enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["enterprise"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups"
								if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_group_id"
									// Leaf parameter
									args["scim_group_id"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseGroup
										s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(args, w, r)
										return
									}
								}
							case 'U': // Prefix: "Users"
								if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_user_id"
									// Leaf parameter
									args["scim_user_id"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseUser
										s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleSearchIssuesAndPullRequestsRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'c': // Prefix: "co"
						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleSearchCommitsRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'd': // Prefix: "de"
							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCode
								s.handleSearchCodeRequest(args, w, r)
								return
							}
						case 'm': // Prefix: "mmits"
							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCommits
								s.handleSearchCommitsRequest(args, w, r)
								return
							}
						}
					case 'i': // Prefix: "issues"
						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchIssuesAndPullRequests
							s.handleSearchIssuesAndPullRequestsRequest(args, w, r)
							return
						}
					case 'l': // Prefix: "labels"
						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchLabels
							s.handleSearchLabelsRequest(args, w, r)
							return
						}
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchRepos
							s.handleSearchReposRequest(args, w, r)
							return
						}
					case 't': // Prefix: "topics"
						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchTopics
							s.handleSearchTopicsRequest(args, w, r)
							return
						}
					case 'u': // Prefix: "users"
						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchUsers
							s.handleSearchUsersRequest(args, w, r)
							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["team_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleTeamsGetLegacyRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsCheckPermissionsForProjectLegacyRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'd': // Prefix: "discussions"
							if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListDiscussionsLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "discussion_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["discussion_number"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleTeamsGetDiscussionLegacyRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReactionsListForTeamDiscussionLegacyRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'c': // Prefix: "comments"
											if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListDiscussionCommentsLegacyRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["comment_number"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleTeamsGetDiscussionCommentLegacyRequest(args, w, r)
														return
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForTeamDiscussionCommentLegacy
															s.handleReactionsListForTeamDiscussionCommentLegacyRequest(args, w, r)
															return
														}
													}
												}
											}
										case 'r': // Prefix: "reactions"
											if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsListForTeamDiscussionLegacy
												s.handleReactionsListForTeamDiscussionLegacyRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "invitations"
							if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsListPendingInvitationsLegacy
								s.handleTeamsListPendingInvitationsLegacyRequest(args, w, r)
								return
							}
						case 'm': // Prefix: "members"
							if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListMembersLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsGetMemberLegacy
									s.handleTeamsGetMemberLegacyRequest(args, w, r)
									return
								}
							case 'h': // Prefix: "hips/"
								if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsGetMembershipForUserLegacy
									s.handleTeamsGetMembershipForUserLegacyRequest(args, w, r)
									return
								}
							}
						case 'p': // Prefix: "projects"
							if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListProjectsLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Leaf parameter
								args["project_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsCheckPermissionsForProjectLegacy
									s.handleTeamsCheckPermissionsForProjectLegacyRequest(args, w, r)
									return
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListReposLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["owner"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repo"
										// Leaf parameter
										args["repo"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: TeamsCheckPermissionsForRepoLegacy
											s.handleTeamsCheckPermissionsForRepoLegacyRequest(args, w, r)
											return
										}
									}
								}
							}
						case 't': // Prefix: "team"
							if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListIdpGroupsForLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '-': // Prefix: "-sync/group-mappings"
								if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsListIdpGroupsForLegacy
									s.handleTeamsListIdpGroupsForLegacyRequest(args, w, r)
									return
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsListChildLegacy
									s.handleTeamsListChildLegacyRequest(args, w, r)
									return
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleUsersGetAuthenticatedRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsListInstallationReposForAuthenticatedUserRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"
						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListBlockedByAuthenticatedRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersCheckBlocked
								s.handleUsersCheckBlockedRequest(args, w, r)
								return
							}
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersListEmailsForAuthenticated
							s.handleUsersListEmailsForAuthenticatedRequest(args, w, r)
							return
						}
					case 'f': // Prefix: "follow"
						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListFollowersForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"
							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListFollowersForAuthenticatedUser
								s.handleUsersListFollowersForAuthenticatedUserRequest(args, w, r)
								return
							}
						case 'i': // Prefix: "ing"
							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleUsersListFollowedByAuthenticatedRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: UsersCheckPersonIsFollowedByAuthenticated
									s.handleUsersCheckPersonIsFollowedByAuthenticatedRequest(args, w, r)
									return
								}
							}
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListGpgKeysForAuthenticatedRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter
							args["gpg_key_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetGpgKeyForAuthenticated
								s.handleUsersGetGpgKeyForAuthenticatedRequest(args, w, r)
								return
							}
						}
					case 'i': // Prefix: "i"
						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleIssuesListForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'n': // Prefix: "nstallations/"
							if l := len("nstallations/"); len(elem) >= l && elem[0:l] == "nstallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["installation_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories"
									if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsListInstallationReposForAuthenticatedUser
										s.handleAppsListInstallationReposForAuthenticatedUserRequest(args, w, r)
										return
									}
								}
							}
						case 's': // Prefix: "ssues"
							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: IssuesListForAuthenticatedUser
								s.handleIssuesListForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListPublicSSHKeysForAuthenticatedRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter
							args["key_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetPublicSSHKeyForAuthenticated
								s.handleUsersGetPublicSSHKeyForAuthenticatedRequest(args, w, r)
								return
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleMigrationsGetArchiveForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"
							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListSubscriptionsForAuthenticatedUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"
								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListSubscriptionsForAuthenticatedUserStubbed
									s.handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(args, w, r)
									return
								}
							}
						case 'e': // Prefix: "emberships/orgs"
							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsListMembershipsForAuthenticatedUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter
								args["org"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsGetMembershipForAuthenticatedUser
									s.handleOrgsGetMembershipForAuthenticatedUserRequest(args, w, r)
									return
								}
							}
						case 'i': // Prefix: "igrations"
							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleMigrationsListForAuthenticatedUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["migration_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleMigrationsGetStatusForAuthenticatedUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleMigrationsListReposForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsGetArchiveForAuthenticatedUser
												s.handleMigrationsGetArchiveForAuthenticatedUserRequest(args, w, r)
												return
											}
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsListReposForUser
												s.handleMigrationsListReposForUserRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					case 'o': // Prefix: "orgs"
						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: OrgsListForAuthenticatedUser
							s.handleOrgsListForAuthenticatedUserRequest(args, w, r)
							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListPublicEmailsForAuthenticatedRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"
							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handlePackagesListPackagesForAuthenticatedUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["package_type"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["package_name"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handlePackagesGetPackageForAuthenticatedUserRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/versions"
												if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Leaf parameter
													args["package_version_id"] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: PackagesGetPackageVersionForAuthenticatedUser
														s.handlePackagesGetPackageVersionForAuthenticatedUserRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								}
							}
						case 'u': // Prefix: "ublic_emails"
							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListPublicEmailsForAuthenticated
								s.handleUsersListPublicEmailsForAuthenticatedRequest(args, w, r)
								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleReposListForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"
							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposListInvitationsForAuthenticatedUser
								s.handleReposListInvitationsForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					case 's': // Prefix: "s"
						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActivityListWatchedReposForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"
							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActivityListReposStarredByAuthenticatedUserRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["owner"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repo"
										// Leaf parameter
										args["repo"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActivityCheckRepoIsStarredByAuthenticatedUser
											s.handleActivityCheckRepoIsStarredByAuthenticatedUserRequest(args, w, r)
											return
										}
									}
								}
							}
						case 'u': // Prefix: "ubscriptions"
							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListWatchedReposForAuthenticatedUser
								s.handleActivityListWatchedReposForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsListForAuthenticatedUser
							s.handleTeamsListForAuthenticatedUserRequest(args, w, r)
							return
						}
					}
				case 's': // Prefix: "s"
					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleUsersListRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["username"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleUsersGetByUsernameRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActivityListReceivedEventsForUserRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'e': // Prefix: "events"
									if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActivityListEventsForAuthenticatedUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActivityListPublicEventsForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'o': // Prefix: "orgs/"
											if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "org"
											// Leaf parameter
											args["org"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActivityListOrgEventsForAuthenticatedUser
												s.handleActivityListOrgEventsForAuthenticatedUserRequest(args, w, r)
												return
											}
										case 'p': // Prefix: "public"
											if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListPublicEventsForUser
												s.handleActivityListPublicEventsForUserRequest(args, w, r)
												return
											}
										}
									}
								case 'f': // Prefix: "follow"
									if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleUsersListFollowersForUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "ers"
										if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: UsersListFollowersForUser
											s.handleUsersListFollowersForUserRequest(args, w, r)
											return
										}
									case 'i': // Prefix: "ing"
										if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleUsersListFollowingForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "target_user"
											// Leaf parameter
											args["target_user"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: UsersCheckFollowingForUser
												s.handleUsersCheckFollowingForUserRequest(args, w, r)
												return
											}
										}
									}
								case 'g': // Prefix: "g"
									if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleUsersListGpgKeysForUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'i': // Prefix: "ists"
										if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GistsListForUser
											s.handleGistsListForUserRequest(args, w, r)
											return
										}
									case 'p': // Prefix: "pg_keys"
										if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: UsersListGpgKeysForUser
											s.handleUsersListGpgKeysForUserRequest(args, w, r)
											return
										}
									}
								case 'h': // Prefix: "hovercard"
									if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersGetContextForUser
										s.handleUsersGetContextForUserRequest(args, w, r)
										return
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersListPublicKeysForUser
										s.handleUsersListPublicKeysForUserRequest(args, w, r)
										return
									}
								case 'o': // Prefix: "orgs"
									if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: OrgsListForUser
										s.handleOrgsListForUserRequest(args, w, r)
										return
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleProjectsListForUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'a': // Prefix: "ackages"
										if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handlePackagesListPackagesForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_type"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["package_type"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_name"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["package_name"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handlePackagesGetPackageForUserRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/versions"
															if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(args, w, r)
																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"
																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "package_version_id"
																// Leaf parameter
																args["package_version_id"] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf: PackagesGetPackageVersionForUser
																	s.handlePackagesGetPackageVersionForUserRequest(args, w, r)
																	return
																}
															}
														}
													}
												}
											}
										}
									case 'r': // Prefix: "rojects"
										if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ProjectsListForUser
											s.handleProjectsListForUserRequest(args, w, r)
											return
										}
									}
								case 'r': // Prefix: "re"
									if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposListForUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'c': // Prefix: "ceived_events"
										if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActivityListReceivedEventsForUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/public"
											if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListReceivedPublicEventsForUser
												s.handleActivityListReceivedPublicEventsForUserRequest(args, w, r)
												return
											}
										}
									case 'p': // Prefix: "pos"
										if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposListForUser
											s.handleReposListForUserRequest(args, w, r)
											return
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleBillingGetGithubActionsBillingUserRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "ettings/billing/"
										if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleBillingGetGithubPackagesBillingUserRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'a': // Prefix: "actions"
											if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: BillingGetGithubActionsBillingUser
												s.handleBillingGetGithubActionsBillingUserRequest(args, w, r)
												return
											}
										case 'p': // Prefix: "packages"
											if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: BillingGetGithubPackagesBillingUser
												s.handleBillingGetGithubPackagesBillingUserRequest(args, w, r)
												return
											}
										case 's': // Prefix: "shared-storage"
											if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: BillingGetSharedStorageBillingUser
												s.handleBillingGetSharedStorageBillingUserRequest(args, w, r)
												return
											}
										}
									case 'u': // Prefix: "ubscriptions"
										if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityListReposWatchedByUser
											s.handleActivityListReposWatchedByUserRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case "PATCH":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActivityMarkThreadAsReadRequest(args, w, r)
				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsUpdateAuthorizationRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsUpdateWebhookConfigForAppRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/config"
						if l := len("/hook/config"); len(elem) >= l && elem[0:l] == "/hook/config" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: AppsUpdateWebhookConfigForApp
							s.handleAppsUpdateWebhookConfigForAppRequest(args, w, r)
							return
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["client_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/token"
								if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsResetToken
									s.handleAppsResetTokenRequest(args, w, r)
									return
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args["authorization_id"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsUpdateAuthorization
						s.handleOAuthAuthorizationsUpdateAuthorizationRequest(args, w, r)
						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/actions/runner-groups/"
						if l := len("/actions/runner-groups/"); len(elem) >= l && elem[0:l] == "/actions/runner-groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "runner_group_id"
						// Leaf parameter
						args["runner_group_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise
							s.handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(args, w, r)
							return
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["gist_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/comments/"
						if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "comment_id"
						// Leaf parameter
						args["comment_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GistsUpdateComment
							s.handleGistsUpdateCommentRequest(args, w, r)
							return
						}
					}
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Leaf parameter
				args["thread_id"] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ActivityMarkThreadAsRead
					s.handleActivityMarkThreadAsReadRequest(args, w, r)
					return
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["org"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOrgsUpdateWebhookRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "actions/runner-groups/"
							if l := len("actions/runner-groups/"); len(elem) >= l && elem[0:l] == "actions/runner-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Leaf parameter
							args["runner_group_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActionsUpdateSelfHostedRunnerGroupForOrg
								s.handleActionsUpdateSelfHostedRunnerGroupForOrgRequest(args, w, r)
								return
							}
						case 'h': // Prefix: "hooks/"
							if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["hook_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleOrgsUpdateWebhookRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/config"
									if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: OrgsUpdateWebhookConfigForOrg
										s.handleOrgsUpdateWebhookConfigForOrgRequest(args, w, r)
										return
									}
								}
							}
						case 't': // Prefix: "teams/"
							if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "team_slug"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["team_slug"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsUpdateInOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleTeamsUpdateDiscussionCommentInOrgRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'd': // Prefix: "discussions/"
										if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "discussion_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["discussion_number"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleTeamsUpdateDiscussionInOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/comments/"
												if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_number"
												// Leaf parameter
												args["comment_number"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsUpdateDiscussionCommentInOrg
													s.handleTeamsUpdateDiscussionCommentInOrgRequest(args, w, r)
													return
												}
											}
										}
									case 't': // Prefix: "team-sync/group-mappings"
										if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsInOrg
											s.handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsUpdateColumnRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args["card_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsUpdateCard
							s.handleProjectsUpdateCardRequest(args, w, r)
							return
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args["column_id"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsUpdateColumn
						s.handleProjectsUpdateColumnRequest(args, w, r)
						return
					}
				}
				// Param: "project_id"
				// Leaf parameter
				args["project_id"] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ProjectsUpdate
					s.handleProjectsUpdateRequest(args, w, r)
					return
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["owner"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["repo"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleReposUpdateRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleGitUpdateRefRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'b': // Prefix: "branches/"
									if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "branch"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["branch"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/protection/required_"
											if l := len("/protection/required_"); len(elem) >= l && elem[0:l] == "/protection/required_" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposUpdateStatusCheckProtectionRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'p': // Prefix: "pull_request_reviews"
												if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposUpdatePullRequestReviewProtection
													s.handleReposUpdatePullRequestReviewProtectionRequest(args, w, r)
													return
												}
											case 's': // Prefix: "status_checks"
												if l := len("status_checks"); len(elem) >= l && elem[0:l] == "status_checks" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposUpdateStatusCheckProtection
													s.handleReposUpdateStatusCheckProtectionRequest(args, w, r)
													return
												}
											}
										}
									}
								case 'c': // Prefix: "c"
									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleCodeScanningUpdateAlertRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'h': // Prefix: "heck-suites/preferences"
										if l := len("heck-suites/preferences"); len(elem) >= l && elem[0:l] == "heck-suites/preferences" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ChecksSetSuitesPreferences
											s.handleChecksSetSuitesPreferencesRequest(args, w, r)
											return
										}
									case 'o': // Prefix: "o"
										if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposUpdateCommitCommentRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'd': // Prefix: "de-scanning/alerts/"
											if l := len("de-scanning/alerts/"); len(elem) >= l && elem[0:l] == "de-scanning/alerts/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "alert_number"
											// Leaf parameter
											args["alert_number"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: CodeScanningUpdateAlert
												s.handleCodeScanningUpdateAlertRequest(args, w, r)
												return
											}
										case 'm': // Prefix: "mments/"
											if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Leaf parameter
											args["comment_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposUpdateCommitComment
												s.handleReposUpdateCommitCommentRequest(args, w, r)
												return
											}
										}
									}
								case 'g': // Prefix: "git/refs/"
									if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "ref"
									// Leaf parameter
									args["ref"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: GitUpdateRef
										s.handleGitUpdateRefRequest(args, w, r)
										return
									}
								case 'h': // Prefix: "hooks/"
									if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["hook_id"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleReposUpdateWebhookRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/config"
											if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposUpdateWebhookConfigForRepo
												s.handleReposUpdateWebhookConfigForRepoRequest(args, w, r)
												return
											}
										}
									}
								case 'i': // Prefix: "i"
									if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleMigrationsMapCommitAuthorRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'm': // Prefix: "mport"
										if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleMigrationsUpdateImportRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleMigrationsSetLfsPreferenceRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "authors/"
												if l := len("authors/"); len(elem) >= l && elem[0:l] == "authors/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "author_id"
												// Leaf parameter
												args["author_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: MigrationsMapCommitAuthor
													s.handleMigrationsMapCommitAuthorRequest(args, w, r)
													return
												}
											case 'l': // Prefix: "lfs"
												if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsSetLfsPreference
													s.handleMigrationsSetLfsPreferenceRequest(args, w, r)
													return
												}
											}
										}
									case 'n': // Prefix: "nvitations/"
										if l := len("nvitations/"); len(elem) >= l && elem[0:l] == "nvitations/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "invitation_id"
										// Leaf parameter
										args["invitation_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposUpdateInvitation
											s.handleReposUpdateInvitationRequest(args, w, r)
											return
										}
									case 's': // Prefix: "ssues/"
										if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Leaf parameter
											args["comment_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: IssuesUpdateComment
												s.handleIssuesUpdateCommentRequest(args, w, r)
												return
											}
										}
										// Param: "issue_number"
										// Leaf parameter
										args["issue_number"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: IssuesUpdate
											s.handleIssuesUpdateRequest(args, w, r)
											return
										}
									}
								case 'l': // Prefix: "labels/"
									if l := len("labels/"); len(elem) >= l && elem[0:l] == "labels/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "name"
									// Leaf parameter
									args["name"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesUpdateLabel
										s.handleIssuesUpdateLabelRequest(args, w, r)
										return
									}
								case 'm': // Prefix: "milestones/"
									if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "milestone_number"
									// Leaf parameter
									args["milestone_number"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesUpdateMilestone
										s.handleIssuesUpdateMilestoneRequest(args, w, r)
										return
									}
								case 'p': // Prefix: "pulls/"
									if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "comments/"
										if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter
										args["comment_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: PullsUpdateReviewComment
											s.handlePullsUpdateReviewCommentRequest(args, w, r)
											return
										}
									}
									// Param: "pull_number"
									// Leaf parameter
									args["pull_number"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: PullsUpdate
										s.handlePullsUpdateRequest(args, w, r)
										return
									}
								case 'r': // Prefix: "releases/"
									if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "assets/"
										if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "asset_id"
										// Leaf parameter
										args["asset_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposUpdateReleaseAsset
											s.handleReposUpdateReleaseAssetRequest(args, w, r)
											return
										}
									}
									// Param: "release_id"
									// Leaf parameter
									args["release_id"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposUpdateRelease
										s.handleReposUpdateReleaseRequest(args, w, r)
										return
									}
								case 's': // Prefix: "secret-scanning/alerts/"
									if l := len("secret-scanning/alerts/"); len(elem) >= l && elem[0:l] == "secret-scanning/alerts/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "alert_number"
									// Leaf parameter
									args["alert_number"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: SecretScanningUpdateAlert
										s.handleSecretScanningUpdateAlertRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups/"
							if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_group_id"
							// Leaf parameter
							args["scim_group_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseGroup
								s.handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(args, w, r)
								return
							}
						case 'U': // Prefix: "Users/"
							if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args["scim_user_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseUser
								s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args, w, r)
								return
							}
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["team_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleTeamsUpdateLegacyRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsUpdateDiscussionCommentLegacyRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'd': // Prefix: "discussions/"
							if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["discussion_number"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsUpdateDiscussionLegacyRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/comments/"
									if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Leaf parameter
									args["comment_number"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsUpdateDiscussionCommentLegacy
										s.handleTeamsUpdateDiscussionCommentLegacyRequest(args, w, r)
										return
									}
								}
							}
						case 't': // Prefix: "team-sync/group-mappings"
							if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsLegacy
								s.handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(args, w, r)
								return
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleUsersUpdateAuthenticatedRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleReposAcceptInvitationRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'e': // Prefix: "email/visibility"
						if l := len("email/visibility"); len(elem) >= l && elem[0:l] == "email/visibility" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersSetPrimaryEmailVisibilityForAuthenticated
							s.handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(args, w, r)
							return
						}
					case 'm': // Prefix: "memberships/orgs/"
						if l := len("memberships/orgs/"); len(elem) >= l && elem[0:l] == "memberships/orgs/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Leaf parameter
						args["org"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsUpdateMembershipForAuthenticatedUser
							s.handleOrgsUpdateMembershipForAuthenticatedUserRequest(args, w, r)
							return
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args["invitation_id"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposAcceptInvitation
							s.handleReposAcceptInvitationRequest(args, w, r)
							return
						}
					}
				}
			}
		}
	case "POST":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsCreateRegistrationTokenForOrgRequest(args, w, r)
				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsCreateAuthorizationRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsCreateInstallationAccessTokenRequest(args, w, r)
						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsRedeliverWebhookDeliveryRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/deliveries/"
							if l := len("hook/deliveries/"); len(elem) >= l && elem[0:l] == "hook/deliveries/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "delivery_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["delivery_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/attempts"
									if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsRedeliverWebhookDelivery
										s.handleAppsRedeliverWebhookDeliveryRequest(args, w, r)
										return
									}
								}
							}
						case 'i': // Prefix: "installations/"
							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["installation_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/access_tokens"
									if l := len("/access_tokens"); len(elem) >= l && elem[0:l] == "/access_tokens" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsCreateInstallationAccessToken
										s.handleAppsCreateInstallationAccessTokenRequest(args, w, r)
										return
									}
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["client_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/token"
								if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleAppsCheckTokenRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/scoped"
									if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsScopeToken
										s.handleAppsScopeTokenRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsCreateAuthorization
						s.handleOAuthAuthorizationsCreateAuthorizationRequest(args, w, r)
						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/actions/runner"
						if l := len("/actions/runner"); len(elem) >= l && elem[0:l] == "/actions/runner" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '-': // Prefix: "-groups"
							if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
								s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args, w, r)
								return
							}
						case 's': // Prefix: "s/re"
							if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'g': // Prefix: "gistration-token"
								if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminCreateRegistrationTokenForEnterprise
									s.handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(args, w, r)
									return
								}
							case 'm': // Prefix: "move-token"
								if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminCreateRemoveTokenForEnterprise
									s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args, w, r)
									return
								}
							}
						}
					}
				}
			case 'g': // Prefix: "gists"
				if l := len("gists"); len(elem) >= l && elem[0:l] == "gists" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleGistsCreateRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "gist_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["gist_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleGistsForkRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'c': // Prefix: "comments"
								if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsCreateComment
									s.handleGistsCreateCommentRequest(args, w, r)
									return
								}
							case 'f': // Prefix: "forks"
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsFork
									s.handleGistsForkRequest(args, w, r)
									return
								}
							}
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["org"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleMigrationsStartForOrgRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "actions/runner"
							if l := len("actions/runner"); len(elem) >= l && elem[0:l] == "actions/runner" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '-': // Prefix: "-groups"
								if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActionsCreateSelfHostedRunnerGroupForOrg
									s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args, w, r)
									return
								}
							case 's': // Prefix: "s/re"
								if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsCreateRemoveTokenForOrgRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'g': // Prefix: "gistration-token"
									if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActionsCreateRegistrationTokenForOrg
										s.handleActionsCreateRegistrationTokenForOrgRequest(args, w, r)
										return
									}
								case 'm': // Prefix: "move-token"
									if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActionsCreateRemoveTokenForOrg
										s.handleActionsCreateRemoveTokenForOrgRequest(args, w, r)
										return
									}
								}
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsCreateWebhookRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["hook_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleOrgsRedeliverWebhookDeliveryRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'd': // Prefix: "deliveries/"
											if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "delivery_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["delivery_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/attempts"
													if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: OrgsRedeliverWebhookDelivery
														s.handleOrgsRedeliverWebhookDeliveryRequest(args, w, r)
														return
													}
												}
											}
										case 'p': // Prefix: "pings"
											if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: OrgsPingWebhook
												s.handleOrgsPingWebhookRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "invitations"
							if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsCreateInvitation
								s.handleOrgsCreateInvitationRequest(args, w, r)
								return
							}
						case 'm': // Prefix: "migrations"
							if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: MigrationsStartForOrg
								s.handleMigrationsStartForOrgRequest(args, w, r)
								return
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleProjectsCreateForOrgRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages/"
								if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["package_type"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["package_name"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePackagesRestorePackageVersionForOrgRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"
													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PackagesRestorePackageForOrg
														s.handlePackagesRestorePackageForOrgRequest(args, w, r)
														return
													}
												case 'v': // Prefix: "versions/"
													if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["package_version_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"
															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: PackagesRestorePackageVersionForOrg
																s.handlePackagesRestorePackageVersionForOrgRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										}
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsCreateForOrg
									s.handleProjectsCreateForOrgRequest(args, w, r)
									return
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposCreateInOrg
								s.handleReposCreateInOrgRequest(args, w, r)
								return
							}
						case 't': // Prefix: "teams"
							if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsCreateRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "team_slug"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["team_slug"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/discussions"
										if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleTeamsCreateDiscussionInOrgRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "discussion_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["discussion_number"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReactionsCreateForTeamDiscussionInOrgRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleTeamsCreateDiscussionCommentInOrgRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["comment_number"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/reactions"
																	if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReactionsCreateForTeamDiscussionCommentInOrg
																		s.handleReactionsCreateForTeamDiscussionCommentInOrgRequest(args, w, r)
																		return
																	}
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsCreateForTeamDiscussionInOrg
															s.handleReactionsCreateForTeamDiscussionInOrgRequest(args, w, r)
															return
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsMoveColumnRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["card_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/moves"
								if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsMoveCard
									s.handleProjectsMoveCardRequest(args, w, r)
									return
								}
							}
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["column_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"
							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsMoveColumn
								s.handleProjectsMoveColumnRequest(args, w, r)
								return
							}
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["project_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/columns"
						if l := len("/columns"); len(elem) >= l && elem[0:l] == "/columns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsCreateColumn
							s.handleProjectsCreateColumnRequest(args, w, r)
							return
						}
					}
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["owner"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["repo"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleAppsCreateContentAttachmentRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'a': // Prefix: "a"
									if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateAutolinkRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'c': // Prefix: "ctions/run"
										if l := len("ctions/run"); len(elem) >= l && elem[0:l] == "ctions/run" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsCreateRegistrationTokenForRepoRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'n': // Prefix: "ners/re"
											if l := len("ners/re"); len(elem) >= l && elem[0:l] == "ners/re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsCreateRemoveTokenForRepoRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'g': // Prefix: "gistration-token"
												if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsCreateRegistrationTokenForRepo
													s.handleActionsCreateRegistrationTokenForRepoRequest(args, w, r)
													return
												}
											case 'm': // Prefix: "move-token"
												if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsCreateRemoveTokenForRepo
													s.handleActionsCreateRemoveTokenForRepoRequest(args, w, r)
													return
												}
											}
										case 's': // Prefix: "s/"
											if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "run_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["run_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleActionsCancelWorkflowRunRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'a': // Prefix: "approve"
														if l := len("approve"); len(elem) >= l && elem[0:l] == "approve" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsApproveWorkflowRun
															s.handleActionsApproveWorkflowRunRequest(args, w, r)
															return
														}
													case 'c': // Prefix: "cancel"
														if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsCancelWorkflowRun
															s.handleActionsCancelWorkflowRunRequest(args, w, r)
															return
														}
													case 'p': // Prefix: "pending_deployments"
														if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsReviewPendingDeploymentsForRun
															s.handleActionsReviewPendingDeploymentsForRunRequest(args, w, r)
															return
														}
													case 'r': // Prefix: "re"
														if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsRetryWorkflowRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'r': // Prefix: "run"
															if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsReRunWorkflow
																s.handleActionsReRunWorkflowRequest(args, w, r)
																return
															}
														case 't': // Prefix: "try"
															if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsRetryWorkflow
																s.handleActionsRetryWorkflowRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										}
									case 'u': // Prefix: "utolinks"
										if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposCreateAutolink
											s.handleReposCreateAutolinkRequest(args, w, r)
											return
										}
									}
								case 'b': // Prefix: "branches/"
									if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "branch"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["branch"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposRenameBranchRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'p': // Prefix: "protection/"
												if l := len("protection/"); len(elem) >= l && elem[0:l] == "protection/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposSetAdminBranchProtectionRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'e': // Prefix: "enforce_admins"
													if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposSetAdminBranchProtection
														s.handleReposSetAdminBranchProtectionRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "re"
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposAddStatusCheckContextsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'q': // Prefix: "quired_s"
														if l := len("quired_s"); len(elem) >= l && elem[0:l] == "quired_s" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposCreateCommitSignatureProtectionRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'i': // Prefix: "ignatures"
															if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposCreateCommitSignatureProtection
																s.handleReposCreateCommitSignatureProtectionRequest(args, w, r)
																return
															}
														case 't': // Prefix: "tatus_checks/contexts"
															if l := len("tatus_checks/contexts"); len(elem) >= l && elem[0:l] == "tatus_checks/contexts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposAddStatusCheckContexts
																s.handleReposAddStatusCheckContextsRequest(args, w, r)
																return
															}
														}
													case 's': // Prefix: "strictions/"
														if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposAddTeamAccessRestrictionsRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'a': // Prefix: "apps"
															if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposAddAppAccessRestrictions
																s.handleReposAddAppAccessRestrictionsRequest(args, w, r)
																return
															}
														case 't': // Prefix: "teams"
															if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposAddTeamAccessRestrictions
																s.handleReposAddTeamAccessRestrictionsRequest(args, w, r)
																return
															}
														case 'u': // Prefix: "users"
															if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposAddUserAccessRestrictions
																s.handleReposAddUserAccessRestrictionsRequest(args, w, r)
																return
															}
														}
													}
												}
											case 'r': // Prefix: "rename"
												if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposRenameBranch
													s.handleReposRenameBranchRequest(args, w, r)
													return
												}
											}
										}
									}
								case 'c': // Prefix: "c"
									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleChecksCreateSuiteRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'h': // Prefix: "heck-suites"
										if l := len("heck-suites"); len(elem) >= l && elem[0:l] == "heck-suites" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleChecksCreateSuiteRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "check_suite_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["check_suite_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/rerequest"
													if l := len("/rerequest"); len(elem) >= l && elem[0:l] == "/rerequest" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ChecksRerequestSuite
														s.handleChecksRerequestSuiteRequest(args, w, r)
														return
													}
												}
											}
										}
									case 'o': // Prefix: "o"
										if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleCodeScanningUploadSarifRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'd': // Prefix: "de-scanning/sarifs"
											if l := len("de-scanning/sarifs"); len(elem) >= l && elem[0:l] == "de-scanning/sarifs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: CodeScanningUploadSarif
												s.handleCodeScanningUploadSarifRequest(args, w, r)
												return
											}
										case 'm': // Prefix: "mm"
											if l := len("mm"); len(elem) >= l && elem[0:l] == "mm" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposCreateCommitCommentRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'e': // Prefix: "ents/"
												if l := len("ents/"); len(elem) >= l && elem[0:l] == "ents/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["comment_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsCreateForCommitComment
															s.handleReactionsCreateForCommitCommentRequest(args, w, r)
															return
														}
													}
												}
											case 'i': // Prefix: "its/"
												if l := len("its/"); len(elem) >= l && elem[0:l] == "its/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "commit_sha"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["commit_sha"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/comments"
														if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposCreateCommitComment
															s.handleReposCreateCommitCommentRequest(args, w, r)
															return
														}
													}
												}
											}
										case 'n': // Prefix: "ntent_references/"
											if l := len("ntent_references/"); len(elem) >= l && elem[0:l] == "ntent_references/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "content_reference_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["content_reference_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/attachments"
													if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: AppsCreateContentAttachment
														s.handleAppsCreateContentAttachmentRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								case 'd': // Prefix: "d"
									if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateDispatchEventRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "eployments"
										if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposCreateDeploymentRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "deployment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["deployment_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/statuses"
													if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposCreateDeploymentStatus
														s.handleReposCreateDeploymentStatusRequest(args, w, r)
														return
													}
												}
											}
										}
									case 'i': // Prefix: "ispatches"
										if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposCreateDispatchEvent
											s.handleReposCreateDispatchEventRequest(args, w, r)
											return
										}
									}
								case 'f': // Prefix: "forks"
									if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposCreateFork
										s.handleReposCreateForkRequest(args, w, r)
										return
									}
								case 'g': // Prefix: "g"
									if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateUsingTemplateRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "enerate"
										if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposCreateUsingTemplate
											s.handleReposCreateUsingTemplateRequest(args, w, r)
											return
										}
									case 'i': // Prefix: "it/"
										if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleGitCreateCommitRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'b': // Prefix: "blobs"
											if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: GitCreateBlob
												s.handleGitCreateBlobRequest(args, w, r)
												return
											}
										case 'c': // Prefix: "commits"
											if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: GitCreateCommit
												s.handleGitCreateCommitRequest(args, w, r)
												return
											}
										case 'r': // Prefix: "refs"
											if l := len("refs"); len(elem) >= l && elem[0:l] == "refs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: GitCreateRef
												s.handleGitCreateRefRequest(args, w, r)
												return
											}
										case 't': // Prefix: "t"
											if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleGitCreateTreeRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'a': // Prefix: "ags"
												if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: GitCreateTag
													s.handleGitCreateTagRequest(args, w, r)
													return
												}
											case 'r': // Prefix: "rees"
												if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: GitCreateTree
													s.handleGitCreateTreeRequest(args, w, r)
													return
												}
											}
										}
									}
								case 'h': // Prefix: "hooks"
									if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateWebhookRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "hook_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["hook_id"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposRedeliverWebhookDeliveryRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'd': // Prefix: "deliveries/"
													if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "delivery_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["delivery_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/attempts"
															if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRedeliverWebhookDelivery
																s.handleReposRedeliverWebhookDeliveryRequest(args, w, r)
																return
															}
														}
													}
												case 'p': // Prefix: "pings"
													if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposPingWebhook
														s.handleReposPingWebhookRequest(args, w, r)
														return
													}
												case 't': // Prefix: "tests"
													if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposTestPushWebhook
														s.handleReposTestPushWebhookRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								case 'i': // Prefix: "issues"
									if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleIssuesCreateRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["comment_id"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/reactions"
													if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsCreateForIssueComment
														s.handleReactionsCreateForIssueCommentRequest(args, w, r)
														return
													}
												}
											}
										}
										// Param: "issue_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["issue_number"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesCreateCommentRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'a': // Prefix: "assignees"
													if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesAddAssignees
														s.handleIssuesAddAssigneesRequest(args, w, r)
														return
													}
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesCreateComment
														s.handleIssuesCreateCommentRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "reactions"
													if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsCreateForIssue
														s.handleReactionsCreateForIssueRequest(args, w, r)
														return
													}
												}
											}
										}
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposCreateDeployKey
										s.handleReposCreateDeployKeyRequest(args, w, r)
										return
									}
								case 'l': // Prefix: "labels"
									if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: IssuesCreateLabel
										s.handleIssuesCreateLabelRequest(args, w, r)
										return
									}
								case 'm': // Prefix: "m"
									if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposMergeRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'e': // Prefix: "erge"
										if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposMergeUpstreamRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '-': // Prefix: "-upstream"
											if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposMergeUpstream
												s.handleReposMergeUpstreamRequest(args, w, r)
												return
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposMerge
												s.handleReposMergeRequest(args, w, r)
												return
											}
										}
									case 'i': // Prefix: "ilestones"
										if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesCreateMilestone
											s.handleIssuesCreateMilestoneRequest(args, w, r)
											return
										}
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePullsCreateRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'a': // Prefix: "ages"
										if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposCreatePagesSiteRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/builds"
											if l := len("/builds"); len(elem) >= l && elem[0:l] == "/builds" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposRequestPagesBuild
												s.handleReposRequestPagesBuildRequest(args, w, r)
												return
											}
										}
									case 'r': // Prefix: "rojects"
										if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ProjectsCreateForRepo
											s.handleProjectsCreateForRepoRequest(args, w, r)
											return
										}
									case 'u': // Prefix: "ulls"
										if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handlePullsCreateRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "comments/"
												if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["comment_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsCreateForPullRequestReviewComment
															s.handleReactionsCreateForPullRequestReviewCommentRequest(args, w, r)
															return
														}
													}
												}
											}
											// Param: "pull_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["pull_number"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handlePullsCreateReviewRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePullsCreateReviewCommentRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["comment_id"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/replies"
																	if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: PullsCreateReplyForReviewComment
																		s.handlePullsCreateReplyForReviewCommentRequest(args, w, r)
																		return
																	}
																}
															}
														}
													case 'r': // Prefix: "reviews"
														if l := len("reviews"); len(elem) >= l && elem[0:l] == "reviews" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePullsCreateReviewRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "review_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx > 0 {
																args["review_id"] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/events"
																	if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: PullsSubmitReview
																		s.handlePullsSubmitReviewRequest(args, w, r)
																		return
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "releases"
									if l := len("releases"); len(elem) >= l && elem[0:l] == "releases" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateReleaseRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "release_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["release_id"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/reactions"
												if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReactionsCreateForRelease
													s.handleReactionsCreateForReleaseRequest(args, w, r)
													return
												}
											}
										}
									}
								case 's': // Prefix: "statuses/"
									if l := len("statuses/"); len(elem) >= l && elem[0:l] == "statuses/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "sha"
									// Leaf parameter
									args["sha"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposCreateCommitStatus
										s.handleReposCreateCommitStatusRequest(args, w, r)
										return
									}
								case 't': // Prefix: "transfer"
									if l := len("transfer"); len(elem) >= l && elem[0:l] == "transfer" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposTransfer
										s.handleReposTransferRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups"
							if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseGroup
								s.handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(args, w, r)
								return
							}
						case 'U': // Prefix: "Users"
							if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseUser
								s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args, w, r)
								return
							}
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["team_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/discussions"
						if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsCreateDiscussionLegacyRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["discussion_number"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReactionsCreateForTeamDiscussionLegacyRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'c': // Prefix: "comments"
										if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleTeamsCreateDiscussionCommentLegacyRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["comment_number"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/reactions"
													if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsCreateForTeamDiscussionCommentLegacy
														s.handleReactionsCreateForTeamDiscussionCommentLegacyRequest(args, w, r)
														return
													}
												}
											}
										}
									case 'r': // Prefix: "reactions"
										if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForTeamDiscussionLegacy
											s.handleReactionsCreateForTeamDiscussionLegacyRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handlePackagesRestorePackageForUserRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handlePackagesRestorePackageForAuthenticatedUserRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersAddEmailForAuthenticated
							s.handleUsersAddEmailForAuthenticatedRequest(args, w, r)
							return
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreateGpgKeyForAuthenticated
							s.handleUsersCreateGpgKeyForAuthenticatedRequest(args, w, r)
							return
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreatePublicSSHKeyForAuthenticated
							s.handleUsersCreatePublicSSHKeyForAuthenticatedRequest(args, w, r)
							return
						}
					case 'm': // Prefix: "migrations"
						if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: MigrationsStartForAuthenticatedUser
							s.handleMigrationsStartForAuthenticatedUserRequest(args, w, r)
							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleProjectsCreateForAuthenticatedUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["package_type"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["package_name"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'r': // Prefix: "restore"
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: PackagesRestorePackageForAuthenticatedUser
													s.handlePackagesRestorePackageForAuthenticatedUserRequest(args, w, r)
													return
												}
											case 'v': // Prefix: "versions/"
												if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["package_version_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/restore"
														if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PackagesRestorePackageVersionForAuthenticatedUser
															s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args, w, r)
															return
														}
													}
												}
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsCreateForAuthenticatedUser
								s.handleProjectsCreateForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ReposCreateForAuthenticatedUser
							s.handleReposCreateForAuthenticatedUserRequest(args, w, r)
							return
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["username"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/packages/"
							if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["package_type"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx > 0 {
										args["package_name"] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePackagesRestorePackageVersionForUserRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'r': // Prefix: "restore"
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: PackagesRestorePackageForUser
													s.handlePackagesRestorePackageForUserRequest(args, w, r)
													return
												}
											case 'v': // Prefix: "versions/"
												if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx > 0 {
													args["package_version_id"] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/restore"
														if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PackagesRestorePackageVersionForUser
															s.handlePackagesRestorePackageVersionForUserRequest(args, w, r)
															return
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case "PUT":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsCreateOrUpdateEnvironmentSecretRequest(args, w, r)
				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp/installations/"
					if l := len("pp/installations/"); len(elem) >= l && elem[0:l] == "pp/installations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "installation_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["installation_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/suspended"
							if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsSuspendInstallation
								s.handleAppsSuspendInstallationRequest(args, w, r)
								return
							}
						}
					}
				case 'u': // Prefix: "uthorizations/clients/"
					if l := len("uthorizations/clients/"); len(elem) >= l && elem[0:l] == "uthorizations/clients/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "client_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["client_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args, w, r)
							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "fingerprint"
							// Leaf parameter
							args["fingerprint"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint
								s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(args, w, r)
								return
							}
						}
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/actions/"
						if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions"
							if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args, w, r)
									return
								}
								switch elem[0] {
								case 'o': // Prefix: "organizations"
									if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org_id"
										// Leaf parameter
										args["org_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
											s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args, w, r)
											return
										}
									}
								case 's': // Prefix: "selected-actions"
									if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminSetAllowedActionsEnterprise
										s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args, w, r)
										return
									}
								}
							}
						case 'r': // Prefix: "runner-groups/"
							if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["runner_group_id"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'o': // Prefix: "organizations"
										if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "org_id"
											// Leaf parameter
											args["org_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
												s.handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args, w, r)
												return
											}
										}
									case 'r': // Prefix: "runners"
										if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_id"
											// Leaf parameter
											args["runner_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
												s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["gist_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/star"
						if l := len("/star"); len(elem) >= l && elem[0:l] == "/star" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: GistsStar
							s.handleGistsStarRequest(args, w, r)
							return
						}
					}
				}
			case 'n': // Prefix: "notifications"
				if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActivityMarkNotificationsAsReadRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/threads/"
					if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "thread_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["thread_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"
							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivitySetThreadSubscription
								s.handleActivitySetThreadSubscriptionRequest(args, w, r)
								return
							}
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["org"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleInteractionsSetRestrictionsForOrgRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'a': // Prefix: "actions/"
							if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsAddSelectedRepoToOrgSecretRequest(args, w, r)
								return
							}
							switch elem[0] {
							case 'p': // Prefix: "permissions"
								if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsSetGithubActionsPermissionsOrganizationRequest(args, w, r)
									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsSetAllowedActionsOrganizationRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'r': // Prefix: "repositories"
										if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repository_id"
											// Leaf parameter
											args["repository_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsEnableSelectedRepositoryGithubActionsOrganization
												s.handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(args, w, r)
												return
											}
										}
									case 's': // Prefix: "selected-actions"
										if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActionsSetAllowedActionsOrganization
											s.handleActionsSetAllowedActionsOrganizationRequest(args, w, r)
											return
										}
									}
								}
							case 'r': // Prefix: "runner-groups/"
								if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_group_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["runner_group_id"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/r"
										if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'e': // Prefix: "epositories"
											if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repository_id"
												// Leaf parameter
												args["repository_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
													s.handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(args, w, r)
													return
												}
											}
										case 'u': // Prefix: "unners"
											if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsSetSelfHostedRunnersInGroupForOrgRequest(args, w, r)
												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_id"
												// Leaf parameter
												args["runner_id"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsAddSelfHostedRunnerToGroupForOrg
													s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args, w, r)
													return
												}
											}
										}
									}
								}
							case 's': // Prefix: "secrets/"
								if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "secret_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx > 0 {
									args["secret_name"] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleActionsCreateOrUpdateOrgSecretRequest(args, w, r)
										return
									}
									switch elem[0] {
									case '/': // Prefix: "/repositories"
										if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsSetSelectedReposForOrgSecretRequest(args, w, r)
											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repository_id"
											// Leaf parameter
											args["repository_id"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsAddSelectedRepoToOrgSecret
												s.handleActionsAddSelectedRepoToOrgSecretRequest(args, w, r)
												return
											}
										}
									}
								}
							}
						case 'b': // Prefix: "blocks/"
							if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsBlockUser
								s.handleOrgsBlockUserRequest(args, w, r)
								return
							}
						case 'i': // Prefix: "interaction-limits"
							if l := len("interaction-limits"); len(elem) >= l && elem[0:l] == "interaction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsSetRestrictionsForOrg
								s.handleInteractionsSetRestrictionsForOrgRequest(args, w, r)
								return
							}
						case 'm': // Prefix: "memberships/"
							if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsSetMembershipForUser
								s.handleOrgsSetMembershipForUserRequest(args, w, r)
								return
							}
						case 'o': // Prefix: "outside_collaborators/"
							if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsConvertMemberToOutsideCollaborator
								s.handleOrgsConvertMemberToOutsideCollaboratorRequest(args, w, r)
								return
							}
						case 'p': // Prefix: "public_members/"
							if l := len("public_members/"); len(elem) >= l && elem[0:l] == "public_members/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args["username"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsSetPublicMembershipForAuthenticatedUser
								s.handleOrgsSetPublicMembershipForAuthenticatedUserRequest(args, w, r)
								return
							}
						case 't': // Prefix: "teams/"
							if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "team_slug"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["team_slug"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'm': // Prefix: "memberships/"
										if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args["username"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: TeamsAddOrUpdateMembershipForUserInOrg
											s.handleTeamsAddOrUpdateMembershipForUserInOrgRequest(args, w, r)
											return
										}
									case 'p': // Prefix: "projects/"
										if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "project_id"
										// Leaf parameter
										args["project_id"] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: TeamsAddOrUpdateProjectPermissionsInOrg
											s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args, w, r)
											return
										}
									case 'r': // Prefix: "repos/"
										if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "owner"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["owner"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "repo"
												// Leaf parameter
												args["repo"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsAddOrUpdateRepoPermissionsInOrg
													s.handleTeamsAddOrUpdateRepoPermissionsInOrgRequest(args, w, r)
													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["project_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/collaborators/"
						if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args["username"] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsAddCollaborator
							s.handleProjectsAddCollaboratorRequest(args, w, r)
							return
						}
					}
				}
			case 'r': // Prefix: "repos"
				if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActionsCreateOrUpdateRepoSecretRequest(args, w, r)
					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["owner"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["repo"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActivityMarkRepoNotificationsAsReadRequest(args, w, r)
										return
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposEnableAutomatedSecurityFixesRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'c': // Prefix: "ctions/"
											if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsSetAllowedActionsRepositoryRequest(args, w, r)
												return
											}
											switch elem[0] {
											case 'p': // Prefix: "permissions"
												if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsSetGithubActionsPermissionsRepositoryRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/selected-actions"
													if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsSetAllowedActionsRepository
														s.handleActionsSetAllowedActionsRepositoryRequest(args, w, r)
														return
													}
												}
											case 's': // Prefix: "secrets/"
												if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "secret_name"
												// Leaf parameter
												args["secret_name"] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsCreateOrUpdateRepoSecret
													s.handleActionsCreateOrUpdateRepoSecretRequest(args, w, r)
													return
												}
											}
										case 'u': // Prefix: "utomated-security-fixes"
											if l := len("utomated-security-fixes"); len(elem) >= l && elem[0:l] == "utomated-security-fixes" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposEnableAutomatedSecurityFixes
												s.handleReposEnableAutomatedSecurityFixesRequest(args, w, r)
												return
											}
										}
									case 'b': // Prefix: "branches/"
										if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "branch"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["branch"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/protection"
												if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposUpdateBranchProtectionRequest(args, w, r)
													return
												}
												switch elem[0] {
												case '/': // Prefix: "/re"
													if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposSetStatusCheckContextsRequest(args, w, r)
														return
													}
													switch elem[0] {
													case 'q': // Prefix: "quired_status_checks/contexts"
														if l := len("quired_status_checks/contexts"); len(elem) >= l && elem[0:l] == "quired_status_checks/contexts" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposSetStatusCheckContexts
															s.handleReposSetStatusCheckContextsRequest(args, w, r)
															return
														}
													case 's': // Prefix: "strictions/"
														if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposSetTeamAccessRestrictionsRequest(args, w, r)
															return
														}
														switch elem[0] {
														case 'a': // Prefix: "apps"
															if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposSetAppAccessRestrictions
																s.handleReposSetAppAccessRestrictionsRequest(args, w, r)
																return
															}
														case 't': // Prefix: "teams"
															if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposSetTeamAccessRestrictions
																s.handleReposSetTeamAccessRestrictionsRequest(args, w, r)
																return
															}
														case 'u': // Prefix: "users"
															if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposSetUserAccessRestrictions
																s.handleReposSetUserAccessRestrictionsRequest(args, w, r)
																return
															}
														}
													}
												}
											}
										}
									case 'c': // Prefix: "co"
										if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposCreateOrUpdateFileContentsRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'l': // Prefix: "llaborators/"
											if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "username"
											// Leaf parameter
											args["username"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposAddCollaborator
												s.handleReposAddCollaboratorRequest(args, w, r)
												return
											}
										case 'n': // Prefix: "ntents/"
											if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "path"
											// Leaf parameter
											args["path"] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposCreateOrUpdateFileContents
												s.handleReposCreateOrUpdateFileContentsRequest(args, w, r)
												return
											}
										}
									case 'i': // Prefix: "i"
										if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleIssuesLockRequest(args, w, r)
											return
										}
										switch elem[0] {
										case 'm': // Prefix: "mport"
											if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsStartImport
												s.handleMigrationsStartImportRequest(args, w, r)
												return
											}
										case 'n': // Prefix: "nteraction-limits"
											if l := len("nteraction-limits"); len(elem) >= l && elem[0:l] == "nteraction-limits" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: InteractionsSetRestrictionsForRepo
												s.handleInteractionsSetRestrictionsForRepoRequest(args, w, r)
												return
											}
										case 's': // Prefix: "ssues/"
											if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "issue_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx > 0 {
												args["issue_number"] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/lock"
													if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesLock
														s.handleIssuesLockRequest(args, w, r)
														return
													}
												}
											}
										}
									case 'l': // Prefix: "lfs"
										if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposEnableLfsForRepo
											s.handleReposEnableLfsForRepoRequest(args, w, r)
											return
										}
									case 'n': // Prefix: "notifications"
										if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityMarkRepoNotificationsAsRead
											s.handleActivityMarkRepoNotificationsAsReadRequest(args, w, r)
											return
										}
									case 'p': // Prefix: "pulls/"
										if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "pull_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx > 0 {
											args["pull_number"] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePullsMergeRequest(args, w, r)
													return
												}
												switch elem[0] {
												case 'm': // Prefix: "merge"
													if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsMerge
														s.handlePullsMergeRequest(args, w, r)
														return
													}
												case 'r': // Prefix: "reviews/"
													if l := len("reviews/"); len(elem) >= l && elem[0:l] == "reviews/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "review_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx > 0 {
														args["review_id"] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handlePullsUpdateReviewRequest(args, w, r)
															return
														}
														switch elem[0] {
														case '/': // Prefix: "/dismissals"
															if l := len("/dismissals"); len(elem) >= l && elem[0:l] == "/dismissals" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: PullsDismissReview
																s.handlePullsDismissReviewRequest(args, w, r)
																return
															}
														}
													}
												case 'u': // Prefix: "update-branch"
													if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsUpdateBranch
														s.handlePullsUpdateBranchRequest(args, w, r)
														return
													}
												}
											}
										}
									case 's': // Prefix: "subscription"
										if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivitySetRepoSubscription
											s.handleActivitySetRepoSubscriptionRequest(args, w, r)
											return
										}
									case 't': // Prefix: "topics"
										if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposReplaceAllTopics
											s.handleReposReplaceAllTopicsRequest(args, w, r)
											return
										}
									case 'v': // Prefix: "vulnerability-alerts"
										if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposEnableVulnerabilityAlerts
											s.handleReposEnableVulnerabilityAlertsRequest(args, w, r)
											return
										}
									}
								}
							}
						}
					}
				case 'i': // Prefix: "itories/"
					if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repository_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["repository_id"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/environments/"
							if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "environment_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["environment_name"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/secrets/"
									if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "secret_name"
									// Leaf parameter
									args["secret_name"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActionsCreateOrUpdateEnvironmentSecret
										s.handleActionsCreateOrUpdateEnvironmentSecretRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["enterprise"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups/"
							if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_group_id"
							// Leaf parameter
							args["scim_group_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseGroup
								s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(args, w, r)
								return
							}
						case 'U': // Prefix: "Users/"
							if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args["scim_user_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseUser
								s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args, w, r)
								return
							}
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx > 0 {
					args["team_id"] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args, w, r)
							return
						}
						switch elem[0] {
						case 'm': // Prefix: "members"
							if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args, w, r)
								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddMemberLegacy
									s.handleTeamsAddMemberLegacyRequest(args, w, r)
									return
								}
							case 'h': // Prefix: "hips/"
								if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args["username"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddOrUpdateMembershipForUserLegacy
									s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args, w, r)
									return
								}
							}
						case 'p': // Prefix: "projects/"
							if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args["project_id"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddOrUpdateProjectPermissionsLegacy
								s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args, w, r)
								return
							}
						case 'r': // Prefix: "repos/"
							if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx > 0 {
								args["owner"] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args["repo"] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsAddOrUpdateRepoPermissionsLegacy
										s.handleTeamsAddOrUpdateRepoPermissionsLegacyRequest(args, w, r)
										return
									}
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user/"
				if l := len("user/"); len(elem) >= l && elem[0:l] == "user/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleAppsAddRepoToInstallationRequest(args, w, r)
					return
				}
				switch elem[0] {
				case 'b': // Prefix: "blocks/"
					if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args["username"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersBlock
						s.handleUsersBlockRequest(args, w, r)
						return
					}
				case 'f': // Prefix: "following/"
					if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args["username"] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersFollow
						s.handleUsersFollowRequest(args, w, r)
						return
					}
				case 'i': // Prefix: "in"
					if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args, w, r)
						return
					}
					switch elem[0] {
					case 's': // Prefix: "stallations/"
						if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx > 0 {
							args["installation_id"] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories/"
								if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args["repository_id"] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsAddRepoToInstallation
									s.handleAppsAddRepoToInstallationRequest(args, w, r)
									return
								}
							}
						}
					case 't': // Prefix: "teraction-limits"
						if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: InteractionsSetRestrictionsForAuthenticatedUser
							s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args, w, r)
							return
						}
					}
				case 's': // Prefix: "starred/"
					if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx > 0 {
						args["owner"] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args["repo"] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActivityStarRepoForAuthenticatedUser
								s.handleActivityStarRepoForAuthenticatedUserRequest(args, w, r)
								return
							}
						}
					}
				}
			}
		}
	}
	s.notFound(w, r)
}
